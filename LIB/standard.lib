// $Id: standard.lib,v 1.18 1998-06-03 10:04:26 obachman Exp $
//////////////////////////////////////////////////////////////////////////////

version="$Id: standard.lib,v 1.18 1998-06-03 10:04:26 obachman Exp $";
info="
LIBRARY: standard.lib   PROCEDURES WHICH ARE ALWAYS LOADED AT START-UP

 stdfglm(ideal[,ord])   standard basis of the ideal via fglm [and ordering ord]
 stdhilb(ideal)         standard basis of the ideal using the Hilbert function
 groebner(ideal/module) standard basis of ideal or module using a
                        heuristically choosen method
";

//////////////////////////////////////////////////////////////////////////////

proc stdfglm (ideal i, list #)
"USAGE:   stdfglm(i[,s]); i ideal, s string (any allowed ordstr of a ring)
RETURN:  stdfglm(i): standard basis of i in the basering, calculated via fglm
                     from ordering \"dp\" to the ordering of the basering.
         stdfglm(i,s): standard basis of i in the basering, calculated via
                     fglm from ordering s to the ordering of the basering.
EXAMPLE: example stdfglm; shows an example"
{
   string os;
   def dr= basering;
   if( (size(#)==0) or (typeof(#[1]) != "string") )
   {
     os = "dp(" + string( nvars(dr) ) + ")";
     if ( (find( ordstr(dr), os ) != 0) and (find( ordstr(dr), "a") == 0) )
     {
       os= "Dp";
     }
     else
     {
       os= "dp";
     }
   }
   else { os = #[1]; }
   execute "ring sr=("+charstr(dr)+"),("+varstr(dr)+"),"+os+";";
   ideal i= fetch(dr,i);
   intvec opt= option(get);
   option(redSB);
   i=std(i);
   option(set,opt);
   setring dr;
   return (fglm(sr,i));
}
example
{ "EXAMPLE:"; echo = 2;
   ring r  = 0,(x,y,z),lp;
   ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
   ideal i1= stdfglm(i);         //uses fglm from "dp" to "lp"
   i1;
   ideal i2= stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
   i2;
}
/////////////////////////////////////////////////////////////////////////////

proc stdhilb(ideal i,list #)
"USAGE:   stdhilb(i);  i ideal
         stdhilb(i,v); i homogeneous ideal, v intvec (the Hilbert function)
RETURN:  stdhilb(i): a standard basis of i (computing v internally)
         stdhilb(i,v): standard basis of i, using the given Hilbert function
EXAMPLE: example stdhilb; shows an example"
{
   def R=basering;

   if((homog(i)==1)||(ordstr(basering)[1]=="d"))
   {
      if ((size(#)!=0)&&(homog(i)==1))
      {
         return(std(i,#[1]));
      }
      return(std(i));
   }

   execute "ring S = ("+charstr(R)+"),("+varstr(R)+",@t),dp;";
   ideal i=homog(imap(R,i),@t);
   intvec v=hilb(std(i),1);
   execute "ring T = ("+charstr(R)+"),("+varstr(R)+",@t),("+ordstr(R)+");";
   ideal i=fetch(S,i);
   ideal a=std(i,v);
   setring R;
   map phi=T,maxideal(1),1;
   ideal a=phi(a);

   int k,j;
   poly m;
   int c=size(i);

   for(j=1;j<c;j++)
   {
     if(deg(a[j])==0)
     {
       a=ideal(1);
       attrib(a,"isSB",1);
       return(a);
     }
     if(deg(a[j])>0)
     {
       m=lead(a[j]);
       for(k=j+1;k<=c;k++)
       {
          if(size(lead(a[k])/m)>0)
          {
            a[k]=0;
          }
       }
     }
   }
   a=simplify(a,2);
   attrib(a,"isSB",1);
   return(a);
}
example
{ "EXAMPLE:"; echo = 2;
   ring  r = 0,(x,y,z),lp;
   ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
   ideal i1= stdhilb(i); i1;
   // is in this case equivalent to:
   intvec v=1,0,0,-3,0,1,0,3,-1,-1;
   ideal i2=stdhilb(i,v);
}
//////////////////////////////////////////////////////////////////////////

proc groebner(def i, list #)
"USAGE: groebner(i[, wait]) i -- ideal/module; wait -- int
RETURNS: Standard basis of ideal or module which is computed using a
         heuristically choosen method:
         If the ordering of the current ring is a local ordering, or
         if it is a non-block ordering and the current ring has no
         parameters, then std(i) is returned.
         Otherwise, i is mapped into a ring with no parameters and
         ordering dp, where its Hilbert series is computed. This is
         followed by a Hilbert-series based std computation in the
         original ring.
NOTE: If a 2nd argument 'wait' is given, then the computation proceeds
      at most 'wait' seconds. That is, if no result could be computed in
      'wait' seconds, then the computation is interrupted, 0 is returned,
      a warning message is displayed, and the global variable
      'groebner_error' is defined.
EXAMPLE: example groebner; shows an example"
{
  def P=basering;

  // we have two arguments -- try to use MPfork links
  if (size(#) > 0)
  {
    if (system("with", "MP"))
    {
      if (typeof(#[1]) == "int")
      {
        int wait = #[1];
        int j = 10;

        string bs = nameof(basering);
        link l_fork = "MPtcp:fork";
        open(l_fork);
        write(l_fork, quote(system("pid")));
        int pid = read(l_fork);
        write(l_fork, quote(groebner(eval(i))));

        // sleep in small intervalls for appr. one second
        if (wait > 0)
        {
          while(j < 1000000)
          {
            if (status(l_fork, "read", "ready", j)) {break;}
            j = j + j;
          }
        }

        // sleep in intervalls of one second from now on
        j = 1;
        while (j < wait)
        {
          if (status(l_fork, "read", "ready", 1000000)) {break;}
          j = j + 1;
        }

        if (status(l_fork, "read", "ready"))
        {
          def result = read(l_fork);
          if (bs != nameof(basering))
          {
            def PP = basering;
            setring P;
            def result = imap(PP, result);
            kill PP;
          }
          if (defined(groebner_error))
          {
            kill(groebner_error);
          }
          kill (l_fork);
        }
        else
        {
          ideal result;
          if (! defined(groebner_error))
          {
            int groebner_error = 1;
            export groebner_error;
          }
          "// ** groebner did not finish";
          j = system("sh", "kill " + string(pid));
        }
        return (result);
      }
      else
      {
        "// ** groebner needs int as 2nd arg";
      }
    }
    else
    {
      "// ** groebner with two args not supported in this configuration";
    }
  }

  // we are still here -- do the actual computation
  string ordstr_P = ordstr(P);
  if (find(ordstr_P,"s") > 0)
  {
    //spaeter den lokalen fall ueber lp oder aehnlich behandeln
    return(std(i));
  }

  int IsSimple_P;
  if (system("nblocks") <= 2)
  {
    if (find(ordstr_P, "M") <= 0)
    {
      IsSimple_P = 1;
    }
  }
  int npars_P = npars(P);

  // return std if no parameters and (dp or wp)
  if ((npars_P == 0) && IsSimple_P)
  {
    if (find(ordstr_P, "d") > 0)
    {
      return (std(i));
    }
    if (find(ordstr_P,"w") > 0)
    {
      return (std(i));
    }
  }

  // reset options
  intvec opt=option(get);
  int p_opt;
  string s_opt = option();
  option(none);
  // turn on option(prot) and/or option(mem), if previously set
  if (find(s_opt, "prot"))
  {
    option(prot);
    p_opt = 1;
  }
  if (find(s_opt, "mem"))
  {
    option(mem);
  }

  // construct ring in which first std computation is done
  string varstr_P = varstr(P);
  string parstr_P = parstr(P);
  int is_homog = (homog(i) && (npars_P == 0));

  string ri = "ring Phelp =" + string(char(P)) + ",(" + varstr_P;
  // parameters are converted to ring variables
  if (npars_P > 0)
  {
    ri = ri + "," + parstr_P;
  }
  // a homogenizing variable is added, if necessary
  if (! is_homog)
  {
    ri = ri + ",@t";
  }
  // ordering is set to (dp, C)
  ri = ri + "),(dp,C);";

  // change the ring
  execute(ri);

  // get ideal from previous ring
  if (is_homog)
  {
    ideal qh = imap(P, i);
  }
  else
  {
    // and homogenize
    ideal qh=homog(imap(P,i),@t);
  }

  // compute std and hilbert series
  if (p_opt)
  {
    "std in " + ri[13, size(ri) - 13];
  }
  ideal qh1=std(qh);
  intvec hi=hilb(qh1,1);

  if (is_homog && (npars_P == 0))
  {
    // no additional variables were introduced
    setring P; // can immediately change to original ring
    // simply compute std with hilbert series in original ring
    if (p_opt)
    {
      "std with hilb in basering";
      i = std(i, hi);
    }
  }
  else
  {
    // additional variables were introduced
    // need another intermediate ring
    ri = "ring Phelp1 =" + string(char(P))
      + ",(" + varstr(Phelp) + "),(" + ordstr_P;

    // for lp without parameters, we do not need a block ordering
    if ( ! (IsSimple_P && (npars_P + is_homog < 2) && find(ordstr_P, "l")))
    {
      // need block ordering
      ri = ri + ", dp(" + string(npars_P + is_homog) + ")";
    }
    ri = ri + ");";

    // change to intermediate ring
    execute(ri);
    ideal qh = imap(Phelp, qh);
    kill Phelp;
    if (p_opt)
    {
      "std with hilb in " + ri[14,size(ri)-14];
    }
    // compute std with Hilbert series
    qh = std(qh, hi);
    // subst 1 for homogenizing var
    if (!is_homog)
    {
      qh = subst(qh, @t, 1);
    }

    // go back to original ring
    setring P;
    // get ideal, delete zeros and clean SB
    i = imap(Phelp1,qh);
    i = simplify(i, 34);
    kill Phelp1;
  }

  // clean-up time
  option(set, opt);
  if (find(s_opt, "redSB") > 0)
  {
    i=interred(i);
  }
  attrib(i, "isSB", 1);
  return (i);
}
example
{
  "EXAMPLE: "; echo = 2;
  ring r = 0, (a,b,c,d), lp;
  option(prot);
  ideal i = a+b+c+d, ab+ad+bc+cd, abc+abd+acd+bcd, abcd-1; // cyclic 4
  groebner(i);
  ring rp = (0, a, b), (c,d), lp;
  ideal i = imap(r, i);
  ideal j = groebner(i);
  option(noprot);
  j; simplify(j, 1); std(i);
  if (system("with", "MP")) {groebner(i, 0);}
  defined(groebner_error);
}


//////////////////////////////////////////////////////////////////////////
proc res(list #)
{
   def P=basering;
   def m=#[1]; //the ideal or module

   int i=#[2]; //the length of the resolution
               //if size(#)>2 a minimal resolution is computed

   //LaScala for the homogeneous case
   if(homog(m)==1)
   {
      resolution re=lres(m,i);
      if(size(#)>2)
      {
         re=minres(re);
      }
      return(re);
   }

   //mres for the global non homogeneous case
   if(find(ordstr(P),"s")==0)
   {
      string ri= "ring Phelp ="
                  +string(char(P))+",("+varstr_P+"),(dp,C);";
      execute(ri);
      def m=imap(P,m);
      list re=mres(m,i);
      setring P;
      resolution result=imap(Phelp,re);
      return(result);
   }

   //sres for the local case and not minimal resolution
   if(size(#)<=2)
   {
      string ri= "ring Phelp ="
                  +string(char(P))+",("+varstr_P+"),(ls,c);";
      execute(ri);
      def m=imap(P,m);
      m=std(m);
      list re=sres(m,i);
      setring P;
      resolution result=imap(Phelp,re);
      return(result);
   }

   //mres for the local case and minimal resolution
   string ri= "ring Phelp ="
                  +string(char(P))+",("+varstr_P+"),(ls,C);";
   execute(ri);
   def m=imap(P,m);
   list re=mres(m,i);
   setring P;
   resolution result=imap(Phelp,re);
   return(result);
}

/*
proc minres(list #)
{
  if (size(#) == 2)
  {
    if (typeof(#[1]) == "ideal" || typeof(#[1]) == "module")
    {
      if (typeof(#[2] == "int"))
      {
        return (res(#[1],#[2],1));
      }
    }
  }
  
  if (typeof(#[1]) == "resolution")
  {
    return minimizeres(#[1]);
  }
  else
  {
    return minimizeres(#);
  }
  
}

*/
