
//-*- mode:C++;-*-
// $Id: lejeune.lib,v 1.17 2005-07-04 09:02:47 cremer Exp $


info="
LIBRARY: lejeune.lib  Arc space computations
AUTHOR:  Nadine Cremer,    nadine.cremer@gmx.de
[SEE ALSO: <comma-separated words of cross references>]
[KEYWORDS: <semicolon-separated phrases of index keys>]
PROCEDURES:
    variables(k,i);      creates k*i new var. t,a(1),..,a(i),..,x(1),..,x(i)
    a_z(k);              returns kth letter of the alphabet
    modd(f,g);           modulo-operator for polys
    idealsimplify(I)     simplifies ideal- i.o. to avoid/keep small radical

    tpolys(k,i);         creates polyn. a(1)*t+..+a(n)*t^n
    ringchange(i);       changes the ring to the one needed in ith step      
    plugin_coeffs(i,f)   plugs tpolys into f, up to power i
    diffidealstep(i,N);  returns ideal needed for contraction in ith step
                         N is number of variables of input f
    formaldiff(f,H);     computes the formal derivatives corresponding to H
                         and the desciption of F	  
    f_set(f,H);          returns the set F corresponding to H as described by
                         M. Lejeune
    g_formaldiff(f,H);   computes the formal derivatives corresponding to H
                         and the description of G
    g_set(f,H);          returns the set G corresponding to H as described by
                         M. Lejeune
    ";


LIB "ring.lib";
LIB "general.lib";
LIB "primdec.lib";
LIB "standard.lib";

////////////////////////////////////////////////////////////////////////////
//                 COMPUTATION OF THE F's
////////////////////////////////////////////////////////////////////////////

proc f_set (poly f,intvec H) 
{
  int p;                              // loop variable
  int m_0=order(f); 
  int b=size(H);
  if(H[1]!=m_0)                       // input admissible?!
    {
     "H[1]=ord(f) notwendig!!";
      return(0);
    } 
  for(p=1;p<b;p++)
    {
      if(H[p]<H[p+1])
      {
        "Unzulaessige Eingabe, H[1]<=...<=H[b] notwendig!";
         return(0);
      }
    }

  def r=basering;
  int startvar=nvars(basering);
  export(startvar);
  def R=ringchange(b-1);
  setring R;
  ideal J,I;
  for(p=2;p<=b;p++)
  {
    setring r;
    def tmp=formaldiff(f,intvec(H[1..p]));
    setring R;
    I=imap(tmp,resultdiff);
    kill tmp;
    J=J,I;
  }
  J=simplify(J,4);
  J=simplify(J,2);
  J=idealsimplify(J);
  option(redSB);
  J=std(J);
  J=idealsimplify(J);
  J=radical(simplify(J,4));
  J;
  return(R);
}



////////////////////////////////////////////////////////////////////////////
//              PREPARATORY WORK: plugging in and differentiating
////////////////////////////////////////////////////////////////////////////


proc formaldiff (poly f,intvec H)
{
  int s,t,v;                          // loop variables
  int u;   
  int i=size(H)-1;                    // need those parameters for computation
  int c=sum(H,1..i);
  int k=H[i+1];
  def R=plugin_coeffs(f,i);           // plugs the power series in...
  setring R;                          // changes the ring 
  def Coe=resultplug;   
  matrix coe=Coe;                     // gives the t-coeff. after plugging in 
  poly fkv;                        
  ideal step=diffidealstep(i,startvar);  // computes the corresponding ideal
  ideal m,power,diffstep,J,resultdiff;
  for(v=1;v<=k;v++)                   // consider the different t-coeff.
   { 
     fkv=coe[c+v,1];
     m=fkv;                           
     J=fkv;                           // will save the result in this step
     for(s=1;s<=k-v;s++)
       {
         power=step^s;
         u=size(power);
         for(t=1;t<=u;t++)
          {
            diffstep=contract(power[t],m);     // actual differentiation
	    J=J,diffstep;
          }
       }
     resultdiff=resultdiff,J;
   }
  resultdiff=simplify(resultdiff,2);
  export(resultdiff);                // exports the result
  return(R);                         // return the ring
}


////////////////////////////////////////////////////////////////////////////



proc plugin_coeffs (poly f,int i)
{
  def r=basering;
  def R=ringchange(i);              // changes the ring
  setring R;                        // makes it new basering;
  ideal I=tpolys(i,startvar);
  poly g=imap(r,f);                 // maps f to new basering
  export(g);                        // export it
  map h=r,I;                        // define map according to our purpose
  ideal J=h(f);                     // gives f with power series plugged in
  export(h);                   
  matrix resultplug=coeffs(J[1],t);     // gives the t-coefficients
  export resultplug;                    // export it i.o. to use it later on
  return(R);                        // return ring (ring change!)
}



proc tpolys (int i,int k)             // constructs polynomials a(1)*t+... 
{                                     // has to be called from pluin_coeffs
  int s,t;                            // loop variables
  int v;           
  poly sum; 
  ideal I; 
  for(t=1;t<=k;t++) 
   {  
     v=(t-1)*i; 
     for(s=1;s<=i;s++) 
      { 
        sum=sum+var(1+k+v+s)*var(k+1)^s;    // clumsy: working with "var(1)",
      }                                     // depends on form of basering
     I[t]=sum; 
     sum=0; 
   }   
  return(I); 
} 

////////////////////////////////////////////////////////////////////////////
//                     CONSTRUCTING the new ring(s)
////////////////////////////////////////////////////////////////////////////

proc ringchange (int i)
{    
  def R=changevar(""+varstr(basering)+",t,"+variables(startvar,i)+"");// change
  return(R);                 // return the ring, needed in future proc
}



proc variables (int k,int i)
{
  list l;
  int s,u;                              // loop variables
  string str;               
  for (u=1;u<=k;u++) 
   {
     for (s=1;s<=i;s++)
     {
       str=""+a_z(u)+"("+string(s)+")"; // creates new variables    
       l[(u-1)*i+s]=str;                // saves them in a list
     }
   } 
  string str1=string(l);                // makes the list into a string,
  return(str1);                         // (needed for ring change)
}


proc a_z (int n)                        // returns nth letter of the alphabet
{ 
  if(1>n>26)                           // input admissible?
   { 
     "n must range between 1 and 26!";
      return(0); 
   } 
  string s="ring r=0,("+A_Z("a",n)+"),ds;"; 
  execute(s); 
  return (string(var(n))); 
} 

////////////////////////////////////////////////////////////////////////////
//                      COMPUTING the G's                                 //
////////////////////////////////////////////////////////////////////////////


proc g_set (poly f,intvec H) 
{
  int p;                             
  int m_0=order(f); 
  int b=size(H);
  if(H[1]!=m_0)                       // input admissible?!
    {
     "H[1]=ord(f) notwendig!!";
      return(0);
    } 
  for(p=1;p<b;p++)
    {
      if(H[p]<H[p+1])
      {
        "Unzulaessige Eingabe, H[1]<=...<=H[b] notwendig!";
         return(0);
      }
    }

  def r=basering;
  int startvar=nvars(basering);
  export(startvar);
  def R=ringchange(b-1);              // work in new ring
  setring R;
  ideal I,J;
  for(p=2;p<=b-1;p++)                 // steps equal to f_set...
  {
    setring r;
    def tmp=formaldiff(f,intvec(H[1..p]));
    setring R;
    I=imap(tmp,resultdiff);
    kill tmp;
    J=J,I;
  }

  setring r;                          // last step, special for G
  def tmp=g_formaldiff(f,H);;
  setring R;
  I=imap(tmp,g_resultdiff);
  kill tmp;
  J=J,I;
 
  J=simplify(J,4);                    // simplify, keep radical small
  J=simplify(J,2);
  J=idealsimplify(J);
  option(redSB);
  J=std(J);
  J=idealsimplify(J);
  J=radical(simplify(J,4));
  J;
  return(R);
}




////////////////////////////////////////////////////////////////////////////
//               PREPARATORY work: differentiating                        //
////////////////////////////////////////////////////////////////////////////




proc g_formaldiff (poly f,intvec H)
{ 
  int s,t,v;                          // loop variables
  int u;
  int i=size(H)-1;
  int c=sum(H,1..i);
  int k=H[i+1];
  def R=plugin_coeffs(f,i);           // plugs the power series in...
  setring R;                          // changes the ring 
  def Coe=resultplug;   
  matrix coe=Coe;                     // gives the t-coeff. after plugging in 
  poly fkv;                           // need this stuff for the following
  ideal step=diffidealstep(i,startvar); 
  ideal m,power,diffstep,J,g_resultdiff;
  for(v=1;v<=k;v++)                   // consider the different t-coeff.
    { 
     fkv=coe[c+v,1];
     m=fkv;                          
     J=fkv;                           
     for(s=1;s<=k-v+1;s++)           // remark: "s<=k-v+1" special!for G!!!
       { 
         power=step^s;
         u=size(power);
         for(t=1;t<=u;t++)
          {
            diffstep=contract(power[t],m);     // actual differentiation
	    J=J,diffstep;
          }
       }
     g_resultdiff=g_resultdiff,J;
   }
  g_resultdiff=simplify(g_resultdiff,2);
  export(g_resultdiff);                // exports the result
  return(R);                           // return the ring
}                       









////////////////////////////////////////////////////////////////////////////
//                        AUXILIARY procedures     
////////////////////////////////////////////////////////////////////////////


proc diffidealstep (int i,int N)       // returns ideal needed for 
{                                     // differentiation in ith step
  ideal I=var(N+1+i);
  int j;
  for(j=2;j<=N;j++)
   {
     I=I,var(N+1+j*i);
   }
return(I);
}



proc order (poly f)                  // gives first elem. of Nash series
{
  poly g=homog(f,var(1));
  int k=deg(g);
  int i;
  for(i=1;i<k;i++)
    {
      if(jet(f,i)!=0)
	{
	  return(i);
        }
    }
}


proc idealsimplify (ideal I)      // simplifies the ideal according to our
{                                 // purposes - to avoid the radical or at 
  int i,j;                        // least to keep the computations small!
  int divisornumber=0;
  int pos;
  for(j=1;j<=ncols(I);j++)
  {
    if(size(I[j])==1)
      {
         for(i=1;i<=nvars(basering);i++)     
         {  
	    if(modd(I[j],var(i))==0)
            {
               divisornumber++;
               pos=i;
             }
          }
       }
      if(divisornumber==1)
	{
          I[j]=var(pos);
        }
      divisornumber=0;
    }
  return(I);
}





proc modd (poly f, poly g)      // the modulo-operation for polys
{
  poly result=f-(f/g)*g;
  return(result);
}




