version="$Id: control.lib,v 1.2 2004-07-22 18:49:14 plural Exp $";
category="System and Control Theory";
info="
LIBRARY:  control.lib Procedures for System and Control Theory 
AUTHORS:  Oleksandr Iena  yena@mathematik.uni-kl.de
@*        Markus Becker   mbecker@mathematik.uni-kl.de

SUPPORT: Forschungsschwerpunkt 'Mathematik und Praxis'


PROCEDURES:
declare(string NameOfRing, string Variables[, list #]);
Defining the ring, optional parametes are a string of parameters and a sting of ordering.
 
Print();                      Well-formatted output of lists, modules and matrixes
control(module R);            Computes everthing related to controllability
autonom(module R);            Computes everything related to autonomy(using Exts) 
autonom2(module R);           Computes everything related to autonomy(using dim) 
LeftKernel(module R);         Computing the left kernel of R
RightKernel(module R);        Computing the right kernel of R

static space(int n)           Procedure used inside the procedure 'Print' to have a better formatted output
static control_output();      Generating the output for the procedure 'control'
static autonom_output();      Generating the output for the procedure 'autonom' and 'autonom2'

";

LIB "homolog.lib"; 
LIB "poly.lib";
LIB "primdec.lib";
//---------------------------------------------------------------
proc declare(string NameOfRing, string Variables, list #)
{
  if(size(#)==0)
  {
    execute("ring "+NameOfRing+"=0,("+Variables+"),dp;");
  }
  else
  {
    if(size(#)==1)
    {
      execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),dp;" );
    }
    else
    { 
      if( (size(#[1])!=0)&&(#[1]!=" ") )
      {
        execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),("+#[2]+");" );
      }
      else
      {
        execute( "ring " + NameOfRing + "=0,("+Variables+"),("+#[2]+");" ); 
      };
    };
  };
  keepring(basering);
  return();
};
example
{"EXAMPLE:";echo = 2;
  string v="x,y,z";
  string p="q,p";
  string Ord ="c,lp";
 
  declare("Ring_1",v);
  print(nameof(basering));
  print(basering);
  
  declare("Ring_2",v,p);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_3",v,p,Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_4",v,"",Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_5",v," ",Ord);
  print(basering);
  print(nameof(basering));
};
//
//maybe reasonable to add this in declare
//
//  print("Please enter your representation matrix in the following form: 
//  module R=[1st row],[2nd row],...");
//  print("Type the command: R=transpose(R)");
//  print(" To compute controllability please enter: control(R)");
//  print(" To compute autonomy please enter: autonom(R)");
//
//
//
//-------------------------------------------------------------------------
static proc space(int n)
//the procedure is used in the procedure Print to have a better formatted output
//USAGE:spase(int n)
//RETURN: string consisting of n spases
{
  int i;
  string s="";
  for(i=1;i<=n;i++)
  {
    s=s+" ";
  };
  return(s);
};
//-----------------------------------------------------------------------------
proc Print(M)
//procedure for a well-formatted output of lists, modules and matrixes
{
  if ( (typeof(M)=="module")||(typeof(M)=="matrix") )
  {
  int @R=nrows(M);
  int @C=ncols(M);
  int i;
  int j;
  list MaxLength=list();
  int Size=0;
  int max;
  string s;
  
  for(i=1;i<=@C;i++)
  { 
    max=0; 
    
    for(j=1;j<=@R;j++)
    {
      Size=size( string( M[j,i] ) );
      if( Size>max )
      {
        max=Size;
      };
    };
    MaxLength[i] = max;
  };
  
  for(i=1;i<=@R;i++)
  {
    s="";
    for(j=1;j<@C;j++)
    {
      s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) ) +",";
    };
    
    s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) );

    if (i!=@R)
    {
      s=s+",";
    };
    print(s);
  };

  return();    
  };
  
  if(typeof(M)=="list")
  {
    int sz=size(M);
    int i;
    for(i=1;i<=sz;i++)
    {
      Print(M[i]);
      print("");
    }; 

    return();
  };
  print(M);
  return();
};
//--------------------------------------------------------------------------
proc RightKernel(matrix M)
{ 
  return(syz(M));
}; 
//-------------------------------------------------------------------------
proc LeftKernel(matrix M)
{
  return( transpose( syz( transpose(M) ) ) );
};
//------------------------------------------------------------------------
static proc control_output(int i, int NVars, module R, module Ext_1) 
//in this procedure the output list with all the contollability properties of the system is generated
{
  int d=dim( std( Ann( transpose(R) ) ) ) ;;//this is the dimension of the system 
  string DofS= "dimension of the system:";
  if(i==1)
  { 
    module RK=RightKernel(R);
    return( 
            list ( i,
	          "not controllable , image representation for controllable part:",
         	   RK,	    
	          "kernel representation for controllable part:",
		   LeftKernel( RK ),
		  "obstruction to controllability",
		   Ext_1,
		  "annihilator of torsion module(of obstruction to controllability)",
		   Ann(Ext_1),
		   DofS,
		   d
		 ) 
          );
  };
  
  if(i>NVars)
  {  
    return( list( -1, 
                  "strongly controllable, image representation:",
		   RightKernel(R),
		   DofS, 
		   d) 
          );
  };
  
  //
  //now i<=NVars
  //
       
  if( (i==2) )
  {
    return( list( i, 
                 "controllable, not reflexive, imagerepresentation:",
		  RightKernel(R),
                  DofS,
                  d ) 
          ); 
  };
    
  if( (i>=3) )
  {
    return( list ( i, 
                  "reflexive, not strongly controllable, image representation:",
		   RightKernel(R),
		   DofS,
		   d) 
          );
  };
              
  
};  
//-------------------------------------------------------------------------

proc control(module R)
//"Computes the controllability of a behaviour represented by the matrix R"
{
  int i;
  int NVars=nvars(basering); 
  int ExtIsZero;
 
       
  module Ext_1 = std(Ext_R(1,R));
   
  ExtIsZero=is_zero(Ext_1);
  i=1;
  while( (ExtIsZero) && (i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero( Ext_R(i,R) );
  };
  
  return( control_output( i, NVars, R, Ext_1 ) );
};
example
{"EXAMPLE:";echo = 2; 
  //-------------------------------
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  Print( R );  
  Print( control(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  Print( Rc );
  Print( control(Rc) );
  //----------------------------------
  //reflector antenna
  ring A = (0, K1, K2, Te, Kp, Kc),(Dt, delta), dp;
  module R;
  R = [Dt, -K1, 0, 0, 0, 0, 0, 0, 0],
       [0, Dt+K2/Te, 0, 0, 0, 0, -Kp/Te*delta, -Kc/Te*delta, -Kc/Te*delta],
       [0, 0, Dt, -K1, 0, 0, 0, 0, 0],
       [0, 0, 0, Dt+K2/Te, 0, 0, -Kc/Te*delta, -Kp/Te*delta, -Kc/Te*delta],
       [0, 0, 0, 0, Dt, -K1, 0, 0, 0],
       [0, 0, 0, 0, 0, Dt+K2/Te, -Kc/Te*delta, -Kc/Te*delta, -Kp/Te*delta];
  R=transpose(R);
  Print(R);
  Print(control(R));
  //----------------------------------
  //Flexible Rod
  ring A = 0,(D1, delta), dp;
  module R;
  R = [D1, -D1*delta, -1],
      [2*D1*delta, -D1-D1*delta^2, 0];
  R=transpose(R);
  Print(R);
  Print(control(R));
  //-------------------------------------
  //TwoPendula
  ring r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module R;
  R =  [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
       [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
       [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];
  R=transpose(R);
  Print(R);
  Print(control(R));
  //----------------------------------------
  //Wind Tunnel
  ring A = (0,a, omega, zeta, k),(D1, delta),dp;
  module R;
  R = [D1+a, -k*a*delta, 0, 0],
      [0, D1, -1, 0],
      [0, omega^2, D1+2*zeta*omega, -omega^2];
  R=transpose(R);
  Print(R);
  Print(control(R));
  //-------------------------------------------

};
//------------------------------------------------------------------------
static proc autonom_output( int i, int NVars ) 
//in this procedure the output list with all the autonomy properties of the system is generated
{
  int d=NVars-i;//that is the dimension of the system
  string DofS="dimension of the system:";
  if(i==0)
  { 
    return( list(  i,
                  "not autonomous",
		   DofS,
		   d ) 
	  );
  };
  
  if( i>NVars )
  {  
    return( list( -1,
                  "trivial",
		  DofS,
		  d ) 
          );
  };
  
  //
  //now i<=NVars
  //
    
     
  if( i==1 )
  //in case that NVars==1 there is no sence to consider the notion
  //of strongly autonomous behavior, because it does not imply 
  //that system is overdetermined in this case
  {
    return( list ( i, 
                  "autonomous, not overdetermined",
		   DofS,
		   d ) 
          ); 
  };
    
  if( i==NVars )
  {  
    return( list(  i,
                  "strongly autonomous,in particular overdetermined",
		   DofS,
		   d) 
	  );
  };
  
  if( i<NVars )
  {
    return( list ( i,
                  "overdetermined, not strongly autonomous",
		   DofS, 
		   d) 
          );
  };
    
};  
//--------------------------------------------------------------------------
proc autonom2(module R)
//analogue to autonom using dim calculations
{ 
  int d;
  int NVars = nvars(basering);
  R=transpose(R);
  d=dim( std( Ann(R) ) );
  return( autonom_output(NVars-d,NVars) );
};
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  Print( R );  
  Print( autonom2(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  Print( Rc );
  Print( autonom2(Rc) );
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  Print( R );
  Print( autonom2(R) );
  
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  Print( R );
  Print( autonom2(R) );
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  Print(R);
  Print(autonom2(R));	   
};  
//---------------------------------------------------------------------------

proc autonom(module R)
//"Computes the autonomy of a behaviour represented by the matrix R"
{
  int i;
  int NVars=nvars(basering);
  int ExtIsZero;
    
  
  R=transpose(R); 
  
  
  ExtIsZero=is_zero(Ext_R(0,R)); 
  
  i=0;
  while( (ExtIsZero)&&(i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero(Ext_R(i,R));
  };
  
  return(autonom_output(i,NVars));
     
};
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  Print( R );  
  Print( autonom(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  Print( Rc );
  Print( autonom(Rc) );
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  Print( R );
  Print( autonom(R) );
  
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  Print( R );
  Print( autonom(R) );
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  Print(R);
  Print(autonom(R));	   
  
};  
//---------------------------------------------------------------------------
