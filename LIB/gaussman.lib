///////////////////////////////////////////////////////////////////////////////
version="$Id: gaussman.lib,v 1.55 2001-11-05 09:16:48 mschulze Exp $";
category="Singularities";

info="
LIBRARY:  gaussman.lib  Gauss-Manin Connection of a Singularity

AUTHOR:   Mathias Schulze, email: mschulze@mathematik.uni-kl.de

OVERVIEW: A library to compute invariants related to the Gauss-Manin connection
          of a an isolated hypersurface singularity

PROCEDURES:
 gmsring(t,s);              Brieskorn lattice in Gauss-Manin system of t
 gmsnf(p,K[,Kmax]);         Gauss-Manin system normal form
 gmscoeffs(p,K[,Kmax]);     Gauss-Manin system basis representation
 monodromy(t);              Jordan data of monodromy of t
 spectrum(t);               spectrum of t
 sppairs(t);                spectral pairs of t
 sppnf(a,w[,m][,v|V]);      normalize spectral pairs
 vfilt(t);                  V-filtration of t on H''/H'
 vwfilt(t);                 weight refined V-filtration of t on H''/H'
 saito(t);                  matrix A0+A1*s of t on H''
 endvfilt(V);               endomorphism V-filtration
 spprint(Sp);               print spectrum Sp
 sppprint(Spp);             print spectral pairs Spp
 spadd(Sp1,Sp2);            sum of spectra Sp1 and Sp2
 spsub(Sp1,Sp2);            difference of spectra Sp1 and Sp2
 spmul(Sp,k);               product of spectrum Sp and integer k
 spmul(Sp,k);               linear combination of spectra Sp with coeffs k
 spissemicont(Sp[,opt]);    test spectrum Sp for semicontinuity
 spsemicont(Sp0,Sp[,opt]);  semicontinuity of spectra Sp0 and Sp
 spmilnor(Sp);              milnor number of spectrum Sp
 spgeomgenus(Sp);           geometrical genus of spectrum Sp
 spgamma(Sp);               gamma invariant of spectrum Sp

SEE ALSO: mondromy_lib, spectrum_lib

KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          monodromy; spectrum; spectral pairs;
          Hodge filtration; V-filtration; weight filtration
";

LIB "linalg.lib";

///////////////////////////////////////////////////////////////////////////////

static proc stdtrans(ideal I)
{
  def R=basering;

  string os=ordstr(R);
  int j=find(os,",C");
  if(j==0)
  {
    j=find(os,"C,");
  }
  if(j==0)
  {
    j=find(os,",c");
  }
  if(j==0)
  {
    j=find(os,"c,");
  }
  if(j>0)
  {
    os[j..j+1]="  ";
  }

  execute("ring S="+charstr(R)+",(gmspoly,"+varstr(R)+"),(c,dp,"+os+");");

  ideal I=homog(imap(R,I),gmspoly);
  module M=transpose(transpose(I)+freemodule(ncols(I)));
  M=std(M);

  setring(R);
  execute("map h=S,1,"+varstr(R)+";");
  module M=h(M);

  for(int i=ncols(M);i>=1;i--)
  {
    for(j=ncols(M);j>=1;j--)
    {
      if(M[i][1]==0)
      {
        M[i]=0;
      }
      if(i!=j&&M[j][1]!=0)
      {
        if(lead(M[i][1])/lead(M[j][1])!=0)
        {
          M[i]=0;
        }
      }
    }
  }

  M=transpose(simplify(M,2));
  I=M[1];
  attrib(I,"isSB",1);
  M=M[2..ncols(M)];
  module U=transpose(M);

  return(list(I,U));
}
///////////////////////////////////////////////////////////////////////////////

proc gmsring(poly t,string s)
"USAGE:    gmsring(t,s); poly t, string s;
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:
@format
ring G: C{{s}}*basering,
  poly gmspoly: image of t
  ideal gmsjacob: image of Jacobian ideal
  ideal gmsstd: image of standard basis of Jacobian ideal
  matrix gmsmatrix: matrix(gmsjacob)*gmsmatrix=matrix(gmsstd)
  ideal gmsbasis: image of monomial vector space basis of Jacobian algebra
  int gmsmaxweight: maximal weight of variables of basering
@end format
NOTE:     do not modify gms variables if you want to use gms procedures
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice
EXAMPLE:  example gms; shows examples
"
{
  def R=basering;
  if(charstr(R)!="0")
  {
    ERROR("characteristic 0 expected");
  }
  for(int i=nvars(R);i>=1;i--)
  {
    if(var(i)>1)
    {
      ERROR("local ordering expected");
    }
  }

  ideal dt=jacob(t);
  list l=stdtrans(dt);
  ideal g=l[1];
  if(vdim(g)<=0)
  {
    if(vdim(g)==0)
    {
      ERROR("singularity at 0 expected");
    }
    else
    {
      ERROR("isolated citical point 0 expected");
    }
  }  
  matrix a=l[2];
  ideal m=kbase(g);

  int gmsmaxweight;
  for(i=nvars(R);i>=1;i--)
  {
    if(deg(var(i))>gmsmaxweight)
    {
      gmsmaxweight=deg(var(i));
    }
  }

  string os=ordstr(R);
  int j=find(os,",C");
  if(j==0)
  {
    j=find(os,"C,");
  }
  if(j==0)
  {
    j=find(os,",c");
  }
  if(j==0)
  {
    j=find(os,"c,");
  }
  if(j>0)
  {
    os[j..j+1]="  ";
  }

  execute("ring G="+string(charstr(R))+",("+s+","+varstr(R)+"),(ws("+
    string(deg(highcorner(g))+2*gmsmaxweight)+"),"+os+",c);");

  poly gmspoly=imap(R,t);
  ideal gmsjacob=imap(R,dt);
  ideal gmsstd=imap(R,g);
  matrix gmsmatrix=imap(R,a);
  ideal gmsbasis=imap(R,m);

  attrib(gmsstd,"isSB",1);
  export gmspoly,gmsjacob,gmsstd,gmsmatrix,gmsbasis,gmsmaxweight;

  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  def G=gmsring(t,"s");
  setring(G);
  gmspoly;
  print(gmsjacob);
  print(gmsstd);
  print(gmsmatrix);
  print(gmsbasis);
  gmsmaxweight;
}
///////////////////////////////////////////////////////////////////////////////

proc gmsnf(ideal p,int K,list #)
"USAGE:    gmsnf(p,K[,Kmax]); poly p, int K[, int Kmax];
ASSUME:   basering constructed by gmsring, K<=Kmax
RETURN:
@format
list l:
  ideal l[1]: projection of p to H''=C{{s}}*gmsbasis mod s^{K+1}
  ideal l[2]: p=l[1]+l[2] mod s^(Kmax+1)
@end format
NOTE:     by setting p=l[2] the computation can be continued up to order
          at most Kmax, by default Kmax=infinity
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice
EXAMPLE:  example gmsnf; shows examples
"
{
  int Kmax=-1;
  if(size(#)>0)
  {
    if(typeof(#[1])=="int")
    {
      Kmax=#[1];
      if(K>Kmax)
      {
        Kmax=K;
      }
    }
  }

  intvec v=1;
  v[nvars(basering)]=0;

  int k;
  if(Kmax>=0)
  {
    p=jet(jet(p,K,v),(Kmax+1)*deg(var(1))-2*gmsmaxweight);
  }

  ideal r,q;
  r[ncols(p)]=0;
  q[ncols(p)]=0;

  poly s;
  int i,j;
  for(k=ncols(p);k>=1;k--)
  {
    while(p[k]!=0&&deg(lead(p[k]),v)<=K)
    {
      i=1;
      s=lead(p[k])/lead(gmsstd[i]);
      while(i<ncols(gmsstd)&&s==0)
      {
        i++;
        s=lead(p[k])/lead(gmsstd[i]);
      }
      if(s!=0)
      {
        p[k]=p[k]-s*gmsstd[i];
        for(j=1;j<=nrows(gmsmatrix);j++)
        {
          if(Kmax>=0)
          {
            p[k]=p[k]+
              jet(jet(diff(s*gmsmatrix[j,i],var(j+1))*var(1),Kmax,v),
                (Kmax+1)*deg(var(1))-2*gmsmaxweight);
          }
          else
          {
            p[k]=p[k]+diff(s*gmsmatrix[j,i],var(j+1))*var(1);
          }
        }
      }
      else
      {
        r[k]=r[k]+lead(p[k]);
        p[k]=p[k]-lead(p[k]);
      }
      while(deg(lead(p[k]))>(K+1)*deg(var(1))-2*gmsmaxweight&&
        deg(lead(p[k]),v)<=K)
      {
        q[k]=q[k]+lead(p[k]);
        p[k]=p[k]-lead(p[k]);
      }
    }
    q[k]=q[k]+p[k];
  }

  return(list(r,q));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  def G=gmsring(t,"s");
  setring(G);
  list l0=gmsnf(gmspoly,0);
  print(l0[1]);
  list l1=gmsnf(gmspoly,1);
  print(l1[1]);
  list l=gmsnf(l0[2],1);
  print(l[1]);
}
///////////////////////////////////////////////////////////////////////////////

proc gmscoeffs(ideal p,int K,list #)
"USAGE:    gmscoeffs(p,K[,Kmax]); poly p, int K[, int Kmax];
ASSUME:   basering constructed by gmsring, K<=Kmax
RETURN:
@format
list l:
  matrix l[1]: projection of p to H''=C{{s}}*gmsbasis=C{{s}}^mu mod s^(K+1)
  ideal l[2]: p=matrix(gmsbasis)*l[1]+l[2] mod s^(Kmax+1)
@end format
NOTE:     by setting p=l[2] the computation can be continued up to order 
          at most Kmax, by default Kmax=infinity
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice
EXAMPLE:  example gmscoeffs; shows examples
"
{
  list l=gmsnf(p,K,#);
  ideal r,q=l[1..2];
  poly v=1;
  for(int i=2;i<=nvars(basering);i++)
  {
    v=v*var(i);
  }
  matrix C=coeffs(r,gmsbasis,v);
  return(C,q);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  def G=gmsring(t,"s");
  setring(G);
  list l0=gmscoeffs(gmspoly,0);
  print(l0[1]);
  list l1=gmscoeffs(gmspoly,1);
  print(l1[1]);
  list l=gmscoeffs(l0[2],1);
  print(l[1]);
}
///////////////////////////////////////////////////////////////////////////////

static proc min(ideal e)
{
  int i;
  number m=number(e[1]);
  for(i=2;i<=ncols(e);i++)
  {
    if(number(e[i])<m)
    {
      m=number(e[i]);
    }
  }
  return(m);
}
///////////////////////////////////////////////////////////////////////////////

static proc max(ideal e)
{
  int i;
  number m=number(e[1]);
  for(i=2;i<=ncols(e);i++)
  {
    if(number(e[i])>m)
    {
      m=number(e[i]);
    }
  }
  return(m);
}
///////////////////////////////////////////////////////////////////////////////

static proc saturate(int K0)
{
  int mu=ncols(gmsbasis);
  ideal r=gmspoly*gmsbasis;
  matrix A0[mu][mu],C;
  module H0;
  module H,H1=freemodule(mu),freemodule(mu);
  int k=-1;
  list l;

  while(size(reduce(H,std(H0*s)))>0)
  {
    dbprint(printlevel-voice+2,"// compute matrix A of t");
    k++;
    dbprint(printlevel-voice+2,"// k="+string(k));
    l=gmscoeffs(r,k,mu+K0);
    C,r=l[1..2];
    A0=A0+C;

    dbprint(printlevel-voice+2,"// compute saturation of H''");
    H0=H;
    H1=jet(module(A0*H1+s^2*diff(matrix(H1),s)),k);
    H=H*s+H1;
  }

  A0=A0-k*s;
  dbprint(printlevel-voice+2,"// compute basis of saturation of H''");
  H=std(H0);

  dbprint(printlevel-voice+2,"// transform H'' to saturation of H''");
  l=division(H,freemodule(mu)*s^k);
  H0=l[1];

  return(A0,r,H,H0,k);
}
///////////////////////////////////////////////////////////////////////////////

static proc tmatrix(matrix A0,ideal r,module H,int k0,int K,int K0)
{
  dbprint(printlevel-voice+2,"// compute matrix A of t");
  dbprint(printlevel-voice+2,"// k="+string(K+k0+1));
  list l=gmscoeffs(r,K+k0+1,K0+k0+1);
  matrix C;
  C,r=l[1..2];
  A0=A0+C;

  dbprint(printlevel-voice+2,"// transform A to saturation of H''");
  l=division(H*s,A0*H+s^2*diff(matrix(H),s));
  matrix A=jet(l[1],l[2],K);

  return(A,A0,r);
}
///////////////////////////////////////////////////////////////////////////////

static proc eigenvals(matrix A0,ideal r,module H,int k0,int K0)
{
  dbprint(printlevel-voice+2,
    "// compute eigenvalues e with multiplicities m of A");
  matrix A;
  A,A0,r=tmatrix(A0,r,H,k0,0,K0);
  list l=eigenvalues(A);
  def e,m=l[1..2];
  dbprint(printlevel-voice+2,"// e="+string(e));
  dbprint(printlevel-voice+2,"// m="+string(m));

  return(e,m,A0,r,int(max(e)-min(e)));
}
///////////////////////////////////////////////////////////////////////////////

static proc transform(matrix A,matrix A0,ideal r,module H,module H0,ideal e,intvec m,int k0,int k1,int K,int K0)
{
  int mu=ncols(gmsbasis);

  dbprint(printlevel-voice+2,"// compute minimum e0 and maximum e1 of e");
  number e0,e1=min(e),max(e);
  dbprint(printlevel-voice+2,"// e0="+string(e0));
  dbprint(printlevel-voice+2,"// e1="+string(e1));
  A,A0,r=tmatrix(A0,r,H,k0,K+k1,K0+k1);
  module U0=s^k0*freemodule(mu);

  if(e1>=e0+1)
  {
    int i,j,i0,j0,i1,j1;
    module U,V;
    list l;

    while(e1>=e0+1)
    {
      dbprint(printlevel-voice+2,"// transform to separate eigenvalues");
      U=0;
      for(i=1;i<=ncols(e);i++)
      {
        U=U+syz(power(jet(A,0)-e[i],m[i]));
      }
      V=inverse(U);
      A=V*A*U;
      H0=V*H0;
      U0=U0*U;

      dbprint(printlevel-voice+2,"// transform to reduce e1 by 1");
      for(i0,i=1,1;i0<=ncols(e);i0++)
      {
        for(i1=1;i1<=m[i0];i1,i=i1+1,i+1)
        {
          for(j0,j=1,1;j0<=ncols(e);j0++)
          {
            for(j1=1;j1<=m[j0];j1,j=j1+1,j+1)
            {
              if(number(e[i0])<e0+1&&number(e[j0])>=e0+1)
              {
                A[i,j]=A[i,j]/s;
              }
              if(number(e[i0])>=e0+1&&number(e[j0])<e0+1)
              {
                A[i,j]=A[i,j]*s;
              }
            }
	  }
        }
      }

      H0=transpose(H0);
      for(i0,i=1,1;i0<=ncols(e);i0++)
      {
        if(number(e[i0])>=e0+1)
        {
          for(i1=1;i1<=m[i0];i1,i=i1+1,i+1)
          {
            A[i,i]=A[i,i]-1;
            H0[i]=H0[i]*s;
            U0[i]=U0[i]/s;
          }
          e[i0]=e[i0]-1;
        }
        else
        {
          i=i+m[i0];
        }
      }
      H0=transpose(H0);

      l=spnf(e,m);
      e,m=l[1..2];

      e1=e1-1;
      dbprint(printlevel-voice+2,"// e1="+string(e1));
    }

    A=jet(A,K);
  }

  return(A,A0,r,H0,U0,e,m);
}
///////////////////////////////////////////////////////////////////////////////

proc monodromy(poly t,list #)
"USAGE:    monodromy(t); poly t
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:   list l: Jordan data jordan(M) of a monodromy matrix exp(-2*pi*i*M)
SEE ALSO: mondromy_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice; monodromy
EXAMPLE:  example monodromy; shows examples
"
{
  def R=basering;
  int n=nvars(R)-1;
  def G=gmsring(t,"s");
  setring(G);

  matrix A;
  module U0;
  ideal e;
  intvec m;
  int k1;

  def A0,r,H,H0,k0=saturate(n);
  e,m,A0,r,k1=eigenvals(A0,r,H,k0,n);
  A,A0,r,H0,U0,e,m=transform(A,A0,r,H,H0,e,m,k0,k1,0,0);

  setring(R);
  return(jordan(imap(G,A),imap(G,e),m));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly f=x5+x2y2+y5;
  print(monodromy(f));
}
///////////////////////////////////////////////////////////////////////////////

proc spectrum(poly t)
"USAGE:    spectrum(t); poly t
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:
@format
list Sp: spectrum of t
  ideal Sp[1]: V-filtration indices in increasing order
  intvec Sp[2]: weight filtration indices in decreasing order
  intvec Sp[3]:
    int Sp[3][i]: multiplicity of spectral number Sp[1][i]
@end format
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice; 
          mixed Hodge structure; spectrum
EXAMPLE:  example spectrum; shows examples
"
{
  list l=vwfilt(t);
  return(spnf(l[1],l[3]));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  spprint(spectrum(t));
}
///////////////////////////////////////////////////////////////////////////////

proc sppairs(poly t)
"USAGE:    sppairs(t); poly t
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:
@format
list Spp: spectrum of t
  ideal Spp[1],intvec Spp[2]: spectral pairs in in-/decreasing lex. order
  intvec Spp[3]:
    int Spp[3][i]: multiplicity of spectral pair (Spp[1][i],Spp[2][i])
@end format
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          mixed Hodge structure; spectrum; spectral pairs
EXAMPLE:  example sppairs; shows examples
"
{
  list l=vwfilt(t);
  return(list(l[1],l[2],l[3]));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  sppprint(sppairs(t));
}
///////////////////////////////////////////////////////////////////////////////

proc sppnf(ideal a,intvec w,list #)
"USAGE:    sppnf(a,w[,m][,v|V]); ideal a, intvec w, intvec m, module v, list V
RETURN:
@format
list Spp: normalized spectral pairs (a,w,m[,V])
  ideal Spp[1]: numbers in a in increasing order
  intvec Spp[2]: integers in w in decreasing order
  intvec Spp[3]:
    int Spp[3][i]: multiplicity of pair (Spp[1][i],Spp[2][i]) in (a,w)
  list Spp[4]:
    module Spp[4][i]: module associated to pair (Spp[1][i],Spp[2][i])
@end format
EXAMPLE:  example sppnorm; shows examples
"
{
  int n=ncols(a);
  intvec m;
  module v;
  list V;
  int i,j;
  while(i<size(#))
  {
    i++;
    if(typeof(#[i])=="intvec")
    {
      m=#[i];
    }
    if(typeof(#[i])=="module")
    {
      v=#[i];
      for(j=n;j>=1;j--)
      {
        V[j]=module(v[j]);
      }
    }
    if(typeof(#[i])=="list")
    {
      V=#[i];
    }
  }
  if(m==0)
  {
    for(i=n;i>=1;i--)
    {
      m[i]=1;
    }
  }

  int k;
  ideal a0;
  intvec w0,m0;
  list V0;
  number a1;
  int w1,m1;
  for(i=n;i>=1;i--)
  {
    if(m[i]!=0)
    {
      for(j=i-1;j>=1;j--)
      {
        if(m[j]!=0)
	{
          if(number(a[i])>number(a[j])||
            (number(a[i])==number(a[j])&&w[i]<w[j]))
          {
            a1=number(a[i]);
            a[i]=a[j];
            a[j]=a1;
            w1=w[i];
            w[i]=w[j];
            w[j]=w1;
            m1=m[i];
            m[i]=m[j];
            m[j]=m1;
            if(size(V)>0)
            {
              v=V[i];
              V[i]=V[j];
              V[j]=v;
            }
          }
          if(number(a[i])==number(a[j])&&w[i]==w[j])
          {
            m[i]=m[i]+m[j];
            m[j]=0;
            if(size(V)>0)
            {
              V[i]=V[i]+V[j];
            }
          }
        }
      }
      k++;
      a0[k]=a[i];
      w0[k]=w[i];
      m0[k]=m[i];
      if(size(V)>0)
      {
        V0[k]=V[i];
      }
    }
  }

  if(size(V0)>0)
  {
    n=size(V0);
    module U=std(V0[n]);
    for(i=n-1;i>=1;i--)
    {
      V0[i]=simplify(reduce(V0[i],U),1);
      if(i>=2)
      {
        U=std(U+V0[i]);
      }
    }
  }

  list l;
  if(k>0)
  {
    l=a0,w0,m0;
    if(size(V0)>0)
    {
      l[4]=V0;
    }
  }
  return(l);
}
example
{ "EXAMPLE:"; echo=2;
}
///////////////////////////////////////////////////////////////////////////////

proc vfilt(poly t)
"USAGE:    vfilt(t); poly t
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:
@format
list V: V-filtration on H''/H'
  ideal V[1]: spectral numbers in increasing order
  intvec V[2]:
    int V[2][i]: multiplicity of spectral number V[1][i]
  list V[4]:
    module V[4][i]: vector space basis of V[1][i]-th graded part 
                    in terms of V[4]
  ideal V[4]: monomial vector space basis of H''/H'
  ideal V[5]: standard basis of Jacobian ideal
@end format
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          mixed Hodge structure; V-filtration; spectrum
EXAMPLE:  example vfilt; shows examples
"
{
  list l=vwfilt(t);
  return(spnf(l[1],l[3],l[4])+list(l[5],l[6]));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  vfilt(t);
}
///////////////////////////////////////////////////////////////////////////////

proc vwfilt(poly t)
"USAGE:    vwfilt(t); poly t
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:
@format
list VW: weight refined V-filtration on H''/H'
  ideal VW[1]: spectral numbers in increasing order
  intvec VW[2]: weights in decreasing order
  intvec VW[3]:
    int VW[3][i]: multiplicity of spectral pair (VW[1][i],VW[2][i])
  list VW[4]:
    module VW[4][i]: vector space basis of (VW[1][i],VW[2][i])-th graded part 
                     in terms of VW[5]
  ideal VW[5]: monomial vector space basis of H''/H'
  ideal VW[6]: standard basis of Jacobian ideal
@end format
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          mixed Hodge structure; V-filtration; weight filtration;
          spectrum; spectral pairs
EXAMPLE:  example vwfilt; shows examples
"
{
  def R=basering;
  int n=nvars(R)-1;
  def G=gmsring(t,"s");
  setring(G);

  int mu=ncols(gmsbasis);
  matrix A;
  module U0;
  ideal e;
  intvec m;
  int k1;

  def A0,r,H,H0,k0=saturate(n);
  e,m,A0,r,k1=eigenvals(A0,r,H,k0,n);
  A,A0,r,H0,U0,e,m=transform(A,A0,r,H,H0,e,m,k0,k1,0,0);

  dbprint(printlevel-voice+2,"// compute weight filtration basis");
  list l=jordanbasis(A,e,m);
  def U,v=l[1..2];
  kill l;
  vector u0;
  int v0;
  int i,j,k,l;
  for(k,l=1,1;l<=ncols(e);k,l=k+m[l],l+1)
  {
    for(i=k+m[l]-1;i>=k+1;i--)
    {
      for(j=i-1;j>=k;j--)
      {
        if(v[i]>v[j])
        {
          v0=v[i];v[i]=v[j];v[j]=v0;
          u0=U[i];U[i]=U[j];U[j]=u0;
        }
      }
    }
  }

  dbprint(printlevel-voice+2,"// transform to weight filtration basis");
  matrix V=inverse(U);
  A=V*A*U;
  dbprint(printlevel-voice+2,"// compute normal form of H''");
  H0=std(V*H0);
  U0=U0*U;

  dbprint(printlevel-voice+2,"// compute spectral pairs");
  ideal a;
  intvec w;
  for(i=1;i<=mu;i++)
  {
    j=leadexp(H0[i])[nvars(basering)+1];
    a[i]=A[j,j]+ord(H0[i])/deg(s)-1;
    w[i]=v[j]+n;
  }
  kill v;
  module v=simplify(grmat(H*U0*H0,2*k0),1);

  setring(R);
  ideal g=imap(G,gmsstd);
  attrib(g,"isSB",1);
  return(sppnf(imap(G,a),w,imap(G,v))+list(imap(G,gmsbasis),g));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  vwfilt(t);
}
///////////////////////////////////////////////////////////////////////////////

proc vfilt1(poly t,list #)
"USAGE:    vfilt1(t[,opt]); poly t, int opt
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:
@format
list V: V-filtration of t on H''/H'
  intvec V[1]: spectral numbers in increasing order
  intvec V[2]:
    int V[2][i]: multiplicity of spectral number V[1][i]/V[2][i]
if opt>=1:
  list V[4]:
    module V[3][i]: vector space basis of V[1][i]/V[2][i]-th graded part
                    in terms of V[5]
  ideal V[4]: monomial vector space basis of H''/H'
  ideal V[5]: standard basis of Jacobian ideal
default: opt=1
@end format
NOTE:     H' and H'' denote the Brieskorn lattices
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          Hodge filtration; V-filtration; spectrum
EXAMPLE:  example vfilt1; shows examples
"
{
  int opt=1;
  if(size(#)>0)
  {
    if(typeof(#[1])=="int")
    {
      opt=#[1];
    }
  }

  def R=basering;
  int n=nvars(R)-1;
  def G=gmsring(t,"s");
  setring G;

  int mu=ncols(gmsbasis);
  ideal r=gmspoly*gmsbasis;
  list l;
  matrix A[mu][mu],C;
  module H,H1=freemodule(mu),freemodule(mu);
  module H0;
  int k=-1;
  int N=n+1;

  while(size(reduce(H,std(H0*s)))>0)
  {
    k++;
    dbprint(printlevel-voice+2,"// k="+string(k));
    dbprint(printlevel-voice+2,"// compute matrix A of t");
    l=gmscoeffs(r,k);
    C,r=l[1..2];
    A=A+C;

    dbprint(printlevel-voice+2,"// compute saturation of H''");
    H0=H;
    H1=jet(module(A*H1+s^2*diff(matrix(H1),s)),k);
    H=H*s+H1;
  }
  A=A-k*s;

  dbprint(printlevel-voice+2,"// compute basis of saturation of H''");
  H=std(H0);
  int d0=maxdeg1(H);
  dbprint(printlevel-voice+2,"// k="+string(d0+N));
  dbprint(printlevel-voice+2,"// compute matrix A of t");
  l=gmscoeffs(r,d0+N,d0+N);
  C,r=l[1..2];
  A=A+C;

  dbprint(printlevel-voice+2,"// transform H'' to saturation of H''");
  l=division(H,freemodule(mu)*s^k);
  H0=jet(l[1],l[2],N-1);

  dbprint(printlevel-voice+2,"// compute vector spaces");
  poly p;
  int i0,j0,i1,j1;
  matrix V0[mu*N][mu*N];
  matrix V1[mu*N][mu*(N-1)];
  for(i0=mu;i0>=1;i0--)
  {
    for(i1=mu;i1>=1;i1--)
    {
      p=H0[i1,i0];
      while(p!=0)
      {
        j1=leadexp(p)[1];
        for(j0=N-j1-1;j0>=0;j0--)
        {
          V0[i1+(j1+j0)*mu,i0+j0*mu]=V0[i1+(j1+j0)*mu,i0+j0*mu]+leadcoef(p);
          if(j1+j0+1<N)
          {
            V1[i1+(j1+j0+1)*mu,i0+j0*mu]=
            V1[i1+(j1+j0+1)*mu,i0+j0*mu]+leadcoef(p);
          }
        }
        p=p-lead(p);
      }
    }
  }

  dbprint(printlevel-voice+2,"// transform A to saturation of H''");
  l=division(H*s,A*H+s^2*diff(matrix(H),s));
  A=jet(l[1],l[2],N-1);

  dbprint(printlevel-voice+2,"// compute matrix M of A");
  matrix M[mu*N][mu*N];
  for(i0=mu;i0>=1;i0--)
  {
    for(i1=mu;i1>=1;i1--)
    {
      p=A[i1,i0];
      while(p!=0)
      {
        j1=leadexp(p)[1];
        for(j0=N-j1-1;j0>=0;j0--)
        {
          M[i1+(j0+j1)*mu,i0+j0*mu]=leadcoef(p);
        }
        p=p-lead(p);
      }
    }
  }
  for(i0=mu;i0>=1;i0--)
  {
    for(j0=N-1;j0>=0;j0--)
    {
      M[i0+j0*mu,i0+j0*mu]=M[i0+j0*mu,i0+j0*mu]+j0;
    }
  }

  dbprint(printlevel-voice+2,"// compute eigenvalues eA of A");
  ideal eA=eigenvalues(jet(A,0))[1];
  dbprint(printlevel-voice+2,"// eA="+string(eA));

  dbprint(printlevel-voice+2,"// compute eigenvalues eM of M");
  ideal eM;
  k=0;
  intvec u;
  for(int i=N;i>=1;i--)
  {
    u[i]=1;
  }
  i0=1;
  while(u[N]<=ncols(eA))
  {
    for(i,i1=i0+1,i0;i<=N;i++)
    {
      if(eA[u[i]]+i<eA[u[i1]]+i1)
      {
        i1=i;
      }
    }
    k++;
    eM[k]=eA[u[i1]]+i1-1;
    u[i1]=u[i1]+1;
    if(u[i1]>ncols(eA))
    {
      i0=i1+1;
    }
  }
  dbprint(printlevel-voice+2,"// eM="+string(eM));

  dbprint(printlevel-voice+2,"// compute V-filtration on H''/sH''");
  ideal a;
  k=0;
  list V;
  V[ncols(eM)+1]=interred(V1);
  intvec d;
  if(opt<=0)
  {
    for(i=ncols(eM);number(eM[i])-1>number(n-1)/2;i--)
    {
      dbprint(printlevel-voice+2,"// compute V["+string(i)+"]");
      V1=module(V1)+syz(power(M-eM[i],n+1));
      V[i]=interred(intersect(V1,V0));

      if(size(V[i])>size(V[i+1]))
      {
        k++;
        a[k]=eM[i]-1;
        d[k]=size(V[i])-size(V[i+1]);
      }
    }

    dbprint(printlevel-voice+2,"// symmetry index found");
    int j=k;

    if(number(eM[i])-1==number(n-1)/2)
    {
      dbprint(printlevel-voice+2,"// compute V["+string(i)+"]");
      V1=module(V1)+syz(power(M-eM[i],n+1));
      V[i]=interred(intersect(V1,V0));

      if(size(V[i])>size(V[i+1]))
      {
        k++;
        a[k]=eM[i]-1;
        d[k]=size(V[i])-size(V[i+1]);
      }
    }

    dbprint(printlevel-voice+2,"// apply symmetry");
    while(j>=1)
    {
      k++;
      a[k]=a[j];
      a[j]=n-1-a[k];
      d[k]=d[j];
      j--;
    }

    setring(R);
    ideal a=imap(G,a);
    return(list(a,d));
  }
  else
  {
    list v;
    int j=-1;
    for(i=ncols(eM);i>=1;i--)
    {
      dbprint(printlevel-voice+2,"// compute V["+string(i)+"]");
      V1=module(V1)+syz(power(M-eM[i],n+1));
      V[i]=interred(intersect(V1,V0));

      if(size(V[i])>size(V[i+1]))
      {
        if(number(eM[i]-1)>=number(n-1)/2)
        {
          k++;
          a[k]=eM[i]-1;
          v[k]=matrix(freemodule(ncols(V[i])),mu,mu*N)*division(V0,V[i])[1];
        }
        else
        {
          if(j<0)
          {
            if(a[k]==number(n-1)/2)
            {
              j=k-1;
            }
            else
            {
              j=k;
            }
          }
          k++;
          a[k]=a[j];
          a[j]=eM[i]-1;
          v[k]=v[j];
          v[j]=matrix(freemodule(ncols(V[i])),mu,mu*N)*division(V0,V[i])[1];
          j--;
        }
      }
    }

    dbprint(printlevel-voice+2,"// compute graded parts");
    for(k=1;k<size(v);k++)
    {
      v[k]=interred(reduce(v[k],std(v[k+1])));
      d[k]=size(v[k]);
    }
    v[k]=interred(v[k]);
    d[k]=size(v[k]);

    setring(R);
    ideal a=imap(G,a);
    list v=imap(G,v);
    ideal m=imap(G,gmsbasis);
    ideal g=imap(G,gmsstd);
    attrib(g,"isSB",1);
    return(list(a,d,v,m,g));
  }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  vfilt1(t);
}
///////////////////////////////////////////////////////////////////////////////

static proc grmat(matrix A,int k)
{
  int i,j;
  for(i=1;i<=ncols(A);i++)
  {
    for(j=1;j<=nrows(A);j++)
    {
      A[i,j]=jet(A[i,j]/var(1)^k,0);
    }
  }
  return(A);
}
///////////////////////////////////////////////////////////////////////////////

proc saito(poly t,list #)
"USAGE:    saito(t); poly t
ASSUME:   basering with characteristic 0 and local degree ordering,
          t with isolated citical point 0
RETURN:   list A: matrix A[1]+A[2]*s of t on H''
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          mixed Hodge structure; V-filtration; weight filtration;
          spectrum; spectral pairs
EXAMPLE:  example saito; shows examples
"
{
  def R=basering;
  int n=nvars(R)-1;
  def G=gmsring(t,"s");
  setring(G);

  int mu=ncols(gmsbasis);
  matrix A;
  module U0;
  ideal e;
  intvec m;
  int k1;

  def A0,r,H,H0,k0=saturate(2*n+mu-1);
  e,m,A0,r,k1=eigenvals(A0,r,H,k0,n);
  A,A0,r,H0,U0,e,m=transform(A,A0,r,H,H0,e,m,k0,k1,k0+k1,k0+k1);

  dbprint(printlevel-voice+2,"// transform to Jordan basis");
  module U=jordanbasis(A,e,m)[1];
  matrix V=inverse(U);
  A=V*A*U;
  H=V*H0;

  dbprint(printlevel-voice+2,"// compute splitting of V-filtration");
  int i,j,k;
  U=freemodule(mu);
  V=matrix(0,mu,mu);
  matrix v[mu^2][1];
  A0=commutator(jet(A,0));
  for(k=1;k<=k0+k1;k++)
  {
    for(j=0;j<k;j++)
    {
      V=matrix(V)-grmat(A,k-j)*grmat(U,j);
    }
    v=V[1..mu,1..mu];
    v=inverse(A0+k)*v;
    V=v[1..mu^2,1];
    U=matrix(U)+s^k*V;
  }

  dbprint(printlevel-voice+2,"// transform to V-splitting basis");
  A=jet(A,0);
  H=jet(division(U,H)[1],k0+k1);
  H=std(H);

  dbprint(printlevel-voice+2,"// compute V-leading terms of H''");
  int i0,j0;
  module H1=H;
  for(k=ncols(H1);k>=1;k--)
  {
    i0=leadexp(H1[k])[nvars(basering)+1];
    j0=ord(H1[k])/deg(s);
    H0[k]=lead(H1[k]);
    H1[k]=H1[k]-lead(H1[k]);
    if(H1[k]!=0)
    {
      i=leadexp(H1[k])[nvars(basering)+1];
      j=ord(H1[k])/deg(s);
      while(A[i,i]+j==A[i0,i0]+j0)
      {
        H0[k]=H0[k]+lead(H1[k]);
        H1[k]=H1[k]-lead(H1[k]);
        i=leadexp(H1[k])[nvars(basering)+1];
        j=ord(H1[k])/deg(s);
      }
    }
  }
  H0=simplify(H0,1);

  dbprint(printlevel-voice+2,"// compute N");
  matrix N=A;
  for(i=1;i<=ncols(N);i++)
  {
    N[i,i]=0;
  }

  dbprint(printlevel-voice+2,"// compute splitting of Hodge filtration");
  U=0;
  module U1;
  module C;
  list F,I;
  module F0,I0;
  for(i0,j0=1,1;i0<=ncols(e);i0++)
  {
    C=matrix(0,mu,1);
    for(j=m[i0];j>=1;j,j0=j-1,j0+1)
    {
      C=C+gen(j0);
    }
    F0=intersect(C,H0);
    F=list();
    j=0;
    while(size(F0)>0)
    {
      j++;
      F[j]=matrix(0,mu,1);
      if(size(jet(F0,0))>0)
      {
        for(i=ncols(F0);i>=1;i--)
        {
          if(ord(F0[i])==0)
          {
            F[j]=F[j]+F0[i];
          }
        }
      }
      for(i=ncols(F0);i>=1;i--)
      {
        F0[i]=F0[i]/s;
      }
    }

    I=list();
    I0=module();
    U0=std(0);
    for(i=size(F);i>=1;i--)
    {
      I[i]=module();
    }
    for(i=1;i<=size(F);i++)
    {
      I0=reduce(F[i],U0);
      j=i;
      while(size(I0)>0)
      {
        U0=std(U0+I0);
        I[j]=I[j]+I0;
        I0=reduce(N*I0,U0);
        j++;
      }
    }

    for(i=1;i<=size(I);i++)
    {
      U=U+I[i];
    }
  }

  dbprint(printlevel-voice+2,"// transform to Hodge splitting basis");
  V=inverse(U);
  A=V*A*U;
  H=V*H;

  dbprint(printlevel-voice+2,"// compute reduced standard basis of H''");
  ring S=0,s,ds;
  module H=imap(G,H);
  degBound=k0+k1+1;
  option("redSB");
  H=std(H);
  degBound=0;
  H=simplify(jet(H,k0+k1),1);
  setring(G);
  H=imap(S,H);

  dbprint(printlevel-voice+2,"// compute matrix A0+sA1 of t");
  list l=division(H,s*A*H+s^2*diff(matrix(H),s));
  A=jet(l[1],l[2],k0+k1+1);
  A0=grmat(A,0);
  A=grmat(A,1);

  setring(R);
  return(list(imap(G,A0),imap(G,A)));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  list A=saito(t);
  print(A[1]);
  print(A[2]);
}
///////////////////////////////////////////////////////////////////////////////

proc endvfilt(list V)
"USAGE:   endvwfilt(V); list V
ASSUME:  V computed by vfilt
RETURN:
@format
list EV: endomorphism V-filtration on the Jacobian algebra
  ideal EV[1]: spectral numbers in increasing order
  intvec EV[2]:
    int EV[2][i]: multiplicity of spectral pair (EV[1][i],EV[2][i])
  list EV[3]:
    module EV[3][i]: vector space basis of the (EV[1][i],EV[2][i])-th 
                      graded part in terms of EV[4]
  ideal EV[4]: monomial vector space basis
  ideal EV[5]: standard basis of Jacobian ideal
@end format
SEE ALSO: spectrum_lib
KEYWORDS: singularities; Gauss-Manin connection; Brieskorn lattice;
          mixed Hodge structure; V-filtration; weight filtration;
          endomorphism filtration
EXAMPLE: example endvwfilt; shows examples
"
{
  def a,d,v,m,g=V[1..5];
  int mu=ncols(m);

  module V0=v[1];
  for(int i=2;i<=size(v);i++)
  {
    V0=V0,v[i];
  }

  dbprint(printlevel-voice+2,"// compute multiplication in Jacobian algebra");
  list M;
  module U=freemodule(ncols(m));
  for(i=ncols(m);i>=1;i--)
  {
    M[i]=division(V0,coeffs(reduce(m[i]*m,U,g),m)*V0)[1];
  }

  int j,k,i0,j0,i1,j1;
  number b0=number(a[1]-a[ncols(a)]);
  number b1,b2;
  matrix M0;
  module L;
  list v0=freemodule(ncols(m));
  ideal a0=b0;

  while(b0<number(a[ncols(a)]-a[1]))
  {
    dbprint(printlevel-voice+2,"// find next possible index");
    b1=number(a[ncols(a)]-a[1]);
    for(j=ncols(a);j>=1;j--)
    {
      for(i=ncols(a);i>=1;i--)
      {
        b2=number(a[i]-a[j]);
        if(b2>b0&&b2<b1)
        {
          b1=b2;
        }
        else
        {
          if(b2<=b0)
          {
            i=0;
          }
        }
      }
    }
    b0=b1;

    list l=ideal();
    for(k=ncols(m);k>=2;k--)
    {
      l=l+list(ideal());
    }

    dbprint(printlevel-voice+2,"// collect conditions for EV["+string(b0)+"]");
    j=ncols(a);
    j0=mu;
    while(j>=1)
    {
      i0=1;
      i=1;
      while(i<ncols(a)&&a[i]<a[j]+b0)
      {
        i0=i0+d[i];
        i++;
      }
      if(a[i]<a[j]+b0)
      {
        i0=i0+d[i];
        i++;
      }
      for(k=1;k<=ncols(m);k++)
      {
        M0=M[k];
        if(i0>1)
        {
          l[k]=l[k],M0[1..i0-1,j0-d[j]+1..j0];
        }
      }
      j0=j0-d[j];
      j--;
    }

    dbprint(printlevel-voice+2,"// compose condition matrix");
    L=transpose(module(l[1]));
    for(k=2;k<=ncols(m);k++)
    {
      L=L,transpose(module(l[k]));
    }

    dbprint(printlevel-voice+2,"// compute kernel of condition matrix");
    v0=v0+list(syz(L));
    a0=a0,b0;
  }

  dbprint(printlevel-voice+2,"// compute graded parts");
  option(redSB);
  for(i=1;i<size(v0);i++)
  {
    v0[i+1]=std(v0[i+1]);
    v0[i]=std(reduce(v0[i],v0[i+1]));
  }

  dbprint(printlevel-voice+2,"// remove trivial graded parts");
  i=1;
  while(size(v0[i])==0)
  {
    i++;
  }
  list v1=v0[i];
  intvec d1=size(v0[i]);
  ideal a1=a0[i];
  i++;
  while(i<=size(v0))
  {
    if(size(v0[i])>0)
    {
      v1=v1+list(v0[i]);
      d1=d1,size(v0[i]);
      a1=a1,a0[i];
    }
    i++;
  }
  return(list(a1,d1,v1,m,g));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  poly t=x5+x2y2+y5;
  endvfilt(vfilt(t));
}
///////////////////////////////////////////////////////////////////////////////

proc spprint(list Sp)
"USAGE:   spprint(Sp); list Sp
RETURN:  string: spectrum Sp
EXAMPLE: example spprint; shows examples
"
{
  string s;
  for(int i=1;i<size(Sp[2]);i++)
  {
    s=s+"("+string(Sp[1][i])+","+string(Sp[2][i])+"),";
  }
  s=s+"("+string(Sp[1][i])+","+string(Sp[2][i])+")";
  return(s);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp);
}
///////////////////////////////////////////////////////////////////////////////

proc sppprint(list Spp)
"USAGE:   sppprint(Sp); list Spp
RETURN:  string: spectral pairs Spp
EXAMPLE: example sppprint; shows examples
"
{
  string s;
  for(int i=1;i<size(Spp[3]);i++)
  {
    s=s+"(("+string(Spp[1][i])+","+string(Spp[2][i])+"),"+string(Spp[3][i])+"),";
  }
  s=s+"(("+string(Spp[1][i])+","+string(Spp[2][i])+"),"+string(Spp[3][i])+")";
  return(s);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Spp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(2,1,1,1,1,1,0),intvec(1,2,2,1,2,2,1));
  sppprint(Spp);
}
///////////////////////////////////////////////////////////////////////////////

proc spadd(list Sp1,list Sp2)
"USAGE:   spadd(Sp1,Sp2); list Sp1,Sp2
RETURN:  list: sum of spectra Sp1 and Sp2
EXAMPLE: example spadd; shows examples
"
{
  ideal s;
  intvec m;
  int i,i1,i2=1,1,1;
  while(i1<=size(Sp1[2])||i2<=size(Sp2[2]))
  {
    if(i1<=size(Sp1[2]))
    {
      if(i2<=size(Sp2[2]))
      {
        if(number(Sp1[1][i1])<number(Sp2[1][i2]))
        {
          s[i]=Sp1[1][i1];
          m[i]=Sp1[2][i1];
          i++;
          i1++;
        }
        else
        {
          if(number(Sp1[1][i1])>number(Sp2[1][i2]))
          {
            s[i]=Sp2[1][i2];
            m[i]=Sp2[2][i2];
            i++;
            i2++;
          }
          else
          {
            if(Sp1[2][i1]+Sp2[2][i2]!=0)
            {
              s[i]=Sp1[1][i1];
              m[i]=Sp1[2][i1]+Sp2[2][i2];
              i++;
            }
            i1++;
            i2++;
          }
        }
      }
      else
      {
        s[i]=Sp1[1][i1];
        m[i]=Sp1[2][i1];
        i++;
        i1++;
      }
    }
    else
    {
      s[i]=Sp2[1][i2];
      m[i]=Sp2[2][i2];
      i++;
      i2++;
    }
  }
  return(list(s,m));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp1);
  list Sp2=list(ideal(-1/6,1/6),intvec(1,1));
  spprint(Sp2);
  spprint(spadd(Sp1,Sp2));
}
///////////////////////////////////////////////////////////////////////////////

proc spsub(list Sp1,list Sp2)
"USAGE:   spsub(Sp1,Sp2); list Sp1,Sp2
RETURN:  list: difference of spectra Sp1 and Sp2
EXAMPLE: example spsub; shows examples
"
{
  return(spadd(Sp1,spmul(Sp2,-1)));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp1);
  list Sp2=list(ideal(-1/6,1/6),intvec(1,1));
  spprint(Sp2);
  spprint(spsub(Sp1,Sp2));
}
///////////////////////////////////////////////////////////////////////////////

proc spmul(list #)
"USAGE:
@format
1) spmul(Sp,k); list Sp, int k
2) spmul(Sp,k); list Sp, intvec k
@end format
RETURN:
@format
1) list: product of spectrum Sp and integer k
2) list: linear combination of spectra Sp with coefficients k
@end format
EXAMPLE: example spmul; shows examples
"
{
  if(size(#)==2)
  {
    if(typeof(#[1])=="list")
    {
      if(typeof(#[2])=="int")
      {
        return(list(#[1][1],#[1][2]*#[2]));
      }
      if(typeof(#[2])=="intvec")
      {
        list Sp0=list(ideal(),intvec(0));
        for(int i=size(#[2]);i>=1;i--)
        {
          Sp0=spadd(Sp0,spmul(#[1][i],#[2][i]));
        }
        return(Sp0);
      }
    }
  }
  return(list(ideal(),intvec(0)));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp);
  spprint(spmul(Sp,2));
  list Sp1=list(ideal(-1/6,1/6),intvec(1,1));
  spprint(Sp1);
  list Sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
  spprint(Sp2);
  spprint(spmul(list(Sp1,Sp2),intvec(1,2)));
}
///////////////////////////////////////////////////////////////////////////////

proc spissemicont(list Sp,list #)
"USAGE:   spissemicont(Sp[,opt]); list Sp, int opt
RETURN:
@format
int k=
if opt=0:
  1, if sum of spectrum Sp over all intervals [a,a+1) is positive
  0, if sum of spectrum Sp over some interval [a,a+1) is negative
if opt=1:
  1, if sum of spectrum Sp over all intervals [a,a+1) and (a,a+1) is positive
  0, if sum of spectrum Sp over some interval [a,a+1) or (a,a+1) is negative
default: opt=0
@end format
EXAMPLE: example spissemicont; shows examples
"
{
  int opt=0;
  if(size(#)>0)
  {
    if(typeof(#[1])=="int")
    {
      opt=1;
    }
  }
  int i,j,k=1,1,0;
  while(j<=size(Sp[2]))
  {
    while(j+1<=size(Sp[2])&&Sp[1][j]<Sp[1][i]+1)
    {
      k=k+Sp[2][j];
      j++;
    }
    if(j==size(Sp[2])&&Sp[1][j]<Sp[1][i]+1)
    {
      k=k+Sp[2][j];
      j++;
    }
    if(k<0)
    {
      return(0);
    }
    k=k-Sp[2][i];
    if(k<0&&opt==1)
    {
      return(0);
    }
    i++;
  }
  return(1);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp1);
  list Sp2=list(ideal(-1/6,1/6),intvec(1,1));
  spprint(Sp2);
  spissemicont(spsub(Sp1,spmul(Sp2,5)));
  spissemicont(spsub(Sp1,spmul(Sp2,5)),1);
  spissemicont(spsub(Sp1,spmul(Sp2,6)));
}
///////////////////////////////////////////////////////////////////////////////

proc spsemicont(list Sp0,list Sp,list #)
"USAGE:   spsemicont(Sp,k[,opt]); list Sp0, list Sp, int opt
RETURN:  list of intvecs l:
         spissemicont(sub(Sp0,spmul(Sp,k)),opt)==1 iff k<=l[i] for some i
NOTE:    if the spectra Sp occur with multiplicities k in a deformation
         of the [quasihomogeneous] spectrum Sp0 then 
         spissemicont(sub(Sp0,spmul(Sp,k))[,1])==1
EXAMPLE: example spsemicont; shows examples
"
{
  list l,l0;
  int i,j,k;
  while(spissemicont(Sp0,#))
  {
    if(size(Sp)>1)
    {
      l0=spsemicont(Sp0,list(Sp[1..size(Sp)-1]));
      for(i=1;i<=size(l0);i++)
      {
        if(size(l)>0)
	{
          j=1;
          while(j<size(l)&&l[j]!=l0[i])
	  {
            j++;
          }
          if(l[j]==l0[i])
	  {
            l[j][size(Sp)]=k;
          }
          else
	  {
            l0[i][size(Sp)]=k;
            l=l+list(l0[i]);
          }
	}
        else
	{
          l=l0;
	}
      }
    }
    Sp0=spsub(Sp0,Sp[size(Sp)]);
    k++;
  }
  if(size(Sp)>1)
  {
    return(l);
  }
  else
  {
    return(list(intvec(k-1)));
  }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp0=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp0);
  list Sp1=list(ideal(-1/6,1/6),intvec(1,1));
  spprint(Sp1);
  list Sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
  spprint(Sp2);
  list Sp=Sp1,Sp2;
  list l=spsemicont(Sp0,Sp);
  l;
  spissemicont(spsub(Sp0,spmul(Sp,l[1])));
  spissemicont(spsub(Sp0,spmul(Sp,l[1]-1)));
  spissemicont(spsub(Sp0,spmul(Sp,l[1]+1)));
}
///////////////////////////////////////////////////////////////////////////////

proc spmilnor(list Sp)
"USAGE:   spmilnor(Sp); list Sp
RETURN:  int: Milnor number of spectrum Sp
EXAMPLE: example spmilnor; shows examples
"
{
  return(sum(Sp[2]));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp);
  spmilnor(Sp);
}
///////////////////////////////////////////////////////////////////////////////

proc spgeomgenus(list Sp)
"USAGE:   spgeomgenus(Sp); list Sp
RETURN:  int: geometrical genus of spectrum Sp
EXAMPLE: example spgeomgenus; shows examples
"
{
  int g=0;
  int i=1;
  while(i+1<=size(Sp[2])&&number(Sp[1][i])<=number(0))
  {
    g=g+Sp[2][i];
    i++;
  }
  if(i==size(Sp[2])&&number(Sp[1][i])<=number(0))
  {
    g=g+Sp[2][i];
  }
  return(g);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp);
  spgeomgenus(Sp);
}
///////////////////////////////////////////////////////////////////////////////

proc spgamma(list Sp)
"USAGE:   spgamma(Sp); list Sp
RETURN:  number: gamma invariant of spectrum Sp
EXAMPLE: example spgamma; shows examples
"
{
  int i,j;
  number g=0;
  for(i=1;i<=ncols(Sp[1]);i++)
  {
    for(j=1;j<=Sp[2][i];j++)
    {
      g=g+(number(Sp[1][i])-number(nvars(basering)-2)/2)^2;
    }
  }
  g=-g/4+sum(Sp[2])*number(Sp[1][ncols(Sp[1])]-Sp[1][1])/48;
  return(g);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y),ds;
  list Sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
  spprint(Sp);
  spgamma(Sp);
}
///////////////////////////////////////////////////////////////////////////////
