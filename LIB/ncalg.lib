///////////////////////////////////////////////////////////////////////////////
version="$Id: ncalg.lib,v 1.5 2004-05-28 20:58:14 levandov Exp $";
category="Noncommutative";
info="
LIBRARY:  ncalg.lib      definitions of important G-algebras
AUTHORS:  Viktor Levandovskyy,     levandov@mathematik.uni-kl.de,
          Oleksandr Motsak,        motsak@mathematik.uni-kl.de,
          Oleksandr Khomenko,      Oleksandr.Khomenko@math.uni-freiburg.de.

PROCEDURES:
sl(n[,p]);   returns U(sl_n) in char p, if an integer p is given,
sl2([p]);    returns U(sl_2) in the (e,f,h) presentation; in char p, if an integer p is given, 
g2([p]);     returns U(g_2) in the (x(i),y(i),Ha,Hb) presentation; in char p, if an integer p is given,
gl(n,[p]);    returns U(gl_n) in the (e_ij (1<i,j<n)) presentation; in char p, if an integer p is given,
Qso3([n]);   returns U_q(so_3) in the presentation of Klimyk, if integer n is given, the quantum parameter will be specialized at the (2n)-th root of unity, 
Qso3Casimir(n); returns a list with the normalized Casimir elements of U_q(so_3) for the quantum parameter specialized at the n-th root of unity,
Qsl2([n]); returns ring, corresponding to the V_q(sl_2) and the ideal Qideal in it, such that U_q(sl_2) = V_q(sl_2) / Qideal; if n is specified, the quantum parameter q will be specialized at the n-th root of unity
Qsl3([n]); returns ring, corresponding to the V_q(sl_3) and the ideal Qideal in it, such that U_q(sl_3) = V_q(sl_3) / Qideal; if n is specified, the quantum parameter q will be specialized at the n-th root of unity
";

LIB "nctools.lib";
LIB "general.lib";
///////////////////////////////////////////////////////////////////////////////

// functions for debug/logging 

proc mySetRing (string @baseName, list #)
// set @@@_RING to description of current ring
{
  if (defined( @@@_RING_NAME ))
  {
    kill @@@_RING_NAME; 
  }
  
  if (string(#) != "0")
  {
    string @@@_RING_NAME = @baseName + "_" + string(#);	
  } 
  else
  {
    string @@@_RING_NAME = @baseName;
  }
  export(@@@_RING_NAME);
  
  if (defined( @@@_RING ))
  {
    kill @@@_RING; 
  }
  
  string @@@_RING = "" + @baseName +"(" + string(#) + ")";
  export(@@@_RING);

  if( defined(@@@_CHAR))
  {
    kill @@@_CHAR;
  }
  
  int @@@_CHAR = char(basering);
  export(@@@_CHAR);
}

proc myGetRing ()
// get desription of current ring
{
  if (defined( @@@_RING ))
  {
    return( @@@_RING );
  }
  return( "No lieA.lib ring defined" );
}

proc myGetRingName ()
// get desription of current ring, only family
{
  if (defined( @@@_RING_NAME ))
  {
    return( @@@_RING_NAME );
  }
  
  return( "No lieA.lib ring defined" );
}

proc myGetRingChar ()
// get desription of current ring, only family
{
  if (defined( @@@_CHAR ))
  {
    return( @@@_CHAR );
  }
  
  return( char(basering) ); 
}


proc myInt ( list # )
// return 0 or int(#)
{
  int @p = 0;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @p = #[1];
    }
  }
  return (@p);
}


///////////////////////////////////////////////////////////////////////////////
proc sl2(list #)
"USAGE:   sl2([p]), p an optional integer (field characteristic)
RETURN:  ring, corresponding to the U(sl_2) in (e,f,h) presentation
NOTE:    you have to activate this ring with the "setring" command
SEE ALSO: sl, g2, gl
EXAMPLE: example sl2; shows examples
"{
   int @p = myInt(#);
   ring @@@rrr=@p,(e,f,h),dp;
   matrix D[3][3]=0;
   D[1,2]=-h;
   D[1,3]=2*e;
   D[2,3]=-2*f;
   ncalgebra(1,D);
   mySetRing("sl2", #);
   return(@@@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=sl2();
   setring a;
   a;
}

///////////////////////////////////////////////////////////////////////////////

proc sl(int n, list #)
"USAGE:   sl(n,[p]); n an integer, n>1; p an optional integer (field characteristic)
RETURN:  a ring, describing U(sl_n)
NOTE:    You have to activate this ring with the "setring" command. The presentation of U(sl_n) is derived from the standard representation of sl_n, positive resp. negative roots are denoted by x(i) resp. y(i); Cartan elements are denoted by h(i).
SEE ALSO: sl2, g2, gl, Qsl3, Qso3
EXAMPLE: example sl; shows examples
"{
  if (n<2)
  {
    Print("Incorrect input");
    return(0);
  }
  if (n==2)
  {
    def @@@a=sl2(#);
    setring @@@a;
    mySetRing("sl", n, #);
    return(@@@a);
  }
  
  int @p = myInt(#);
  ring @@@rr=@p,(x(1..n*(n-1)/2),y(1..n*(n-1)/2),h(1..n-1)),dp;
  intmat CNT[n][n]=0;
  matrix TMP[n][n]=0;
  int k,l=1,1;
  int buf=0;  
  list X,Y,H;
  for(k=1; k<=n; k++)
  {
    for(l=k+1; l<=n; l++)
    {
      buf = (l-k-1)*(2*n-l+k)/2 + k; 
      CNT[k,l] = buf;
      TMP[k,l] = 1;
      X[buf] = TMP;
      TMP = 0;
      CNT[l,k] = buf;
      TMP[l,k] = 1;
      Y[buf] = TMP;
      TMP=0;   
    }
  }
  for(k=1; k<=n-1; k++)
  {
    TMP[k,k]=1;
    TMP[k+1,k+1]=-1;
    H[k]=TMP;
    TMP=0;
  }  
  int i,j=1,1;
  number p,q=0,0;
  list V=X+Y+H;
  int v=size(V);
  matrix D[v][v]=0;  
  for(k=1; k<=v; k++)
  {
    for(l=k+1; l<=v; l++)
    {
      TMP=V[l]*V[k]-V[k]*V[l];
      for(i=1; i<=n; i++)
      {
        for(j=i+1; j<=n; j++)
        {
          buf=(j-i-1)*(2*n-j+i)/2+i;
          if (TMP[i,j]!=0)
          {
	    D[k,l]=D[k,l]+leadcoef(TMP[i,j])*x(buf);
          }
          if (TMP[j,i]!=0)
          {          
	    D[k,l]=D[k,l]+leadcoef(TMP[j,i])*y(buf);
          }
        }
      }
      i=1;
      while ( (TMP[i,i]==0) && (i<n) ) { i++; }
      for(j=i; j<=n-1; j++)
      {
        p=leadcoef(TMP[j,j]);
        q=leadcoef(TMP[j+1,j+1]);
        D[k,l]=D[k,l]+p*h(j);
	//        if ((j!=n-1)&&((p+q)!=0)) {D[k,l]=D[k,l]+(p+q)*h(j+1);}
        TMP[j+1,j+1]=TMP[j+1,j+1]+p; 
      }
    }
  }
  ncalgebra(1,D);
  mySetRing("sl", n, #);
  return(@@@rr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=sl(3);
   setring a;
   a;
}

///////////////////////////////////////////////////////////////////////////////

proc g2(list #)
"USAGE:  g2([p]), p an optional integer (field characteristic)
RETURN:  ring, corresponding to the U(g_2) in (x(i),y(i),Ha,Hb) presentation
NOTE:    you have to activate this ring with the "setring" command
SEE ALSO: sl, gl
EXAMPLE: example g2; shows examples
"{
  int @p = myInt(#);
  ring @@@rrr=@p,(x(1..6),y(1..6),Ha,Hb),dp;
  setring @@@rrr;
  matrix D[14][14];
  D[1,2]=-x(3);
  D[1,3]=-2*x(4);
  D[1,4]=3*x(5);
  D[1,7]=-Ha;
  D[1,9]=3*y(2);
  D[1,10]=2*y(3);
  D[1,11]=-y(4);
  D[1,13]=2*x(1);
  D[1,14]=-x(1);
  D[2,5]=x(6);
  D[2,8]=-Hb;
  D[2,9]=-y(1);
  D[2,12]=-y(5);
  D[2,13]=-3*x(2);
  D[2,14]=2*x(2);
  D[3,4]=3*x(6);
  D[3,7]=3*x(2);
  D[3,8]=-x(1);
  D[3,9]=-Ha-3*Hb;
  D[3,10]=-2*y(1);
  D[3,12]=-y(4);
  D[3,13]=-x(3);
  D[3,14]=x(3);
  D[4,7]=2*x(3);
  D[4,9]=-2*x(1);
  D[4,10]=-2*Ha-3*Hb;
  D[4,11]=y(1);
  D[4,12]=y(3);
  D[4,13]=x(4);
  D[5,7]=-x(4);
  D[5,10]=x(1);
  D[5,11]=-Ha-Hb;
  D[5,12]=y(2);
  D[5,13]=3*x(5);
  D[5,14]=-x(5);
  D[6,8]=-x(5);
  D[6,9]=-x(4);
  D[6,10]=x(3);
  D[6,11]=x(2);
  D[6,12]=-Ha-2*Hb;
  D[6,14]=x(6);
  D[7,8]=y(3);
  D[7,9]=2*y(4);
  D[7,10]=-3*y(5);
  D[7,13]=-2*y(1);
  D[7,14]=y(1);
  D[8,11]=-y(6);
  D[8,13]=3*y(2);
  D[8,14]=-2*y(2);
  D[9,10]=-3*y(6);
  D[9,13]=y(3);
  D[9,14]=-y(3);
  D[10,13]=-y(4);
  D[11,13]=-3*y(5);
  D[11,14]=y(5);
  D[12,14]=-y(6);
  ncalgebra(1,D);
  mySetRing("g2", #);
  return(@@@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=g2();
   setring a;
   a;
}

///////////////////////////////////////////////////////////////////////////////
proc gl(int n, list #)
"
USAGE:   gl(n,[p]); n an integer, n>1;  p an optional integer (field characteristic)
RETURN:  ring, corresponding to the U(gl_n) in the (e_ij (1<i,j<n)) presentation
NOTE:    You have to activate this ring with the "setring" command.
SEE ALSO: sl, g2
EXAMPLE: example gl; shows examples
"{
  if (n<2)
  {
    print("Incorrect input");
    return(0);
  };
  int @p = myInt(#);
  int i, j;
  string vs = "";
  for ( i = 1; i<= n ; i++ )
  {
        for ( j = 1; j<= n ; j++ )
	{
	    if ( vs != "" ) 
	    {
		vs = vs + ", ";
	    };
	    vs = vs + "e_" + string(i) + "_" + string(j);    
	};  
  };
  string strRING = "ring RING_GL=(" + string (@p) + "), (" + vs + "),dp;";
  execute( strRING );
  int N = nvars( RING_GL ); // n*n
  matrix D[N][N]=0;
  int k, l;
  int ik,il,jk,jl;
  poly p ;
  for( k=1; k<=N; k++)
  {
    ik = 1 + ((k-1)/n);
    jk = k -  n*(ik-1);
    
    for( l=k+1; l<=N; l++)
    {
        il = 1 + ((l-1)/n);
	jl = l -  n*(il-1);
	p = 0;    
	if( jl == ik )
	{
	    p = p + var ( (il-1)*n + jk );
	};
	if( jk == il )
	{
	    p = p - var ( (ik-1)*n + jl );
	};
	D[k,l]=p;
    };
  };
  ncalgebra(1,D);
  mySetRing("gl", n, #);  
  return(RING_GL);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=gl(3);
   setring a;
   a;
};

///////////////////////////////////////////////////////////////////////////////

proc Qso3(list #)
"USAGE:   Qso3([n]), n an optional integer
RETURN:  ring, corresponding to the U_q(so_3) in the presentation of Klimyk; if n is specified, the quantum parameter Q will be specialized at the (2*n)-th root of unity
NOTE:    you have to activate this ring with the "setring" command
SEE ALSO: sl, g2, gl, Qsl2, Qsl3, Qso3Casimir
EXAMPLE: example Qso3; shows examples
"{
  int @p = myInt(#); 
  @p = 2*@p;
  ring @@@r=(0,Q),(x,y,z),dp;
  minpoly = RootOfUnity(@p);
  matrix C[3][3];
  C[1,2]=Q2;
  C[1,3]=1/Q2;
  C[2,3]=Q2;
  matrix D[3][3];
  D[1,2]=-Q*z;
  D[1,3]=1/Q*y;
  D[2,3]=-Q*x;
  ncalgebra(C,D);
  mySetRing("Qso3", #);
  return(@@@r);
}
example
{ "EXAMPLE:"; echo = 2;
   def K = Qso3(3);
   setring K;
   K;
}

///////////////////////////////////////////////////////////////////////////////

proc Qso3Casimir(int n)
"USAGE:   Qso3Casimir(n), n an integer
RETURN:  list with the normalized Casimir elements of U_q(so_3) for the quantum parameter specialized at the n-th root of unity
NOTE:    the result of the procedure makes sense only in U_q(so_3)
SEE ALSO: Qso3
EXAMPLE: example Qso3Casimir; shows examples
"{
  if ( npars(basering) !=1 )
  {
    "Error: wrong algebra. U_q(so3) has only one parameter";
    return(0);
  }
  if (n<1) { return(0); }
  number Q = par(1);
  int N=(n-1)/2;
  int NV=nvars(basering);
  number k1,k2;
  poly p,rs,hlp;
  list cp;
  int j;
  p=var(1);
  for(j=0; j<=N; j++)
  {
    k1 = binomial(n-j,j,0);
    k1=k1/(n-j);
    k1=k1*((-1)^j);
    k2=((Q^2)/(Q^4-1))^(2*j);
    k2=k2*k1;
    hlp=k2*(p)^(n-(2*j));
    rs=rs+hlp;
    hlp=0; k2=0; k1=0;
  }
  rs=cleardenom(rs);
  cp[1] = rs;
  for(j=2; j<=NV; j++)
  {
    cp[j] = subst(rs,var(1),var(j));
  }
  return(cp);
}
example
{ "EXAMPLE:"; echo = 2;
   def R = Qso3(5);
   setring R;
   list C=Qso3Casimir(5);
   C;
}

///////////////////////////////////////////////////////////////////////////////

proc Qsl2(list #)
"USAGE:   Qsl2([n]), n an optional integer
RETURN:  ring, corresponding to the V_q(sl_2) and the ideal Qideal in it. U_q(sl_2) = V_q(sl_2) / Qideal; if n is specified, the quantum parameter q will be specialized at the n-th root of unity
NOTE:    you have to activate this ring with the "setring" command. If you wish to set the U_q(sl_2), you have to call the command "qring Usl2q = Qideal;"
SEE ALSO: sl, Qsl3, Qso3 
EXAMPLE: example Qsl2; shows examples
"
{
  ring r=(0,q),(E,F,Ke,Kf),dp;
  int @p = myInt(#);
  if (@p >1) 
  {
    minpoly = RootOfUnity(@p);
  }
  matrix C = UpOneMatrix(4);;
  matrix D[4][4];
  C[1,3]=q^2;
  C[2,3]=1/(q^2);
  C[1,4]=1/(q^2);
  C[2,4]=q^2;
  D[1,2]=(1/(q-(1/q)))*(-Ke+Kf);
  ncalgebra(C,D);
  ideal Qideal = Ke*Kf-1;
  Qideal = twostd(Qideal);
  export Qideal; 
  mySetRing("Qsl2", #);
  return(r);
}
example
{ "EXAMPLE:"; echo = 2;
   def A = Qsl2(3);
   setring A;
   Qideal;
   qring Usl2q = Qideal;
   Usl2q;
}	
///////////////////////////////////////////////////////////////////////////////

proc Qsl3(list #)
"USAGE:   Qsl3([n]), n an optional integer
RETURN:  ring, corresponding to the V_q(sl_3) and the ideal Qideal in it. U_q(sl_3) = V_q(sl_3) / Qideal; if n is specified, the quantum parameter q will be specialized at the n-th root of unity
NOTE:    you have to activate this ring with the "setring" command. If you wish to set the U_q(sl_3), you have to call the command "qring Usl3q = Qideal;"
SEE ALSO: sl, Qsl2, Qso3
EXAMPLE: example Qsl3; shows examples
"{
  int @p = myInt(#);
  //   ring @@@rrr=(@p, q), (f12, f13, f23, k1, k2, l1, l2, e12, e13, e23), wp(7, 10, 11, 1, 1, 1, 1, 7, 10, 11);
  
  ring @@@rrr=(0, q), (f12, f13, f23, k1, k2, l1, l2, e12, e13, e23), wp(3, 5, 3, 1, 1, 1, 1, 1, 1, 1);
  if (@p >1) 
  {
    minpoly = RootOfUnity(@p);
  }
  int @n = nvars(@@@rrr);
  matrix C = UpOneMatrix(@n);
  matrix D[@n][@n];
  // some constants
  number q1 =    1/q;
  number Q  = (q )^2;
  number Q1 = (q1)^2;
  //   number QQ = Q - Q1; // q2 - 1/(q2)
  number QQ1= 1 / (Q - Q1);  
  // relations:
  C[1,2] = Q1;
  C[2,3] = C[1,2];
  C[8,9] = C[1,2];
  C[9,10]= C[1,2];
  C[1,3] = Q;
  C[8,10]= C[1,3];
  
  D[1,3] = -q*(f13);
  D[8,10]= -q*(e13);
  // V_q(sl_3)
  D[1,8] = QQ1 * ( (k1) ^ 2 - (l1) ^ 2 );
  D[3,10]= QQ1 * ( (k2) ^ 2 - (l2) ^ 2 );
  D[2,9] = -QQ1 * ( ((k1)^2)*((k2)^2) - ((l1)^2)*((l2)^2) );
  D[2, 8] =   q * (f23) * ((k1)^2);
  D[3, 9] =   q * ((k2)^2) * (e12);
  D[1, 9] = -q1 * ((l1)^2) * (e23);
  D[2, 10]= -q1 * (f12) * ((l2)^2);
  // k1
  C[ 4, 8 ]= Q1;
  C[ 4, 9 ]= q1;
  C[ 4, 10]= q;
  // l1
  C[ 6, 8 ]= Q;
  C[ 6, 9 ]= q;
  C[ 6, 10]= q1;
  // k2
  C[ 5, 8 ]= q;
  C[ 5, 9 ]= q1;
  C[ 5, 10]= Q1;
  // l2
  C[ 7, 8 ]= q1;
  C[ 7, 9 ]= q;
  C[ 7, 10]= Q;
  // k1
  C[ 1, 4 ]= Q1;
  C[ 2, 4 ]= q1;
  C[ 3, 4 ]= q;
  // l1
  C[ 1, 6 ]= Q;
  C[ 2, 6 ]= q;
  C[ 3, 6 ]= q1;
  // k2
  C[ 1, 5 ]= q;
  C[ 2, 5 ]= q1;
  C[ 3, 5 ]= Q1;
  // l2
  C[ 1, 7 ]= q1;
  C[ 2, 7 ]= q;
  C[ 3, 7 ]= Q;
  ncalgebra(C,D); // the V_q(sl3) is done
  ideal Qideal = k1*l1-1,  k2*l2-1;
  Qideal = twostd(Qideal);
  export Qideal;
  mySetRing("Qsl3", #);
  return(@@@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def B = Qsl3(5);
   setring B;
   Qideal;
   qring Usl3q = Qideal;
   Usl3q;
}

///////////////////////////////////////////////////////////////////////////////