version="$Id: control.lib,v 1.9 2004-08-09 13:50:11 levandov Exp $";
category="Miscellaneous";
info="
LIBRARY:  control.lib Procedures for System and Control Theory 
AUTHORS:  Oleksandr Iena  yena@mathematik.uni-kl.de
@*        Markus Becker   mbecker@mathematik.uni-kl.de

SUPPORT: Forschungsschwerpunkt 'Mathematik und Praxis' (Project of Dr. E. Zerz
and V. Levandovskyy), Uni Kaiserslautern

NOTE: This library provides algebraic analysis tools for System and Control Theory

PROCEDURES:
control(module R);            analysis of controllability-related properties of R,
autonom(module R);            analysis of autonomy-related properties of R (using Ext modules),
autonom2(module R);           analysis of autonomy-related properties of R (using dimension),
LeftKernel(module R);         a left kernel of R,
RightKernel(module R);        a right kernel of R,
LeftInverse(module R)         a left inverse of matrix (module).

AUXILIARY PROCEDURES:
ncdetection(ring r);          computes an ideal, presenting an involution map on non-comm algebra r;
involution(m, map theta); applies the involution, presented by theta to  m of typ poly, vector, ideal, module;
declare(string NameOfRing, string Variables[,string  Parameters, string Ordering]);     defines the ring, optional parametes are a string of parameters and a sting of ordering,
view();                      Well-formatted output of lists, modules and matrixes
";

// NOTE: static things should not be shown for end-user
// static Ext_Our(...)                  Copy of Ext_R from 'homolog.lib' in commutative case;
// static is_zero_Our(module R)         Copy of is_zero from 'OBpoly.lib';
//  static space(int n)           Procedure used inside the procedure 'Print' to have a better formatted output
// static control_output();      Generating the output for the procedure 'control'
// static autonom_output();      Generating the output for the procedure 'autonom' and 'autonom2'

LIB "homolog.lib"; 
LIB "poly.lib";
LIB "primdec.lib";
LIB "ncalg.lib";
//---------------------------------------------------------------
proc declare(string NameOfRing, string Variables, list #)
"USAGE: declare(NameOfRing, Variables,[Parameters, Ordering]);
          NameOfRing:  string with name of ring,
	  Variables:   string with names of variables separated by commas(e.g. "x,y,z"),
	  [Parameters, Ordering]: optional, strings:
	    Parameters: string of parameters in the ring separated by commas(e.g. "a,b,c"),
	    Ordering:   string with name of ordering(by default the ordering "dp,C" is used)
RETURN:  no return value
EXAMPLE:  example declare; shows an example 
"
{
  if(size(#)==0)
  {
    execute("ring "+NameOfRing+"=0,("+Variables+"),dp;");
  }
  else
  {
    if(size(#)==1)
    {
      execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),dp;" );
    }
    else
    { 
      if( (size(#[1])!=0)&&(#[1]!=" ") )
      {
        execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),("+#[2]+");" );
      }
      else
      {
        execute( "ring " + NameOfRing + "=0,("+Variables+"),("+#[2]+");" ); 
      };
    };
  };
  keepring(basering);
}
example
{"EXAMPLE:";echo = 2;
  string v="x,y,z";
  string p="q,p";
  string Ord ="c,lp";
 
  declare("Ring_1",v);
  print(nameof(basering));
  print(basering);
  
  declare("Ring_2",v,p);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_3",v,p,Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_4",v,"",Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_5",v," ",Ord);
  print(basering);
  print(nameof(basering));
};
//
//maybe reasonable to add this in declare
//
//  print("Please enter your representation matrix in the following form: 
//  module R=[1st row],[2nd row],...");
//  print("Type the command: R=transpose(R)");
//  print(" To compute controllability please enter: control(R)");
//  print(" To compute autonomy please enter: autonom(R)");
//
//
//
//-------------------------------------------------------------------------
static proc space(int n)
"USAGE:spase(n); 
         n: integer, number of needed spaces
RETURN:  string consisting of n spaces
NOTE:  the procedure is used in the procedure 'view' to have a better formatted output
"
{
  int i;
  string s="";
  for(i=1;i<=n;i++)
  {
    s=s+" ";
  };
  return(s);
};
//-----------------------------------------------------------------------------
proc view(M)
"USAGE:  view(M);
           M:  any type
RETURN:  no return value
PURPOSE:  procedure for ( well-) formatted output of modules, matrices, lists of modules, matrices;
          shows everything even if entries are long
NOTE:  in case of other types( not 'module', 'matrix', 'list') works just as standard 'print' procedure  
EXAMPLE:  example view; shows an example
"
{
  if ( (typeof(M)=="module")||(typeof(M)=="matrix") )
  {
  int @R=nrows(M);
  int @C=ncols(M);
  int i;
  int j;
  list MaxLength=list();
  int Size=0;
  int max;
  string s;
  
  for(i=1;i<=@C;i++)
  { 
    max=0; 
    
    for(j=1;j<=@R;j++)
    {
      Size=size( string( M[j,i] ) );
      if( Size>max )
      {
        max=Size;
      };
    };
    MaxLength[i] = max;
  };
  
  for(i=1;i<=@R;i++)
  {
    s="";
    for(j=1;j<@C;j++)
    {
      s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) ) +",";
    };
    
    s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) );

    if (i!=@R)
    {
      s=s+",";
    };
    print(s);
  };

  return();    
  };
  
  if(typeof(M)=="list")
  {
    int sz=size(M);
    int i;
    for(i=1;i<=sz;i++)
    {
      view(M[i]);
      print("");
    }; 

    return();
  };
  print(M);
  return();
}
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[1][3] = x,y,z;
  print(M);
  view(M);
};
//--------------------------------------------------------------------------
proc RightKernel(matrix M)
"USAGE:  RightKernel(M);
           M:  matrix
RETURN:  right kernel of matrix M, i.e., the module of all elements v such that Mv=0
NOTE:  in commutative case it is a left  module, in noncommutative (will be implemented later) it is a right module   
EXAMPLE:  example RightKernel; shows an example
"
{ 
  return(syz(M));
}
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[1][3] = x,y,z;
  print(M);
  print( RightKernel(M) );
};
//-------------------------------------------------------------------------
proc LeftKernel(matrix M)
"USAGE:  LeftKernel(M);
           M:  matrix
RETURN:  left kernel of matrix M, i.e., the matrix whose rows are generators of left module
         (elements of this module are to be rows) of all elements v such that vM=0   
EXAMPLE:  example LeftKernel; shows an example
"
{
  return( transpose( syz( transpose(M) ) ) );
}
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[3][1] = x,y,z;
  print(M);
  print( LeftKernel(M) );
};
//------------------------------------------------------------------------
proc LeftInverse(matrix M)
"USAGE:  LeftInverse(M);
           M:  matrix
RETURN:  left inverse of M if exists, i.e., matrix L such that LM == id;
EXAMPLE:  example LeftInverse; shows an example
"
{
  int NCols=ncols(M);
  M=transpose(M);
  matrix I[NCols][NCols];
  I=I+1;
  module Id=I;
  return( transpose( lift( module(M),Id ) )  );
}
example
{"EXAMPLE:";echo =2;
  ring r;
  matrix M[2][1] = 1,x2z;
  print(M);
  print( LeftInverse(M) );  
};
//-----------------------------------------------------------------------
static proc Ext_Our(int i, module R,list #)
// just a copy of 'Ext_R' from "homolog.lib" in commutative case
{
  if ( size(#)==0 )
  { 
    return( Ext_R(i,R) ); 
  }
  else
  {
    return( Ext_R(i,R,#[1]) );
  };
}
//------------------------------------------------------------------------
static proc is_zero_Our(module R)
//just a copy of 'is_zero' from "poly.lib"
{
  return( is_zero(R) ) ;
};
//------------------------------------------------------------------------
static proc control_output(int i, int NVars, module R, module Ext_1) 
"USAGE:  proc control_output(i, NVars, R, Ext_1)
           i:  integer, number of first nonzero Ext or 
	       just number of variables in a base ring + 1 in case that all the Exts are zero
	   NVars:  integer, number of variables in a base ring  
	   R:  module R (cokernel representation)
	   Ext_1:  module, the first Ext(its cokernel representation)      
RETURN:  list with all the contollability properties of the system which is to be returned in 'control' procedure
NOTE:  this procedure is used in 'control' procedure
"
{
  int d=dim( std( Ann( transpose(R) ) ) ) ;;//this is the dimension of the system 
  string DofS= "dimension of the system:";
  string Fn= "number of first nonzero Ext:";
  if(i==1)
  { 
    module RK=RightKernel(R);
    return( 
            list ( Fn,
	           i,
	          "not controllable , image representation for controllable part:",
         	   RK,	    
	          "kernel representation for controllable part:",
		   LeftKernel( RK ),
		  "obstruction to controllability",
		   Ext_1,
		  "annihilator of torsion module(of obstruction to controllability)",
		   Ann(Ext_1),
		   DofS,
		   d
		 ) 
          );
  };
  
  if(i>NVars)
  { module RK =RightKernel(R); 
    return( list(  Fn,
                   -1, 
                  "strongly controllable, image representation:",
		   RK,
		  "left inverse to image representation:",
		   LeftInverse(RK),
		   DofS, 
		   d) 
          );
  };
  
  //
  //now i<=NVars
  //
       
  if( (i==2) )
  {
    return( list( Fn,
                  i, 
                 "controllable, not reflexive, image representation:",
		  RightKernel(R),
                  DofS,
                  d ) 
          ); 
  };
    
  if( (i>=3) )
  {
    return( list ( Fn,
                   i, 
                  "reflexive, not strongly controllable, image representation:",
		   RightKernel(R),
		   DofS,
		   d) 
          );
  };
              
  
};  
//-------------------------------------------------------------------------

proc control(module R)
"USAGE:  control(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning controllability of the system(behavior) represented by the  matrix R
EXAMPLE:  example control; shows an example
"
{
  int i;
  int NVars=nvars(basering); 
  int ExtIsZero;
 
       
  module Ext_1 = std(Ext_Our(1,R));
   
  ExtIsZero=is_zero_Our(Ext_1);
  i=1;
  while( (ExtIsZero) && (i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our( Ext_Our(i,R) );
  };
  
  return( control_output( i, NVars, R, Ext_1 ) );
}
example
{"EXAMPLE:";echo = 2; 
  //-------------------------------
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  view( R );  
  view( control(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  view( Rc );
  view( control(Rc) );
  kill r;
  //----------------------------------
  //reflector antenna
  ring A = (0, K1, K2, Te, Kp, Kc),(Dt, delta), dp;
  module R;
  R = [Dt, -K1, 0, 0, 0, 0, 0, 0, 0],
       [0, Dt+K2/Te, 0, 0, 0, 0, -Kp/Te*delta, -Kc/Te*delta, -Kc/Te*delta],
       [0, 0, Dt, -K1, 0, 0, 0, 0, 0],
       [0, 0, 0, Dt+K2/Te, 0, 0, -Kc/Te*delta, -Kp/Te*delta, -Kc/Te*delta],
       [0, 0, 0, 0, Dt, -K1, 0, 0, 0],
       [0, 0, 0, 0, 0, Dt+K2/Te, -Kc/Te*delta, -Kc/Te*delta, -Kp/Te*delta];
  R=transpose(R);
  view(R);
  view(control(R));
  kill A;
  //----------------------------------
  //Flexible Rod
  ring A = 0,(D1, delta), dp;
  module R;
  R = [D1, -D1*delta, -1],
      [2*D1*delta, -D1-D1*delta^2, 0];
  R=transpose(R);
  view(R);
  view(control(R));
  kill A;
  //-------------------------------------
  //TwoPendula
  ring r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module R;
  R =  [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
       [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
       [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];
  R=transpose(R);
  view(R);
  view(control(R));
  kill r;
  //----------------------------------------
  //Wind Tunnel
  ring A = (0,a, omega, zeta, k),(D1, delta),dp;
  module R;
  R = [D1+a, -k*a*delta, 0, 0],
      [0, D1, -1, 0],
      [0, omega^2, D1+2*zeta*omega, -omega^2];
  R=transpose(R);
  view(R);
  view(control(R));
  //-------------------------------------------

};
//------------------------------------------------------------------------
static proc autonom_output( int i, int NVars ) 
"USAGE:  proc autonom_output(i, NVars)
           i:  integer, number of first nonzero Ext or 
	       just number of variables in a base ring + 1 in case that all the Exts are zero
	   NVars:  integer, number of variables in a base ring  
RETURN:  list with all the autonomy properties of the system which is to be returned in 'autonom' procedure
NOTE:  this procedure is used in 'autonom' procedure
"
{
  int d=NVars-i;//that is the dimension of the system
  string DofS="dimension of the system:";
  string Fn = "number of first nonzero Ext:";
  if(i==0)
  { 
    return( list(  Fn,
                   i,
                  "not autonomous",
		   DofS,
		   d ) 
	  );
  };
  
  if( i>NVars )
  {  
    return( list( Fn,
                  -1,
                  "trivial",
		  DofS,
		  d ) 
          );
  };
  
  //
  //now i<=NVars
  //
    
     
  if( i==1 )
  //in case that NVars==1 there is no sence to consider the notion
  //of strongly autonomous behavior, because it does not imply 
  //that system is overdetermined in this case
  {
    return( list ( Fn,
                   i, 
                  "autonomous, not overdetermined",
		   DofS,
		   d ) 
          ); 
  };
    
  if( i==NVars )
  {  
    return( list(  Fn,
                   i,
                  "strongly autonomous,in particular overdetermined",
		   DofS,
		   d) 
	  );
  };
  
  if( i<NVars )
  {
    return( list ( Fn,
                   i,
                  "overdetermined, not strongly autonomous",
		   DofS, 
		   d) 
          );
  };
    
};  
//--------------------------------------------------------------------------
proc autonom2(module R)
"USAGE:  autonom2(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning autonomy of the system(behavior) represented by the  matrix R
NOTE:  this procedure is an analogue to 'autonom' using dimension calculations
EXAMPLE:  example autonom2; shows an example
"
{ 
  int d;
  int NVars = nvars(basering);
  R=transpose(R);
  d=dim( std( Ann(R) ) );
  return( autonom_output(NVars-d,NVars) );
}
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  view( R );  
  view( autonom2(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  view( Rc );
  view( autonom2(Rc) );
  kill r;
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  view( R );
  view( autonom2(R) );
  kill r;
  //-----------------------------------
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  view( R );
  view( autonom2(R) );
  kill r;
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  view(R);
  view(autonom2(R));	   
};  
//---------------------------------------------------------------------------

proc autonom(module R)
"USAGE:  autonom(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning autonomy of the system(behavior) represented by the  matrix R
EXAMPLE:  example autonom; shows an example
"
//"Computes the autonomy of a behaviour represented by the matrix R"
{
  int NVars=nvars(basering);
  int ExtIsZero;    
  R=transpose(R); 
  ExtIsZero=is_zero_Our(Ext_Our(0,R)); 
  int i=0;
  while( (ExtIsZero)&&(i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our(Ext_Our(i,R));
  };

  return(autonom_output(i,NVars));     
}
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  view( R );  
  view( autonom(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  view( Rc );
  view( autonom(Rc) );
  kill r;
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  view( R );
  view( autonom(R) );
  kill r;
 //-----------------------------------
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  view( R );
  view( autonom(R) );
  kill r;
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  view(R);
  view(autonom(R));	   
};  
//---------------------------------------------------------------------------
static proc invo_poly(poly m, map theta)
//applies the involution map theta to m, where m=polynomial
{
  int i,j;
  intvec v;
  poly p,z;
  poly n = 0;
  i = 1;
  while(m[i]!=0)
  {
    v = leadexp(m[i]);
    z =1;
    for(j=nvars(basering); j>=1; j--)
    {
      if (v[j]!=0)
      { 
        p = var(j); 
        p = theta(p);
        z = z*(p^v[j]);
      }
    }    
    n = n + (leadcoef(m[i])*z);
    i++;  
  }
  return(n);
}

proc involution(m, map theta)
//applies the involution map theta to m, where m=vector, polynomial,
//module,ideal
{
  int i,j;
  intvec v;
  poly p,z;
  if (typeof(m)=="poly")
  {
    return (invo_poly(m,theta));  
  }
  if ( typeof(m)=="ideal" )
  {
    ideal n;
    for (i=1; i<=size(m); i++)
    {
      n[i] = invo_poly(m[i],theta);
    } 
    return(n);
  }
  if (typeof(m)=="vector")
  {
    for(i=1;i<=size(m);i++)
    {
      m[i] = invo_poly(m[i],theta);
    }
    return (m);  
  }
  
  if ( (typeof(m)=="matrix") || (typeof(m)=="module"))
  {  
//    m=transpose(m);
    matrix n = matrix(m);
    int @R=nrows(n);
    int @C=ncols(n);
    for(i=1; i<=@R; i++)
    {
      for(j=1; j<=@C; j++)
      {
        n[i,j] = invo_poly( m[i,j], theta);
      }
    }
   }
  if (typeof(m)=="module")
  {
    return (module(n));
  }
  return(n);
}
example
{ 
  "EXAMPLE:";echo = 2;
  ring r = 0,(x,d),dp;
  ncalgebra(1,1); // Weyl-Algebra
  map F = r,x,-d;
  poly f =  x*d^2+d;
  poly If = involution(f,F);
  f-If;
  poly g = x^2*d+2*x*d+3*x+7*d;
  poly tg = -d*x^2-2*d*x+3*x-7*d;
  poly Ig = involution(g,F);
  tg-Ig;
  ideal I = f,g;
  ideal II = involution(I,F);
  II;
  I - involution(II,F);
  module M  = [f,g,0],[g,0,x^2*d];
  module IM = involution(M,F);
  print(IM);
  print(M - involution(IM,F));  
}

proc ncdetection( r)
//in dieser proc. wird eine matrix erzeugt, die in der i-ten zeile die indices 
//der differential-,shift- oder advance-operatoren enthaelt mit denen die i-te
//variable nicht kommutiert. 
{
  int i,j,k,LExp;
  int NVars=nvars(r);
  matrix rel = NCRelations(r)[2];
  intmat M[NVars][3];
  int NRows = nrows(rel);
  intvec v,w; 
  poly d,d_lead;
  ideal I;
  map theta;
 
  for( j=NRows;j>=2;j-- )
  {
   if( rel[j] == w )       //the whole column is zero
    {
      j--;
      continue;
    }
    
    for( i=1;i<j;i++ )         
    {
      if( rel[i,j]==1 )        //relation of type var(j)*var(i) = var(i)*var(j) +1
      {
         M[i,1]=j;
      }
      if( rel[i,j] == -1 )    //relation of type var(i)*var(j) = var(j)*var(i) -1
      {
        M[j,1]=i;
      }
      d = rel[i,j];
      d_lead = lead(d);
      v=leadexp(d_lead); //in the next lines we check wether we have a  relation of differential or shift type
      LExp=0;
      for( k=1;k<=NVars;k++)
      {
        LExp = LExp + v[k];
      }
      if( (d-d_lead != 0) || (LExp > 1) )
      {
        return( "wrong input" );
      }
      if( v[j] == 1)                   //relation of type var(j)*var(i) = var(i)*var(j) -lambda*var(j)
      {
        if (leadcoef(d) < 0)
        {
          M[i,2] = j;
        }
        else
        {
          M[i,3] = j;
        }
      }
      if( v[i]==1 )                    //relation of type var(j)*var(i) = var(i)*var(j) -lambda*var(i)
      {
        if (leadcoef(d) > 0)
        {
          M[j,2] = i;
        }
        else
        {
          M[j,3] = i;
        }
      }
    }
  }
  //ab hier wird die map ausgerechnet
  for(i=1;i<=NVars;i++)
  {
    I=I+var(i);
  }

  for(i=1;i<=NVars;i++)
  {
    if( M[i,1..3]==(0,0,0) )
    {
      i++;
      continue;
    }
    if( M[i,1]!=0 )
    {
      if( (M[i,2]!=0) && (M[i,3]!=0) )
      {
        I[M[i,1]] = -var(M[i,1]);
        I[M[i,2]] = var(M[i,3]);
        I[M[i,3]] = var(M[i,2]);
      }
      if( (M[i,2]==0) && (M[i,3]==0) )
      {
        I[M[i,1]] = -var(M[i,1]);
      }                  
      if( ( (M[i,2]!=0) && (M[i,3]==0) )|| ( (M[i,2]!=0) && (M[i,3]==0) ) 
)
      {
        I[i] = -var(i);
      }
    }
    else
    {
      if( (M[i,2]!=0) && (M[i,3]!=0) )
      {
        I[i] = -var(i);
        I[M[i,2]] = var(M[i,3]);
        I[M[i,3]] = var(M[i,2]);
      }
      else
      {
        I[i] = -var(i);
      } 
    }
  }
  return(I);

}
example
{ 
  "EXAMPLE:"; echo = 2;
  ring r=0,(x,y,z,D(1..3)),dp;
  matrix D[6][6];
  D[1,4]=1;
  D[2,5]=1;
  D[3,6]=1;
  ncalgebra(1,D);
  ncdetection(r);
  kill r;
  //----------------------------------------
  ring r=0,(x,S),dp;
  ncalgebra(1,-S);
  ncdetection(r);
  kill r;
  //----------------------------------------
  ring r=0,(x,D(1),S),dp;
  matrix D[3][3];
  D[1,2]=1;
  D[1,3]=-S;
  ncalgebra(1,D);
  ncdetection(r);
}