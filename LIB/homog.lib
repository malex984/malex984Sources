// $Id: homog.lib,v 1.2 1997-04-28 19:27:18 obachman Exp $
//(BM 11/95)
///////////////////////////////////////////////////////////////////////////////
LIBRARY:  homog.lib           homological algebra porcedures
ext(<int>,<ideal>);             Ext^k(R/I,R),    I - ideal in basering R
Ext(<int>,<mod>,<mod>);         Ext^k(M,N),      M,N modules
Hom(<mod>,<mod>);               Hom(M,N),        M,N modules
cup1(<mod>);                    cup: Ext^1(M,M) x Ext^1() --> Ext^2()
kohom(<mat>,<int>);             Hom(R^k,mat)
kontrahom(<mat>,<int>);         Hom(mat,R^k)

LIB "matrix.lib";
//=============================================================================

proc ext (int k, ideal I, list #)

COMPUTES:  Ext^k(P/I,P);   I ideal in the basering P
USAGE:     ext(<int>,<id>[,<any>]);
SHOWS:     degree of Ext^k
RETURN:    Ext (as quotient of a free module)
           or  (in case of a third parameter)
           a list of two modules
           [1] = module Ext
           [2] = SB of  Ext
{
//------------ initialisation -------------------------------------------------
  module m1,m2,ret,ret0;

//-----------------  compute resulution of P/I --------------------------------
  mres(I,k+1,resI);
//-----------------  apply Hom(_,P) at k-th place -----------------------------
  m2 = transpose(resI(k+1));
  m1 = transpose(resI(k));
//-----------------  ker(m2)/im(m1) -------------------------------------------
  m2 = simplify(m2,10);
  if (m2[1]==0) { ret = m1; }
  else          { ret = modulo(syz(m2),m1); }
  ret0 = std(ret);
  "// degree of Ext^"+string(k)+"(P/I,P):";degree(ret0);
  if (size(#)>0)
  { return(ret,ret0); }
  return(ret);
}
example
{
 "EXAMPLE:";     echo=2;
  ring r=0,(x,y,z),(c,dp);
  ideal  I = x2y,y2z,z3x;
  module E = ext(1,I);
  E = ext(2,I);
  E = ext(3,I);
  kbase(std(E));
  E = ext(4,I);
}

///////////////////////////////////////////////////////////////////////////////
proc Ext (int k, module M, module N, list #)

COMPUTES  Ext^k(M,N);  M,N modules (quotients of a free one)
USAGE     Ext(<int>,<mod>,<mod>);
SHOWS     degree(Ext)
RETURN    Ext (as quotient of a free one)
          or  (in case of a 4th parameter)
          a list of modules:
          [1] = Ext
          [2] = SB of Ext
{
//---------- initialisation ---------------------------------------------------
  module A,B,C,M1,M2,ker,imag,extMN,extMN0;
  ideal  test1,test2;
//----------  resolution of M  and N ------------------------------------------
 if (k>0)
 {
   mres(M,k+1,resM);
   M1 = resM(k);
   M2 = resM(k+1);
   test1 = simplify(ideal(M1),10);
   test2 = simplify(ideal(N),10);
   if ((test1[1]==0) or (test2[1]==0))
   { "//Ext(M,N)=0";return(extMN);
   }
   else
   {
     test1 = simplify(ideal(M2),10);
     if (test1[1]==0)                                 //Ker(Hom(m2,N))
     { ker = freemodule(ncols(M1)*nrows(N));
     }
     else
     {
       A = kontrahom(M2,nrows(N));
       B = kohom(N,ncols(M2));
       C = intersect(A,B);
       C = reduce(C,std(ideal(0)));C=simplify(C,10);
       ker = lift(A,C)+syz(A);
     }
     imag = kohom(N,ncols(M1));
     A    = kontrahom(M1,nrows(N));
     imag = imag+A;                              //im(Hom(m1,M))
     extMN = modulo(ker,imag);
     extMN0= std(extMN);
     "// degree of Ext^"+string(k)+"(M,N):";degree(extMN0);
   }
 }
 else
 {
   extMN,extMN0 = Hom(M,N,1);
 }
 if (size(#)>0)
 { return(extMN,extMN0); }
 return(extMN );
}
example
{
 "EXAMPLE:";     echo=2;
 ring r=0,(x,y),(c,dp);
 ideal i=x2-y3;
 qring qr=std(i);
 module M=[-x,y],[-y2,x];
 module EXT1=Ext(1,M,M);
}
////////////////////////////////////////////////////////////////////////////////
proc Hom (module M, module N, list #)


COMPUTES   Hom(M,N);   M,N modules  (quotients of a free one)
USAGE      Hom(M,N);
SHOWS      degree(Hom)
RETURN     Hom(M,N)   (as quotient of a free one)
           or  (in case of a 3rd parameter)
          a list of modules:
          [1] = Hom
          [2] = SB of Hom
{
//---------- initialisation ---------------------------------------------------
  module A,B,C,ker,imag,homMN,homMN0;
  ideal  tes;
  tes = simplify(ideal(M),10);
  if (tes[1]==0)
  {
    "// Hom(ring,N)=N";
    if (size(#)>0) { return(N,std(N)); }
    return(N);
  }
  tes = simplify(ideal(N),10);
  if (tes[1]==0)
  {
    "// Hom(M,ring)=M^*";
    homMN = transpose(M);
    if (size(#)>0) { return(homMN,std(homMN));}
    return(homMN);
  }
  B = kohom(N,ncols(M));
  A = kontrahom(M,nrows(N));
  C = intersect(A,B);
  C = reduce(C,std(ideal(0)));C=simplify(C,10);
  ker   = lift(A,C)+syz(A);                              //ker(Hom(m,N))
  imag  = kohom(N,ncols(M));                             //im(Hom(M,n))
  homMN = modulo(ker,imag);
  homMN0= std(homMN);
  "// degree of Hom(M,N):";degree(homMN0);
  if (size(#)>0) { return(homMN,homMN0); }
  return(homMN);
}
example
{
  "EXAMPLE:";  echo = 2;
  ring r=0,(x,y),(c,dp);
  ideal i=x2-y3;
  qring q=std(i);
  module M=[-x,y],[-y2,x];
  module hom=Hom(M,M);
  print(hom);
//-----------------  2nd example ----------------------------------------------
  ring s=3,(x,y,z),(c,dp);
  ideal i=x2+y5+z4;i=jacob(i);
  qring rq=std(i);
  matrix M[2][2]=xy,x3,5y,z2,x2;
  matrix N[4][4]=x,y,z,x2,xyx2y,y3,xz2,x2z,z3;
  print(M);print(N);
  print(Hom(M,N));
            "!!!!!!!!!!!!!!!!!!!!!Abweichung von alter lib!?";
}
////////////////////////////////////////////////////////////////////////////////
proc qmod (module M, module N)

USAGE:   qmod(<module_M>,<module_N>);
         N a submodule of M, a submodule of e free one
COMPUTE: presentation S of M/N, i.e. M/N<<--F<--[S],
         F free of rank = size(M),
RETURNS: module  S
{
  return(lift(M,N)+syz(M));
}
//////////////////////////////////////////////////////////////////////////////
proc kontrahom (matrix M, int j)

USAGE:      kontrahom(<matrix>,<int>;
COMPUTES:   Hom(M,P^j)
i.e.        Let M be a matrix defining a map: F1 --> F2
            it computes the matrix of the map: Hom(F2,F)-->Hom(F1,F)
            F free of rank j
RETURN:     matrix: Hom(_,F)
{
  return(transpose(outer(diag(1,j),M)));
}
example
{
  "EXAMPLE:";  echo=2;
  ring r;
  matrix n[2][3]=x,y,5,z,77,33;
  print(kontrahom(n,3));
}
///////////////////////////////////////////////////////////////////////////////
proc kohom (matrix M, int j)

USAGE:      kohom(<matrix>,<int>)
COMPUTES:   Hom(P^j,M)
i.e.        Let M be a matrix defining a map:  F1 --> F2
            it computes the matrix of the map: Hom(F,F1)-->Hom(F,F2),
            F free ot rank j
RETURN:     matrix: Hom(F,_)
{
    return(outer(M,diag(1,j)));
}
example
{
  "EXAMPLE:";   echo=2;
  ring r;
  matrix n[2][3]=x,y,5,z,77,33;
  print(kohom(n,3));
}
///////////////////////////////////////////////////////////////////////////////
proc cup1 (module M)

USAGE:    cup1(<mod>);
COMPUTES: cup-product
                         Ext^1(M,M) x Ext^1(M,M) ---> Ext^2(M,M)
ASSUME:   all Ext's  are of finite dimension
RETURNS:  <matrix> of the associated linear map
{
//---------- INITIALISTION ----------------------------------------------------
   int    i,j,f0,f1,f2,f3,e1,e2;
   module M1,M2,A,B,C,ker,ima,ext1,ext2,ext10,ext20;
   matrix cup[1][0];
   matrix kb1,lift1,kb2;
   ideal  tes1,tes2,null;
//-----------------------------------------------------------------------------
//take a resolution of M<--F(0)<--- ...  <---F(3)
//apply Hom(-,M) and compute the Ext's
//-----------------------------------------------------------------------------
   mres(M,3,resM);
   M1 = resM(2);
   M2 = resM(3);
   f0 = nrows(M);
   f1 = ncols(M);
   f2 = ncols(M1);
   f3 = ncols(M2);
   tes1 = simplify(ideal(M),10);tes2=simplify(ideal(M1),10);
   if ((tes1[1]==0) or (tes2[1]==0))
   {
      dbpri(2,"// Ext == 0 , hence 'cup' is zero-map");
      return(@cup);
   }
//------ compute Ext^1 --------------------------------------------------------
   B   = kohom(M,f2);
   A   = kontrahom(M1,f0);
   C   = intersect(A,B);
   C   = reduce(C,std(null));C = simplify(C,10);
   ker = lift(A,C)+syz(A);
   ima = kohom(M,f1);
   ima = ima + kontrahom(M,f0);
   ext1  = modulo(ker,ima);
            degree(std(ker));degree(std(ima));pause;
   ext10 = std(ext1);
   e1   = vdim(ext10);
   dbpri(2,"// vdim (Ext^1) = "+string(e1));
   if (e1 < 0)
   {
     "// Ext^1 not of finite dimension";
     return(cup);
   }
   kb1 = kbase(ext10);
   kb1 = matrix(ker)*matrix(kb1,ncols(ker),e1);
   dbpri(2,"// kbase of Ext^1:",kb1);
//------ compute the liftings of Ext^1 ----------------------------------------
   C = matrix(A)*kb1;
   if (B[1]!=0) { lift1 =lift(B,C); }
   dbpri(2,"// lift kbase of Ext^1:",lift1);pause;
//------ compute Ext^2  -------------------------------------------------------
   B   = kohom(M,f3);
   A   = kontrahom(M2,f0);
   C   = intersect(A,B);
   C   = reduce(C,std(null));C = simplify(C,10);
   ker = lift(A,C)+syz(A);
   ima = kohom(M,f2);
   ima = ima + kontrahom(M1,f0);
   ext2  = modulo(ker,ima);
   ext20 = std(ext2);
   e2    = vdim(ext20);
   if (e2<0)
   {
     "// Ext^2 not of finite dimension";
     return(cup);
   }
   kb2 = kbase(ext20);
   kb2 = matrix(ker)*matrix(kb2,ncols(ker),e2);
   dbpri(2,"// kbase of Ext^2:",kb2);
//-------  compute: cup-products of base-elements -----------------------------
   for (i=1;i<=e1;i=i++)
   {
     for (j=1;j<=e1;j=j++)
     {
       A = matrix(ideal(lift1[j]),f1,f2);
       B = matrix(ideal(kb1[i]),f0,f1);
       C = B*A;                       "%";pri(A,B,C);pause;
       A = matrix(ideal(C),f0*f2,1);
       cup= concat(cup,A);
     }
   }
   dbpri(2,"// matrix of cup-products (in Ext^2)",cup);
//------- comptute: presentation of base-elements -----------------------------
            "##";print(ker);"$$$$##";print(cup);pause;
   cup = lift(ker,cup);
   cup = liftkb(cup,ext20);
   dbpri(2,"// present cups as linear combination of kbase of Ext^2",cup);
   return(cup);
}
example
{
  "EXAMPLE";   echo=2;  printlevel=2;
  ring  r = 0,(x,y),(dp,C);
  ideal i = x2-y3;
  qring q = std(i);
  module M= [-x,y],[-y2,x];
  print(M);
  print(cup1(M));
  pause;
  ring rr = 32003,(x,y,z),(dp,C);
  ideal I = x4+y3+z2;
  qring o = std(I);
  module M= [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
  print(M);
  print(cup1(M));
}
