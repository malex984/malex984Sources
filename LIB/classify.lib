// $Id: classify.lib,v 1.7 1997-08-10 08:49:30 krueger Exp $
//=============================================================================
//
// Please send bugs and comments to krueger@mathematik.uni-kl.de
//
//=============================================================================

LIBRARY:  Classify.lib

 Classify(f);
// required libraries

LIB "lib_Setring";
LIB "lib_ReOrder";
LIB "lib_RandomPoly";
LIB "Morse.lib";
LIB "tools.lib";
LIB "Kclass.lib";
LIB "Ausgaben.lib";
LIB "HKclass.lib";
LIB "NFlist.lib";
LIB "Hilbert.lib";

//=========================================================================
//=========================================================================
proc Classify_lib
{
"
  Classify(poly f);    determine the typ of the singularity f
";
}

//=============================================================================
// TopLevel Funktion of the Arnold-Classifier.
//
proc Classify (poly @f_in)
USAGE:   Classify(f);  f=poly
COMPUTE: Normalform and singularity type of f
RETURN:  Normalform of f
EXAMPLE: example Classify; shows an example
REMARK:  This version of Classify is only alpha.
         Please send bugs and comments to:
         "Kai Krueger" <krueger@mathematik.uni-kl.de>
NOTE:    The procedure init_debug(n); is usefull as trace-mode.
	 n may range from 0 to 10, higher values of n give more informations.
{
//         or set the shell-variable SG_DEBUG to the debugging level.
  if(system("version")<922) {
    "Sorry. You need to have at least Singular version 0.9.2.c"
    return;
  }

  def ring_top=basering;
  // Get characteristics of ring set it as default.
  if(defined(CharOfRing) == 1) { kill CharOfRing; }
  int CharOfRing = char(basering);
  export CharOfRing;

  if(checkring()) { return(@f_in); }
  int @show_nf = 1;    // return normal form if set to '1'

  int @n = nvars(basering);

  // Save the name of initial ring
  int @i;

  // if trace/debug mode not set, do it!
  init_debug();

  // define new ring
  if( defined(Rtop) == 1) { kill Rtop; }
  ring Rtop=char(basering),(x(1..@n)),(c,ds);
  export Rtop;

  map @Conv=ring_top,maxideal(1);
  setring ring_top;

  if(defined(ShowPoly) == 1) { kill ShowPoly; }
  map ShowPoly=Rtop,maxideal(1);
  export ShowPoly;
  setring Rtop;
  init();

  string RingDisplay = "ring_top";
  export RingDisplay;

  string @s1;
  string @s2;
  string @s3;
  string @s4;
  @s1,@s2=Klassifiziere(@Conv(@f_in));
  // @s1: f nach saemtlichen Koordinatentransformationen
  // @s2: Typ des Polynoms f z.b: E[18]
  @s4 = "poly @f_out="+@s1+";";
//"Corang:"+ string(CoRang);
  debug_log(10, "S1=", @s1);
  debug_log(10, "S2=", @s2);

  if( @s2[1,2]=="f " || @s2[1,4]=="The " || @s2=="Fehler!" || @s2=="A[0]") { 
    if( @s2 != "Fehler!") { @s2; }
    if(@s1=="1" || @s2[1,4]=="The " || @s2=="Fehler!" ) { 
      setring ring_top;
      return(@f_in);
    }
    setring Rtop;
    execute @s4;
    map @ConvUp=Rtop,maxideal(1);
  }
  else {
    setring RingB;
    execute @s4;
    setring Rtop;
    map @ConvUp=RingB,maxideal(1);
  }
  if(@show_nf==1) {
    poly @f_nf = NormalForm(@s2);
    for(@i=4;@i<=@n;@i=@i+1) {
      @f_nf = @f_nf + x(@i)^2;
    }
    if(DeBug>1) { "Normal form NF(f)=", @f_nf; }
  }
  poly @f_out = @ConvUp(@f_out);
//listvar();
//"------------------------------";
//"Corang:"+ string(CoRang);
//"Classify() Controlpoint Test----";
//listvar();
//"------------------------------";
  for(@i=CoRang+1;@i<=@n;@i=@i+1) {
    @f_out = @f_out + x(@i)^2;
  }
//"Classify() Controlpoint Test----";
  setring ring_top;
  map @ConvBack=Rtop,maxideal(1);
//"Classify() Controlpoint Test----";

  if(@show_nf == 1) {
    return(@ConvBack(@f_nf));
  }
  else { return(@ConvBack(@f_out)); }
}
example
{"EXAMPLE"; echo=2;
   ring r=0,(x,y,z),ds;
   init_debug(2);
   poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
   poly g=Classify(f);
}
// E n d   O f   F i l e
