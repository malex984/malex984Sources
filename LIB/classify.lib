// $Id: classify.lib,v 1.5 1997-01-24 10:23:07 krueger Exp $
//=============================================================================
//
// Please send bugs and comments to krueger@mathematik.uni-kl.de
//
//=============================================================================
// required libraries
//LIB "lib0";
//LIB "lib1";
LIB "lib_Setring";
LIB "lib_ReOrder";
LIB "lib_RandomPoly";
LIB "Morse.lib";
LIB "tools.lib";
LIB "Kclass.lib";
LIB "Ausgaben.lib";
LIB "HKclass.lib";
LIB "NFlist.lib";
LIB "Hilbert.lib";

//=========================================================================
proc Classify_lib
{
"
  Classify(poly f);    determine the typ of the singularity f
";
}

//=============================================================================
// TopLevel Funktion of the Arnold-Classifier.
//
proc Classify
{
  if( size(#) != 1 ) {
//=============================================================================
    " USAGE:   Classify(<poly>)";
    " RETURN:  Normal-Form of <poly>";
    " NOTE:    Tells the typ of f";
    " EXAMPLE: ring r; ";
    "          int DeBug=1 / 3 / 6 / 11; ";
    "          poly g=Classify(f); ";
    "";
    " REMARK:  This version of Classify is only pre-alpha.";
    "          Please send bugs and comments to: ";
    "          \"Kai Krueger\" <krueger@mathematik.uni-kl.de>";
    "";
    "          int DeBug=1; is usefull as trace-mode. For more informations";
    "          increace the value of \'DeBug\'";
//=============================================================================
    return();
  }
  if(system("version")<922) {
    "Sorry. You need to have at least Singular version 0.9.2.c"
    return;
  }
  if( typeof(#[1]) != "poly") {
    "Classify: argv(1) must be poly";
    return(#[1]);
  }
  // Get characteristics of ring set it as default.
  if(defined(CharOfRing) == 1) { kill CharOfRing; }
  int CharOfRing = char(basering);
  export CharOfRing;

  if(checkring()) { return(#[1]); }
  int @show_nf = 1;    // return normal form if set to '1'

  poly @f_in = #[1];
  int @n = nvars(basering);

  // Save the name of initial ring
  string @RingInput = "setring " + nameof(basering) + ";";
  string @tmp = "map @Conv=" + nameof(basering) + ",";
  int @i;

  // if trace/debug mode not set, do it!
  if( defined(DeBug) == 0) { 
    string s=system("getenv", "SG_DEBUG");
    if( s != "" ) {
      s="int DeBug="+s;
      execute s;
    } 
    else { int DeBug = 0; }
  }
  export DeBug;

  // define new ring
  if( defined(Rtop) == 1) { kill Rtop; }
  execute Setring(@n, "Rtop");
  export Rtop;

  @tmp = @tmp + string(maxideal(1)) + ";";
  execute @tmp;

  execute @RingInput;

  if(defined(ShowPoly) == 1) { kill ShowPoly; }
  map ShowPoly=Rtop,maxideal(1);
  export ShowPoly;

  setring Rtop;
  init();

  string RingDisplay = @RingInput;
  export RingDisplay;

  string @s1;
  string @s2;
  string @s3;
  string @s4;
//listvar();
//basering;
  @s1,@s2=Klassifiziere(@Conv(@f_in));
  // @s1: f nach saemtlichen Koordinatentransformationen
  // @s2: Typ des Polynoms f z.b: E[18]
  @s4 = "poly @f_out="+@s1+";";
//"Corang:"+ string(CoRang);

  if( @s2[1,2]=="f " || @s2[1,4]=="The " || @s2=="Fehler!" || @s2=="A[0]") { 
    if( @s2 != "Fehler!") { @s2; }
    if(@s1=="1" || @s2[1,4]=="The " || @s2=="Fehler!" ) { 
      execute @RingInput;
      return(@f_in);
    }
    setring Rtop;
    execute @s4;
    map @ConvUp=Rtop,maxideal(1);
  }
  else {
    setring RingB;
    execute @s4;
    setring Rtop;
    map @ConvUp=RingB,maxideal(1);
  }
//"Corang:"+ string(CoRang);

  if(@show_nf==1) {
    poly @f_nf = NormalForm(@s2);
    for(@i=4;@i<=@n;@i=@i+1) {
      @f_nf = @f_nf + x(@i)^2;
    }
    if(DeBug>1) { "Normal form NF(f)=", @f_nf; }
  }
//"Corang:"+ string(CoRang);
//listvar();
//"------------------------------";
//"Classify() Controlpoint Test----";
  poly @f_out = @ConvUp(@f_out);
//listvar();
//"------------------------------";
//"Corang:"+ string(CoRang);
//"Classify() Controlpoint Test----";
//listvar();
//"------------------------------";
  for(@i=CoRang+1;@i<=@n;@i=@i+1) {
    @f_out = @f_out + x(@i)^2;
  }
//"Classify() Controlpoint Test----";
  execute @RingInput;
  map @ConvBack=Rtop,maxideal(1);
//"Classify() Controlpoint Test----";

  if(@show_nf == 1) {
    return(@ConvBack(@f_nf));
  }
  else { return(@ConvBack(@f_out)); }
}
// E n d   O f   F i l e
