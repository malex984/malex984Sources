//=============================================================================
// $Id: classify.lib,v 1.4 1995-02-09 13:52:14 krueger Exp $
//
// Please send bugs and comments to krueger@mathematik.uni-kl.de
//
//=============================================================================
LIB "lib0";
LIB "lib1";
LIB "lib_Setring";
LIB "lib_ReOrder";
LIB "lib_RandomPoly";
LIB "lib_Morse";
LIB "lib_tools";
LIB "lib_Kclass";
LIB "lib_Ausgaben";
LIB "lib_WorkOn";
LIB "lib_HKclass";

//=============================================================================
//
//
proc ShowLibs
{ 
  string @Required = LIB;
  int @len = size(@Required);
  int @i;
  int @k;
  int @j;
  string @s;
  string @s1;

  for(@i=1;@i<@len;@i=@i+@k) {
    @s = @Required[@i..@len];
    @k = find(@s, ",");
    if(@k>0) { 
      @s = @Required[@i,@k-1]; 
    }
    else {
      @k = size(@s);
    }
    @s1 = "@j = defined(SLib_"+@s+");";
    execute @s1;
    if( @j != 0) {
      @s1 = "SLib_"+@s+";";
      execute @s1;
    }
  }
}

//=============================================================================
// TopLevel Funktion of the Arnold-Classifier.
//
proc Classify
{
  if( #ARGS != 1 ) {
//=============================================================================
    " USAGE:   Classify(<poly>)";
    " RETURN:  Normal-Form of <poly>";
    " NOTE:    Tells the typ of f";
    " EXAMPLE: ring r; ";
    "          int DeBug=1 / 3 / 6 / 11; ";
    "          poly g=Classify(f); ";
    "";
    " REMARK:  This version of Classify is only pre-alpha.";
    "          Please reports bugs and comments to: ";
    "          \"Kai Krueger\" <krueger@mathematik.uni-kl.de>";
    "";
    "          int DeBug=1; is usefull as trace-mode. For more informations";
    "          increace the value of \'DeBug\'";
//=============================================================================
    return();
  }
  if( typeof(#1) != "poly") {
    "Classify: argv(1) must be poly";
    return(#1);
  }
  int @show_nf = 1;    // return Normal-form if set to '1'

  poly @f_in = #1;
  int @n = nvars(basering);

  // Save the name of initial ring
  string @RingInput = "setring " + nameof(basering) + ";";
  string @tmp = "map @Conv=" + nameof(basering) + ",";
  int @i;

  // if trace/debug mode not set, do it!
  if( defined(DeBug) == 0) { int DeBug = 0; }
  if(system("version")>=91) { global DeBug; }

  // define new ring
  if( defined(Rtop) == 1) { kill Rtop; }
  execute Setring(@n, "Rtop");
  @tmp = @tmp + string(maxideal(1)) + ";";
  execute @tmp;
  if(system("version")>=91) { global Rtop; }

  execute @RingInput;
  map ShowPoly=Rtop,maxideal(1);
  if(system("version")>=91) { global ShowPoly; }
  setring Rtop;
  init();
  string RingDisplay = @RingInput;
  if(system("version")>=91) { global RingDisplay; }

  string @s1;
  string @s2;
  string @s3;
  string @s4;
  @s1,@s2=Klassifiziere(@Conv(@f_in));
  @s4 = "poly @f_out="+@s1+";";

  setring RingB;
  execute @s4;
  setring Rtop;

  poly @f_nf = NormalForm(@s2);
  for(@i=5;@i<=@n;@i=@i+1) {
    @f_nf = @f_nf + x(@i)^2;
  }
  if(DeBug>1) { "Normal form NF(f)=", @f_nf; }

  map @ConvUp=RingB,maxideal(1);
  poly @f_out = @ConvUp(@f_out);
  for(@i=CoRang+1;@i<=@n;@i=@i+1) {
    @f_out = @f_out + x(@i)^2;
  }
  execute @RingInput;
  map @ConvBack=Rtop,maxideal(1);

  if(@show_nf == 1) {
    return(@ConvBack(@f_nf));
  }
  else { return(@ConvBack(@f_out)); }
}
// E n d   O f   F i l e