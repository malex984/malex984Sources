///////////////////////////////////////////////////////////////////////////////
version="$Id: ncalg.lib,v 1.15 2005-08-12 16:47:08 levandov Exp $";
category="Noncommutative";
info="
LIBRARY:  ncalg.lib      Definitions of important GR-algebras
AUTHORS:  Viktor Levandovskyy,     levandov@mathematik.uni-kl.de,
@*          Oleksandr Motsak,        motsak@mathematik.uni-kl.de.

CONVENTIONS: This library provides pre-defined important noncommutative algebras. 
@* For universal enveloping algebras of finite dimensional Lie algebras sl_n, gl_n and g_2 there are functions @code{makeUsl}, @code{makeUgl} and @code{makeUg2}.
@* There are quantized enveloping algebras U_q(sl_2) and U_q(sl_3) (via functions @code{makeQsl2}, @code{makeQsl3}) 
@* and non-standard quantum deformation of so_3, accessible via @code{makeQso3} function.

PROCEDURES:
makeUsl(n[,p]);   create U(sl_n) in char p>=0
makeUsl2([p]);    create U(sl_2) in the variables (e,f,h) in char p>=0
makeUg2([p]);     create U(g_2) in the variables (x(i),y(i),Ha,Hb) in char p>=0
makeUgl(n,[p]);   create U(gl_n) in the variables (e_ij (1<i,j<n)) in char p>=0
makeQso3([n]);    create U_q(so_3) in the presentation of Klimyk (if int n is given, the quantum parameter will be specialized at the 2n-th root of unity)
Qso3Casimir(n [,m]); returns a list with the (optionally normalized) Casimir elements of U_q(so_3) for the quantum parameter specialized at the 2n-th root of unity
makeQsl2([n]);    preparation for U_q(sl_2) as factor-algebra; if n is specified, the quantum parameter q will be specialized at the n-th root of unity
makeQsl3([n]);    preparation for U_q(sl_3) as factor-algebra; if n is specified, the quantum parameter q will be specialized at the n-th root of unity
GKZsystem(A, sord, alg [,v]);  define a ring and a Gelfand-Kapranov-Zelevinsky system of differential equations
";

LIB "nctools.lib"; // rootofUnity, 
LIB "general.lib";
LIB "toric.lib"; // needed for GKZsystem

///////////////////////////////////////////////////////////////////////////////
static proc defInt ( list # )
// return 0 or int(#)
{
  int @p = 0;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @p = #[1];
    };
  };
  return (@p);
};

///////////////////////////////////////////////////////////////////////////////
proc makeUsl2(list #)
"USAGE:   makeUsl2([p]), p an optional integer (field characteristic)
RETURN:  ring
PURPOSE: set up the U(sl_2) in the variables e,f,h over the field of char p
NOTE:    activate this ring with the @code{setring} command
SEE ALSO: makeUsl, makeUg2, makeUgl
EXAMPLE: example makeUsl2; shows examples
"{
   int @p = defInt(#);
   ring @@@rrr=@p,(e,f,h),dp;
   matrix D[3][3]=0;
   D[1,2]=-h;
   D[1,3]=2*e;
   D[2,3]=-2*f;
   ncalgebra(1,D);
   return(@@@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=makeUsl2();
   setring a;
   a;
}

///////////////////////////////////////////////////////////////////////////////
proc makeUsl(int n, list #)
"USAGE:   makeUsl(n,[p]); n an integer, n>1; p an optional integer (field characteristic)
RETURN:  ring
PURPOSE: set up the U(sl_n) in the variables ( x(i),y(i),h(i) | i=1..n+1) over the field of char p
NOTE:    activate this ring with the @code{setring} command
@*       This presentation of U(sl_n) is the standard one, i.e. positive resp. negative roots are denoted by x(i) resp. y(i) and the Cartan elements are denoted by h(i).
@* The variables are ordered as x(1),...x(n),y(1),...,y(n),h(1),...h(n).
SEE ALSO: makeUsl2, makeUg2, makeUgl, makeQsl3, makeQso3
EXAMPLE: example makeUsl; shows examples
"{
  if (n<2)
  {
    print("Incorrect input");
    return(0);
  }
  if (n==2)
  {
    def @@@a=makeUsl2(#);
    setring @@@a;
    return(@@@a);
  }

  int @p = defInt(#);
  ring @@@rr=@p,(x(1..n*(n-1)/2),y(1..n*(n-1)/2),h(1..n-1)),dp;
  intmat CNT[n][n]=0;
  matrix TMP[n][n]=0;
  int k,l=1,1;
  int buf=0;
  list X,Y,H;
  for(k=1; k<=n; k++)
  {
    for(l=k+1; l<=n; l++)
    {
      buf = (l-k-1)*(2*n-l+k)/2 + k;
      CNT[k,l] = buf;
      TMP[k,l] = 1;
      X[buf] = TMP;
      TMP = 0;
      CNT[l,k] = buf;
      TMP[l,k] = 1;
      Y[buf] = TMP;
      TMP=0;
    }
  }
  for(k=1; k<=n-1; k++)
  {
    TMP[k,k]=1;
    TMP[k+1,k+1]=-1;
    H[k]=TMP;
    TMP=0;
  }
  int i,j=1,1;
  number p,q=0,0;
  list V=X+Y+H;
  int v=size(V);
  matrix D[v][v]=0;
  for(k=1; k<=v; k++)
  {
    for(l=k+1; l<=v; l++)
    {
      TMP=V[l]*V[k]-V[k]*V[l];
      for(i=1; i<=n; i++)
      {
        for(j=i+1; j<=n; j++)
        {
          buf=(j-i-1)*(2*n-j+i)/2+i;
          if (TMP[i,j]!=0)
          {
            D[k,l]=D[k,l]+leadcoef(TMP[i,j])*x(buf);
          }
          if (TMP[j,i]!=0)
          {
            D[k,l]=D[k,l]+leadcoef(TMP[j,i])*y(buf);
          }
        }
      }
      i=1;
      while ( (TMP[i,i]==0) && (i<n) ) { i++; }
      for(j=i; j<=n-1; j++)
      {
        p=leadcoef(TMP[j,j]);
        q=leadcoef(TMP[j+1,j+1]);
        D[k,l]=D[k,l]+p*h(j);
        //        if ((j!=n-1)&&((p+q)!=0)) {D[k,l]=D[k,l]+(p+q)*h(j+1);}
        TMP[j+1,j+1]=TMP[j+1,j+1]+p;
      }
    }
  }
  ncalgebra(1,D);
  return(@@@rr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=makeUsl(3);
   setring a;
   a;
}

///////////////////////////////////////////////////////////////////////////////
proc makeUg2(list #)
"USAGE:  makeUg2([p]), p an optional int (field characteristic)
RETURN:  ring
PURPOSE: set up the U(g_2) in variables (x(i),y(i),Ha,Hb) for i=1..6 over the field of char p
NOTE:    activate this ring with the @code{setring} command
@* the variables are ordered as x(1),...x(6),y(1),...,y(6),Ha,Hb.
SEE ALSO: makeUsl, makeUgl
EXAMPLE: example makeUg2; shows examples
"{
  int @p = defInt(#);
  ring @@@rrr=@p,(x(1..6),y(1..6),Ha,Hb),dp;
  setring @@@rrr;
  matrix D[14][14];
  D[1,2]=-x(3);
  D[1,3]=-2*x(4);
  D[1,4]=3*x(5);
  D[1,7]=-Ha;
  D[1,9]=3*y(2);
  D[1,10]=2*y(3);
  D[1,11]=-y(4);
  D[1,13]=2*x(1);
  D[1,14]=-x(1);
  D[2,5]=x(6);
  D[2,8]=-Hb;
  D[2,9]=-y(1);
  D[2,12]=-y(5);
  D[2,13]=-3*x(2);
  D[2,14]=2*x(2);
  D[3,4]=3*x(6);
  D[3,7]=3*x(2);
  D[3,8]=-x(1);
  D[3,9]=-Ha-3*Hb;
  D[3,10]=-2*y(1);
  D[3,12]=-y(4);
  D[3,13]=-x(3);
  D[3,14]=x(3);
  D[4,7]=2*x(3);
  D[4,9]=-2*x(1);
  D[4,10]=-2*Ha-3*Hb;
  D[4,11]=y(1);
  D[4,12]=y(3);
  D[4,13]=x(4);
  D[5,7]=-x(4);
  D[5,10]=x(1);
  D[5,11]=-Ha-Hb;
  D[5,12]=y(2);
  D[5,13]=3*x(5);
  D[5,14]=-x(5);
  D[6,8]=-x(5);
  D[6,9]=-x(4);
  D[6,10]=x(3);
  D[6,11]=x(2);
  D[6,12]=-Ha-2*Hb;
  D[6,14]=x(6);
  D[7,8]=y(3);
  D[7,9]=2*y(4);
  D[7,10]=-3*y(5);
  D[7,13]=-2*y(1);
  D[7,14]=y(1);
  D[8,11]=-y(6);
  D[8,13]=3*y(2);
  D[8,14]=-2*y(2);
  D[9,10]=-3*y(6);
  D[9,13]=y(3);
  D[9,14]=-y(3);
  D[10,13]=-y(4);
  D[11,13]=-3*y(5);
  D[11,14]=y(5);
  D[12,14]=-y(6);
  ncalgebra(1,D);
  return(@@@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a = makeUg2();
   setring a;  a;
}

///////////////////////////////////////////////////////////////////////////////
proc makeUgl(int n, list #)
"USAGE:   makeUgl(n,[p]); n an int, n>1;  p an optional int (field characteristic)
RETURN:  ring
PURPOSE: set up the U(gl_n) in the (e_ij (1<i,j<n)) presentation (where e_ij corresponds to a matrix with 1 at i,j only) over the field of char p
NOTE:    activate this ring with the @code{setring} command
@* the variables are ordered as e_12,e_13,...,e_1n,e_21,...,e_nn.
SEE ALSO: makeUsl, makeUg2
EXAMPLE: example makeUgl; shows examples
"{
  if (n<2)
  {
    print("Incorrect input");
    return(0);
  };
  int @p = defInt(#);
  int i, j;
  string vs = "";
  for ( i = 1; i<= n ; i++ )
  {
        for ( j = 1; j<= n ; j++ )
        {
            if ( vs != "" )
            {
                vs = vs + ", ";
            };
            vs = vs + "e_" + string(i) + "_" + string(j);
        };
  };
  string strRING = "ring RING_MAKEUGL=(" + string (@p) + "), (" + vs + "),dp;";
  execute( strRING );
  int N = nvars( RING_MAKEUGL ); // n*n
  matrix D[N][N]=0;
  int k, l;
  int ik,il,jk,jl;
  poly p ;
  for( k=1; k<=N; k++)
  {
    ik = 1 + ((k-1)/n);
    jk = k -  n*(ik-1);

    for( l=k+1; l<=N; l++)
    {
        il = 1 + ((l-1)/n);
        jl = l -  n*(il-1);
        p = 0;
        if( jl == ik )
        {
            p = p + var ( (il-1)*n + jk );
        };
        if( jk == il )
        {
            p = p - var ( (ik-1)*n + jl );
        };
        D[k,l]=p;
    };
  };
  ncalgebra(1,D);
  return(RING_MAKEUGL);
}
example
{ "EXAMPLE:"; echo = 2;
   def a=makeUgl(3);
   setring a; a;
};

///////////////////////////////////////////////////////////////////////////////
proc makeQso3(list #)
"USAGE:   makeQso3([n]), n an optional int
PURPOSE: set up the U_q(so_3) in the presentation of Klimyk; if n is specified, the quantum parameter Q will be specialized at the (2n)-th root of unity
RETURN:  ring
NOTE:    activate this ring with the @code{setring} command
SEE ALSO: makeUsl, makeUg2, makeUgl, makeQsl2, makeQsl3, Qso3Casimir
EXAMPLE: example makeQso3; shows examples
"{
  int @p = 2*defInt(#);
  ring @@@r=(0,Q),(x,y,z),dp;
  minpoly = rootofUnity(@p);
  matrix C[3][3];
  C[1,2]=Q2;
  C[1,3]=1/Q2;
  C[2,3]=Q2;
  matrix D[3][3];
  D[1,2]=-Q*z;
  D[1,3]=1/Q*y;
  D[2,3]=-Q*x;
  ncalgebra(C,D);
  return(@@@r);
}
example
{ "EXAMPLE:"; echo = 2;
   def K = makeQso3(3);
   setring K;
   K;
}

///////////////////////////////////////////////////////////////////////////////
proc Qso3Casimir(int n, list #)
"USAGE:   Qso3Casimir(n [,m]), n an integer, m an optional integer
RETURN:  list (of polynomials)
PURPOSE: compute the Casimir (central) elements of U_q(so_3) for the quantum parameter specialized at the n-th root of unity; if m!=0 is given, polynomials will be normalized
ASSUME:    the basering must be U_q(so_3)
SEE ALSO: makeQso3
EXAMPLE: example Qso3Casimir; shows examples
"{
  if ( npars(basering) !=1 )
  {
    "Error: wrong algebra. U_q(so3) has only one parameter";
    return(0);
  }
  if (n<1) { return(0); }
  number Q = par(1);
  int N=(n-1)/2;
  int NV=nvars(basering);
  number k1,k2;
  poly p,rs,hlp;
  list cp;
  int j;
  p=var(1);
  for(j=0; j<=N; j++)
  {
    k1 = binomial(n-j,j,0);
    k1=k1/(n-j);
    k1=k1*((-1)^j);
    k2=((Q^2)/(Q^4-1))^(2*j);
    k2=k2*k1;
    hlp=k2*(p)^(n-(2*j));
    rs=rs+hlp;
    hlp=0; k2=0; k1=0;
  }
  if (size(#)>0)
  {
    int m = int(#[1]);
    if (m!=0)
    {
       rs = cleardenom(rs);
    }
  }
  cp[1] = rs;
  for(j=2; j<=NV; j++)
  {
    cp[j] = subst(rs,var(1),var(j));
  }
  return(cp);
}
example
{ "EXAMPLE:"; echo = 2;
   def R = makeQso3(5);
   setring R;
   list C = Qso3Casimir(5);
   C;
   list Cnorm = Qso3Casimir(5,1);
   Cnorm;
}

///////////////////////////////////////////////////////////////////////////////
proc makeQsl2(list #)
"USAGE:   makeQsl2([n]), n an optional int
RETURN:   ring
PURPOSE:  define the U_q(sl_2) as a factor-ring of a ring V_q(sl_2) modulo the ideal @code{Qideal}
NOTE:   the output consists of a ring, presenting V_q(sl_2) together with the ideal called @code{Qideal} in this ring
@* activate this ring with the @code{setring} command
@* in order to create the U_q(sl_2) from the output, execute the command like @code{qring Usl2q = Qideal;}
@* If n is specified, the quantum parameter q will be specialized at the n-th root of unity
SEE ALSO: makeUsl, makeQsl3, makeQso3
EXAMPLE: example makeQsl2; shows examples
"{
  ring r=(0,q),(E,F,Ke,Kf),dp;
  int @p = defInt(#);
  if (@p >1)
  {
    minpoly = rootofUnity(@p);
  }
  matrix C = UpOneMatrix(4);;
  matrix D[4][4];
  C[1,3]=q^2;
  C[2,3]=1/(q^2);
  C[1,4]=1/(q^2);
  C[2,4]=q^2;
  D[1,2]=(1/(q-(1/q)))*(-Ke+Kf);
  ncalgebra(C,D);
  ideal Qideal = Ke*Kf-1;
  Qideal = twostd(Qideal);
  export Qideal;
  return(r);
}
example
{ "EXAMPLE:"; echo = 2;
   def A = makeQsl2(3);
   setring A;
   Qideal;
   qring Usl2q = Qideal;
   Usl2q;
}

///////////////////////////////////////////////////////////////////////////////
proc makeQsl3(list #)
"USAGE:   makeQsl3([n]), n an optional int
RETURN:   ring
PURPOSE:  define the U_q(sl_3) as a factor-ring of a ring V_q(sl_3) modulo the ideal @code{Qideal}
NOTE:   the output consists of a ring, presenting V_q(sl_3) together with the ideal called @code{Qideal} in this ring
@* activate this ring with the @code{setring} command
@* in order to create the U_q(sl_3) from the output, execute the command like @code{qring Usl3q = Qideal;}
@* If n is specified, the quantum parameter q will be specialized at the n-th root of unity
SEE ALSO: makeUsl, makeQsl2, makeQso3
EXAMPLE: example makeQsl3; shows examples
"{
  int @p = defInt(#);
  ring @@@rrr=(0, q), (f12, f13, f23, k1, k2, l1, l2, e12, e13, e23), wp(2, 3, 2, 1, 1, 1, 1, 2, 3, 2);
  if (@p >1)
  {
    minpoly = rootofUnity(@p);
  }
  int @n = nvars(@@@rrr);
  matrix C = UpOneMatrix(@n);
  matrix D[@n][@n];
  // some constants
  number q1 =    1/q;
  number Q  = (q )^2;
  number Q1 = (q1)^2;
  //   number QQ = Q - Q1; // q2 - 1/(q2)
  number QQ1= 1 / (Q - Q1);
  // relations:
  C[1,2] = Q1;
  C[2,3] = C[1,2];
  C[8,9] = C[1,2];
  C[9,10]= C[1,2];
  C[1,3] = Q;
  C[8,10]= C[1,3];

  D[1,3] = -q*(f13);
  D[8,10]= -q*(e13);
  // V_q(sl_3)
  D[1,8] = QQ1 * ( (k1) ^ 2 - (l1) ^ 2 );
  D[3,10]= QQ1 * ( (k2) ^ 2 - (l2) ^ 2 );
  D[2,9] = -QQ1 * ( ((k1)^2)*((k2)^2) - ((l1)^2)*((l2)^2) );
  D[2, 8] =   q * (f23) * ((k1)^2);
  D[3, 9] =   q * ((k2)^2) * (e12);
  D[1, 9] = -q1 * ((l1)^2) * (e23);
  D[2, 10]= -q1 * (f12) * ((l2)^2);
  // k1
  C[ 4, 8 ]= Q1;
  C[ 4, 9 ]= q1;
  C[ 4, 10]= q;
  // l1
  C[ 6, 8 ]= Q;
  C[ 6, 9 ]= q;
  C[ 6, 10]= q1;
  // k2
  C[ 5, 8 ]= q;
  C[ 5, 9 ]= q1;
  C[ 5, 10]= Q1;
  // l2
  C[ 7, 8 ]= q1;
  C[ 7, 9 ]= q;
  C[ 7, 10]= Q;
  // k1
  C[ 1, 4 ]= Q1;
  C[ 2, 4 ]= q1;
  C[ 3, 4 ]= q;
  // l1
  C[ 1, 6 ]= Q;
  C[ 2, 6 ]= q;
  C[ 3, 6 ]= q1;
  // k2
  C[ 1, 5 ]= q;
  C[ 2, 5 ]= q1;
  C[ 3, 5 ]= Q1;
  // l2
  C[ 1, 7 ]= q1;
  C[ 2, 7 ]= q;
  C[ 3, 7 ]= Q;
  ncalgebra(C,D); // the V_q(makeUsl3) is done
  ideal Qideal = k1*l1-1,  k2*l2-1;
  Qideal = twostd(Qideal);
  export Qideal;
  return(@@@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def B = makeQsl3(5);
   setring B;
   qring Usl3q = Qideal;
   Usl3q;
}

proc GKZsystem(intmat A, string sord, string alg, list #)
"USAGE:   GKZsystem(A, sord, alg, [,v]); A intmat, sord, alg string, v intvec
RETURN:  ring
PURPOSE: define a ring (Weyl algebra) and create a Gelfand-Kapranov-Zelevinsky (GKZ) system of equations in a ring from the following data:
@*        @code{A}    is an intmat, defining the system,
@*        @code{sord} is a string with desired term ordering,
@*        @code{alg}  is a string, saying which algorithm to use (exactly like in toric_lib),
@*        @code{v}    is an optional intvec.
@* In addition, the ideal called @code{GKZid} containing actual equations is calculated and exported to the ring.
NOTE:    activate the ring with the @code{setring} command. This procedure is elaborated by Oleksandr Yena
ASSUME: This procedure uses toric_lib and therefore inherits its input requirements:
@*        possible values for input variable @code{alg} are: \"ect\",\"pt\",\"blr\", \"hs\", \"du\".
@*        As for the term ordering, it should be a string @code{sord} in Singular format like \"lp\",\"dp\", etc. 
@*        Please consult the toric_lib for allowed orderings and more details.
SEE ALSO: toric_lib
EXAMPLE: example GKZsystem; shows examples
"{
  int d = nrows(A);
  int n = ncols(A);
  execute("ring r1=0,(d(1..n)),"+sord+";");
  ideal I0;
  if (size(#)==0)
  {
    I0 = toric_ideal(A, alg);
  }
  else
  {
    if ( typeof(#[1]) == "intvec" )
    {
      intvec V = intvec(#[1]);
      I0 = toric_ideal(A, alg, V);
    }
    else
    {
      "Wrong type of the optional argument. Intvec expected.";
      return();
    }
  };
  execute("ring GR = (0,b(1..d)),(x(1..n),d(1..n)),"+sord+";");
  Weyl();
  int i,j;
  poly p;
  ideal I;
  for (i=1; i<=d; i++)
  {
    p = -b(i);
    for (j=1; j<=n; j++)
    {
      p = p+ A[i,j]*x(j)*d(j);
    }
  I = I, p;
  }
  I = I, imap(r1,I0);
  I = simplify(I,2);
  ideal GKZid = I;
  export GKZid;
  return(GR);
}
example
{"EXAMPLE:"; echo = 2;
  // example 3.1.4 from the [SST] without vector w
  intmat A[2][4]=3,2,1,0,0,1,2,3;
  print(A);
  def D1 = GKZsystem(A,"lp","ect");
  setring D1;
  D1;
  print(GKZid);
  // now, consider A with the vector w=1,1,1,1
  intvec v=1,1,1,1;
  def D2 = GKZsystem(A,"lp","blr",v);
  setring D2;
  print(GKZid);
}
// easier example: 3.1.1 from SST
//   intmat A[2][3]=2,1,0,0,1,2;
///////////////////////////////////////////////////////////////////////////////
