// $Id: tex.lib,v 1.2 1997-07-03 15:49:56 Singular Exp $   
//
// author : Christian Gorzel email: gorzelc@math.uni-muenster.de
// created ....18.4.97 (lastchange 13.6.97)
///////////////////////////////////////////////////////////////////////////////


LIBRARY: tex.lib      PROCEDURES FOR TYPESET OF SINGULAROBJECTS IN TEX
                        by Christian Gorzel, send bugs and
                        comments to gorzelc@math.uni-muenster.de
 
 closetex(s);         writes closing line for TeX-document
 opentex(s);          writes header for TeX-file s
 tex(s);              call latex for TeX-file s
 texdemo();           produces a latex file explaining the features of this lib
 texfactorize(fnm,f); create string in TeX-Symbolformat for factors of poly f
 texmap(fnm,m,r1,r2); create string in TeX-Symbolformat for map m:r1->r2
 texname(fnm,s);      create string in TeX-Symbolformat for identifier
 texobj(l);           creates string in TeX-Symbolformat for any (basic) type
 texpoly(f,n[,l]);    creates string in TeX-Symbolformat for poly
 texproc(fnm,p);      create string in TeX-Symbolformat of text from proc p
 texring(fnm,r[,l]);  create string in TeX-Symbolformat for ring/qring
 rmx(s);              remove .aux and .log files of TeXfile s
 xdvi(s);             call xdvi for dvi-file s
         (parameters in square brackets [] are optional)
 
                      Global Variables: 
  TeXwidth, TeXnofrac, TeXbrack, TeXproj, TeXaligned, TeXreplace, NoDollars
                  are used to control the typesetting  
    Call example texdemo; to become familiar with the features of tex.lib


  TeXwidth      : int: -1,0,1..9, >9  controls the breaking of long polynomials
  TeXnofrac     : (int) flag,  write 1/2 instead of \\frac{1}{2}
  TeXbrack      : string: possible values {,(,<,|, \"\"
                          controls brackets around ideals and matrices
  TeXproj       : (int) flag, write : instead of , in intvecs and vectors
  TeXaligned    : (int) flag, write mappings (and ideals) aligned
  TeXreplace    : list, entries twoelemented list for replacing symbols
  NoDollars     : (int) flag, suppresses surrounding "$" signs


///////////////////////////////////////////////////////////////////////////////

proc closetex(string fname, list #) 
USAGE:   closetex(fname[,style]); fname,style = string
RETURN:  nothing; writes a LaTeX2e closing line into file fname
NOTE:    style overwrites the default setting latex2e; maybe latex,amstex,tex 
         preceeding ">>" end ending ".tex" may miss in fname; 
         overwriting an existing file is not possible
EXAMPLE: example closetex; shows an example
{
  string default = "latex2e";       // may be changed appropriatly (C.G.)
  int i = 1;

  if (size(#)) { default = #[1];}
  if (not(size(fname)))                      // filename is the empty string
  { print("-- Error: need a filename");
     return();
  }
  while (fname[i]==">"){i++;}
  fname = fname[i,size(fname)-i+1];

  if (size(fname)>=4)               // check if filename is ending with ".tex"
  { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
  }
  else {fname = fname + ".tex";}
  
  if (default=="tex") {write(fname,"\\bye");}
  else { write(fname,"\\end{document}");}  
  return(); 
}
example
{ "EXAMPLE:"; echo=2;
   opentex("exmpl");
   texobj("exmpl","{\\large \\bf hello}");
   closetex("exmpl");
}
///////////////////////////////////////////////////////////////////////////////

proc tex(string fname, list #)
USAGE:   tex(fname[,style]); fname,style = string
RETURN:  nothing; calls latex2e for compiling the file fname
NOTE:    style overwrites the default setting latex2e; maybe latex,amstex,tex 
         ending ".tex" may miss in fname        
EXAMPLE: example tex; shows an example
{ 
  string default = "latex2e";           // may be changed appropriatly (C.G.)
  int i=1;

  while (fname[i]==">"){i++;}
  fname = fname[i,size(fname)-i+1];

  if (size(fname)>=4)               // check if filename is ending with ".tex"
  { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
  }
  else {fname = fname + ".tex";}
  if (size(#)) {default = #[1];}
  "calling ",default, " for :",fname,newline;

  system("sh",default + " " +  fname);
  return();
}
example
{ "EXAMPLE:"; echo =2;
  ring r;
  ideal I = maxideal(7);
  opentex("exp001");              // defaulted latex2e document
  texobj("exp001","An ideal ",I);
  closetex("exp001");
  tex("exp001");

  opentex("exp002","tex");       // create a texdocument
  texobj("exp002","An ideal",I);
  closetex("exp002");
  tex("exp002","tex");
  echo = 0;
  print("the created files will be deleted after pressing <RETURN> ");
  pause;
  echo = 2;
  system("sh","rm -i exp00?.*");
}
///////////////////////////////////////////////////////////////////////////////

proc opentex(string fname, list #)         
USAGE:   opentex(fname[,style]); fname,style = string
RETURN:  nothing; writes as LaTeX2e header into a new file fname
NOTE:    suffix .tex may miss in fname
         style overwrites the default setting latex2e; may be latex,amstex,tex 
EXAMPLE: example opentex; shows an example
{
  int i =1;

  while (fname[i]==">"){i++;}
  fname = fname[i,size(fname)-i+1];

  if (size(fname)>=4)               // check if filename is ending with ".tex"
  { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
  }
  else {fname = fname + ".tex";}

  fname = ">" + fname;
  write(fname, "\\documentstyle[12pt,amstex]{article}");
  fname = ">" + fname;              // aendern
  write(fname, "\\parindent=0pt");
  write(fname,
  "\\newcommand{\\C}{{\\Bbb C}}",
  "\\newcommand{\\F}{{\\Bbb F}}", 
  "\\newcommand{\\N}{{\\Bbb N}}",
 // "\\newcommand{\\P}{{\\Bbb P}}",
  "\\newcommand{\\Q}{{\\Bbb Q}}",
  "\\newcommand{\\R}{{\\Bbb R}}",
  "\\newcommand{\\T}{{\\Bbb T}}",
  "\\newcommand{\\Z}{{\\Bbb Z}}",newline);
  write(fname, "\\begin{document}");
  return();   
}
example
{ "EXAMPLE:"; echo=2;
   opentex("exmpl");
   texobj("exmpl","hello");
   closetex("exmpl");
}
///////////////////////////////////////////////////////////////////////////////

proc texdemo(list #) 
USAGE:   texdemo();
RETURN:  nothing; generates automatically a LaTeX2e file called: texlibdemo.tex
         explaining the  features of tex.lib and its gloabl variables
NOTE:    this proc takes some minutes         
EXAMPLE: example texdemo; executes the generation
{ int make_demo = size(#);

  print(" Not implemeted yet");
  return();
  if (make_demo) {make_demo=(#[1]=="yes");}
  if(make_demo)
  { 
   int TeXdemopart = sytem("sh","sh");
   system("random",TeXdemopart);

   part0();
   part1();
   part2();
   part3();
   print(" tldemo.tex generated ...");
   exitall;
  }
  else
  { print("Enter texdemo(\"yes\") to generate the demofile.");
    return();
  }
}
example
{ "EXAMPLE:";
   print("Enter texdemo(\"yes\") to generate the demofile.");
}
///////////////////////////////////////////////////////////////////////////////

proc texfactorize(string fname, poly f, list #) 
USAGE:   opentex(fname,f); fname = string; f = poly
RETURN:  string, the poly as as product of its irreducible factors
                 in TeX-typesetting if fname == empty string;
         otherwise append this to file fname.tex; return nothing  
NOTE:    preceeding ">>" end ending ".tex" may miss in fname 
EXAMPLE: example texfactorize; shows an example
{
  def @r = basering;
  list l;
  int i,j,k,Tw,TW,ND;;
  intvec v;
  string s,t;
  string D = "$";
  poly g;

  ND = defined(NoDollars);
  if (!(ND)) {int NoDollars; export NoDollars;}
  else { D = ""; }
  TW = defined(TeXwidth);
  if (TW) {Tw = TeXwidth; TeXwidth = -1;}  
  else {int TeXwidth = -1; export TeXwidth;}

  if (f==0) {s= D + "0" + D;}
  else
  {
   l = factorize(f);      // sollte auch fuer f== 0 direkt funktionieren
   if (l[1][1]<>1){s = texpoly("",l[1][1]);}
   for(i=2;i<=size(l[1]);i++)
   {
    if(size(s)){s = s+"\\cdot ";}
    g = l[1][i];
    v = leadexp(g);
    k=0;
    for(j=1;j<=size(v);j++){k = k + v[j];}
    if(size(g)>1 or (size(g)==1 and k>1))
    { t = "(" + texpoly("",l[1][i]) + ")";}
    else { t =  texpoly("",l[1][i]);} 
    if (l[2][i]>1)
    { t = t+"^{" +string(l[2][i]) + "}";}
    s = s + t;
   }
   if (!(ND)) { kill NoDollars;}
   s = D + s + D;
   if (TW) {TeXwidth = Tw;}
  }
  if(size(fname)) 
  { i=1;
    while (fname[i]==">"){i++;}
    fname = fname[i,size(fname)-i+1];

    if (size(fname)>=4)             // check if filename is ending with ".tex"
    { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
    }
    else {fname = fname + ".tex";}
    write(fname,s);
  }
  else{return(s);}
}
example
{ "EXAMPLE:"; echo=2;
  ring r2=13,(x,y),dp;
  poly f = (x+1+y)^2*x3y*(2x -2y)*y12;
  texfactorize("",f);
  ring R49 = (7,a),x,dp;
  minpoly = a2 +a +3;
  poly f = (a24x5 + x3)*a2x6*(x+1)^2;
  f; 
  texfactorize("",f);
}
///////////////////////////////////////////////////////////////////////////////

proc texmap(string fname, def m, def @r1, def @r2, list #)
USAGE:   texmap(fname,f); fname = string; m = string/map, @r1,@r2 = ring
RETURN:  string, the map m from @r1 to @r2 preeceded by its name if m = string
                 in TeX-typesetting if fname == empty string;
         otherwise append this to file fname.tex; return nothing  
NOTE:    preceeding ">>" end ending ".tex" may miss in fname 
EXAMPLE: example texmap; shows an example
{ 
  int saveDollars= defined(NoDollars);
  int TX = defined(TeXwidth);
  int Tw;
  int i,n;
  string r1str,r2str, varr1str, varr2str;
  string mapname,t,s;
  string D,DD,vrg = "$","$$",",";
  def @r = basering;
  def themap;
  list l1,l2;
  string rr1,rr2 = "@r1","@r2";

  proc rp(string s)
  { int i;

    for(i=1;i<=size(TeXreplace);i++) 
    { if (TeXreplace[i][1]==s) {s= TeXreplace[i][2]; break;}}
    return(s);
  }
  
// --- store all actual informations
  if(TX) { Tw = TeXwidth; TeXwidth = -1;}
  else { int TeXwidth = -1; export TeXwidth;}
  if (!(saveDollars)) { int  NoDollars; export NoDollars;}
  if (defined(TeXproj)) {vrg = ":";}

  if (size(#))
  { if (typeof(#[1])=="list")
    { l1 = #[1];
      if(size(#)==2) { l2 = #[2];}
    }
    else {l1=#; l2 =#;}
  }
// --- tex the information in preimring r1

  setring(@r1);
  r1str = texring("",@r1,l1);
// --- avoid an execute; hence construct an ideal

  n = nvars(@r1);
  if (n>1) { t = "\\left(";}
  ideal @I = var(1);
  t = t + texpoly("",var(1));
  for(i=2;i<=n;i++)
  { @I = @I + var(i);
    t = t + vrg + texpoly("",var(i));
  }
  if (n>1) { t = t + "\\right)";}
  varr1str = t;

// --- now the things in ring ring r2

  setring(@r2);
 // listvar();

  if (typeof(m)=="string")
  { themap = `m`;
    mapname = m;
    if (defined(TeXreplace))
    { mapname = rp(mapname);   // rp ausschreiben !
    }
    mapname = mapname + ":";
  }
  if (typeof(m)=="map") { themap = m;}

  r2str = texring("",@r2,l2);
  ideal @J  = themap(@I);
  n = size(matrix(@J));
  if (n>1) { t = " \\left(";}
  if (!(defined(TeXaligned)) and (n>1))
      { t = t + newline + "\\begin{array}{c}" + newline;}
  t = t + texpoly("",@J[1]);
  for (i=2;i<=n; i++)
  {if(defined(TeXaligned)) 
   { t = t + vrg + texpoly("",@J[i]); }
   else { t = t + "\\\\" + newline + texpoly("",@J[i]);}
  }
  if (!(defined(TeXaligned)) and (n>1))
      { t = t + newline + "\\end{array}" + newline;}
  if (n>1) {t = t + "\\right)";}
  varr2str = t;

// --- go back to  ring r1 to kill @I

  setring(@r1);
  kill @I;

// --- now reset the old settings and stick all the information together

  setring(@r);
  if (!(saveDollars)) { kill NoDollars;}
  if (TX) {TeXwidth = Tw;}
  else { kill TeXwidth;}
  if (defined(NoDollars))
  { D,DD = "",""; }

  if (defined(TeXaligned))
  { s = D + mapname;
    s =  s + r1str + "\\longrightarrow" + r2str + ", \\ " +
        varr1str + "\\longmapsto" + varr2str + D; }
  else
  { s = DD;
    s = s + newline + "\\begin{array}{rcc}" +  newline;
    s = s + mapname + r1str + " & \\longrightarrow & " +  r2str + "\\\\[2mm]"
          + newline;
    s = s + varr1str + " & \\longmapsto & " +  newline + varr2str + newline;
    s = s + "\\end{array}" + newline;
    s = s +  DD;
  }

  if (size(fname))
  { i=1;
    while (fname[i]==">"){i++;}
    fname = fname[i,size(fname)-i+1];

    if (size(fname)>=4)          // check if filename is ending with ".tex"
    { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
    }
    else {fname = fname + ".tex";}
    write(fname,s);
  }
  else {return(s);}
}
example 
{ "EXAMPLE:"; echo = 2;
  string fname = "tldemo";
  ring r1=0,(x,y,z),dp;   export r1;
  ring r2=0,(u,v),dp;
  map phi =(r1,u2,uv -v,v2); export phi;
  list TeXreplace;
  TeXreplace[1] = list("phi","\\phi");
  export TeXreplace;
  texmap("","phi",r1,r2);
  int TeXaligned; export TeXaligned;
  texmap("",phi,r1,r2,"\\C");
  kill r1,r2,TeXreplace,TeXaligned;
}       
///////////////////////////////////////////////////////////////////////////////

proc texname(string fname, string s) 
USAGE:   texname(fname,s);  fname,s = string
RETURN:  the string s if fname == the empty string "" ;
         otherwise append s to file fname.tex; return nothing 
NOTE:    preceeding ">>" end ending ".tex" may miss in fname;         
EXAMPLE: example texname; shows an example
{
  string st, extr;
  int i,anf,end,op,bigch;
  int n;

  if (s[1]=="{") { return(s[2,size(s)-2]);}
  if (s=="") { return(s);}
  s = s + newline;             // add a terminating sign
  anf=1;
  while(s[i]!=newline)
  {
   i =anf;

  while(s[i]<"0" or s[i]>"9" and s[i]!="'" and s[i]!= "_" and s[i]!="~" and
        s[i]!="(" and s[i]!=")" and s[i]!= "[" and s[i]!=newline) {i++;}
  if (s[i]==newline){st = st + s[anf,i-anf]; n = n +10*(i-anf); return(st);}
  st = st + s[anf,i-anf];                        // the starting letters
 if (s[anf]>="A" and s[anf]<="Z") {bigch=1;}
  if (s[i]=="'") { st = st + "'";i++;}
  if (s[i]=="~") { st = "\\tilde{" + st + "}"; i++;}
  if (s[i]=="_") { i++;}
  if (s[i]=="(") { op =1;i++;}
  if (s[i]=="[") { anf = i+1;
   while(s[i]!="]"){i++;}                    // matrices and vectors
    st = st + "_{" + s[anf,i-anf] + "}"; n = n+ 5*(i-anf); i++; 
  // besser: while s[i]<> nwline : scan forward: end, return
  }
  if (s[i]==newline) {return(st);}
  anf =i;
  while (s[i]>="0" and s[i]<="9") {i++;}  // parse the number after the letters
  if (bigch and not(op)) { st = st + "^{" + s[anf,i-anf] + "}"; bigch =0;}
  else { st = st + "_{" + s[anf,i-anf] + "}";}
  n = n+5*(i-anf);
  anf =i;            // the next text in ( , ) as exponent
  if (op) { if (s[i]== ","){anf = anf+1;}             
   while(s[i] !=")"){ i++;}
   if (i<>anf){st = st + "^{" + s[anf,i-anf] + "}"; n = n +5*(i-anf);}
  i++;
  }
  anf =i;
  }
  if (size(fname))
  { i=1;
    while (fname[i]==">"){i++;}
    fname = fname[i,size(fname)-i+1];

    if (size(fname)>=4)            // check if filename is ending with ".tex"
    { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
    }
    else {fname = fname + ".tex";}
    write(fname,st);
  }
  else {return(st);}
}
example
{ "EXAMPLE:"; echo =2;
   ring r = 0,(x,y),lp;
   poly f = 3xy4 + 2xy2 + x5y3 + x + y6;
   texname("","{f(10)}");
   texname("","f(10) =");
   texname("","n1");
   texname("","T1_12");
   texname("","g'_11");
   texname("","f23");
   texname("","M[2,3]");
   texname("","A(0,3);");
   texname("","E~(3)");
}
///////////////////////////////////////////////////////////////////////////////

proc texobj(string fname, list #)
USAGE:   texobj(fname,l); fname = string,l = list of Singular dataypes
RETURN:  string, the objects in TeX-typesetting if fname == empty string;
         otherwise append this to file fname.tex; return nothing    
NOTE:    preceeding ">>" end ending ".tex" may miss in fname;         
EXAMPLE: example texobj; shows an example
{
 int i,j,k,nr,nc,linear,Tw,Dollars;
 int ND = defined(NoDollars);
 int TW = defined(TeXwidth);

 if(defined(basering)){ poly g,h; matrix M;}
 string s,t,l,ineq,sg,Iname;
 string sep= ",";
 string D,DA,DE = "$","\\begin{equation*}","\\end{equation*}"+ newline;
 string OB,CB = "(",")"; 
 if (defined(TeXbrack))
 {// if (TeXbrack=="(") {OB = "("; CB = ")";}
   if (TeXbrack=="<") {OB = "<"; CB = ">";}
   if (TeXbrack=="{") {OB = "{"; CB = "}";}
   if (TeXbrack=="|") {OB = "|"; CB = "|";}
   if (TeXbrack=="" ) {OB = ""; CB = "";}
 }


 if (!(TW)) { int TeXwidth = -1; export TeXwidth; }
 Tw = TeXwidth;

 if (defined(TeXproj)){ sep = ":";}
 if(ND) { D,DA,DE="","","";}
 else {int NoDollars; export NoDollars;}

 proc absterm(poly f)
 { int k;
   
   for (k=1; k<=nvars(basering); k++)
   { f = subst(f,var(k),0); }
   return(f);
 }


 if (size(#)==1)
 { if (typeof(#[1])=="int" or typeof(#[1])=="intvec" or typeof(#[1])=="vector" 
   or typeof(#[1])=="number" or defined(TeXaligned)) { DA = D; DE = D; } }

 s = DA + newline;

 for (k=1; k<=size(#); k++)
 { def obj = #[k];
   if (typeof(obj) == "string") 
   { if (defined(`obj`))
     { if (typeof(`obj`)=="ideal") 
       { Iname = obj; def e = `obj`;
         kill obj; def obj = e; kill e;}
       else {s = s + obj + newline;}
    }
    else { s = s + obj + newline;}
   }
   if (typeof(obj) == "int") { s = s + "  " + string(obj) + "  ";}
 
   if (typeof(obj) == "intvec") 
   { s = s + "  (";
     for(j=1; j<size(obj);j++) { s = s + string(obj[j]) + sep;}
     s = s +  string(obj[j]) + ")  ";
   }

   if (typeof(obj) == "number" ) 
   { s = s + texpoly("",obj) + newline;
   }

   if (typeof(obj) == "poly")
   { int TeXdisplay; export TeXdisplay;
     s = s + "\\begin{split}" + newline;
     s = s + texpoly("",obj) + "\\\\" + newline;
     s = s + "\\end{split}" + newline;
    kill TeXdisplay;
   }

   if (typeof(obj) == "vector") 
   { if (obj==0) { s = s + D + "0" + D;}
     else
     {
      s = s + "\\left" + OB;
      for(j=1; j<nrows(obj); j++) {s = s + texpoly("",obj[j]) + sep;}
      s = s + texpoly("",obj[j])  + "\\right" + CB + newline;;
     }
    }

   if (typeof(obj) == "ideal") 
   { if (size(Iname))   // verwende hier align
     { if (Tw==0) {TeXwidth = -1;}
       s =  s + "\\begin{array}{rcl}" + newline;
       for (i=1;i<=size(matrix(obj));i++)
       { s =  s + Iname+ "_{" + string(i) + "} & = & " 
               + texpoly("",obj[i]);
         if (i<size(matrix(obj))){ s = s  + "\\\\" + newline;}
       }
       s = s + newline;
       s = s + "\\end{array}" + newline;
       TeXwidth = Tw;
       Iname ="";
     }
     else 
     {  
      if (TeXwidth==0) 
      { obj= simplify(obj,2);
        linear = 1;
        for (j=1;j<=size(obj);j++)
        { if (deg(obj[j])>1){linear =0; break;}
        }
        if (!(linear))
        { s = s + "\\begin{array}{rcl}" + newline;
          for(j=1;j<=size(obj);j++)
          { h = absterm(obj[j]);
            ineq = attrib(I[j],"ineq");
            if(!(size(ineq))) { ineq = "=" ; }
            l = texpoly("",obj[j]-h) + " & " + ineq + " & " + texpoly("",-h);
            if(j<size(obj)) { l = l + " \\\\";}
            s =s+ l + newline;
           }
          s = s + "\\end{array}" + newline;
        }
        else   // linear
        { s = s +  
   "\\begin{array}{*{" + string(2*nvars(basering)-1) + "}{c}cr}" + newline;
           for(j=1; j<=size(obj);j++) 
           { h = absterm(obj[j]); 
             ineq = attrib(obj[j],"ineq");
             if(!(size(ineq))) { ineq = "=" ; }
              l = ""; nc = 0;
              for (i=1; i<=nvars(basering);i++)
              { t = " "; sg ="";
                g = obj[j]-subst(obj[j],var(i),0);
                if (g!=0) { t = texpoly("",g);}
                if (i>1)
                { if (t[1]!="-" and t[1]!= " " and nc ){sg = "+";}
                  if  (t[1]=="-") { sg = "-"; nc =1; t=t[2,size(t)-1];}
                  if (t==" ") {sg ="";}  
                  l = l + " & " + sg + " & " + t;
                }
                else { l = t;}
                if (g!=0) {nc = 1;}
               }

               l = l + " & " + ineq + " & " + texpoly("",-h);
             if (j < size(obj)) { l = l + " \\\\";}
             s = s + l + newline;
            } // end for (j)
          s = s + "\\end{array}";
         }  // end else linear
       } // end TeXwidth == 0
   else // TeXwidth <> 0
   { s =  s + "\\left"+ OB;
     if (defined(TeXaligned))
     { s = s + texpoly("",obj,",");
     } 
     else
     { s = s + newline + "\\begin{array}{c}" + newline +
               texpoly("",obj,", \\\\" + newline) + 
                newline + "\\end{array}" + newline;
     }
    s = s + "\\right" + CB;
    } // end TeXwidth <> 0 
   }  // not Iname
// s;
  }

   if (typeof(obj) == "module") 
   { M = matrix(obj);
     if (Tw ==0 or Tw > 9) { TeXwidth = -1;}
     s = s + "\\left" + OB + newline;
     if (!(defined(TeXaligned)))
     {  // Naechste Zeile nicht notwendig !
     // s = s + "\\begin{array}{*{"+ string(ncols(M)) + "}{c}}" + newline; 
      for(j=1;j<=ncols(M);j++) 
      { l = "\\left" + OB + newline + "\\begin{array}{c}" + newline;
        l = l + texpoly("",ideal(M[j]), " \\\\" + newline)
              + newline + "\\end{array}" +newline + "\\right" + CB + newline;
        if (j< ncols(M)) { l = l + " , " + newline;}
        s = s + l ;
      }
     }
     else    // TeXaligned
     { 
      for(j=1;j<=ncols(M);j++) 
      { s = s + "\\left" + OB + newline +
                texpoly("",ideal(M[j]),",") + newline + "\\right" + CB;
        if (j<ncols(M)) { s = s + "," + newline; }
      }
     }
    s = s  + "\\right" + CB + newline;
   } // module part


   if (typeof(obj) == "matrix")
   { if (Tw==0 or Tw > 9) {TeXwidth = -1;}
     M = transpose(obj);
     s = s + "\\left" + OB + newline + 
             "\\begin{array}{*{"+ string(ncols(obj)) + "}{c}" + "}"+ newline;
     for(i=1;i<=ncols(M);i++)
     { l = l + texpoly("",ideal(M[i])," & ");
       if (i<ncols(M)) { l = l + " \\\\" + newline;}
     }
     l = l + newline;
     s = s + l + "\\end{array}" + newline + 
                 "\\right" + CB + newline;
    TeXwidth = Tw;
  }
  
   if (typeof(obj) == "intmat")
   { nr,nc = nrows(obj),ncols(obj);
     l = "";
     l =  "\\left" + OB + newline + 
          "\\begin{array}{*{"+ string(nc) + "}{r}}"+ newline;
     for(i=1;i<=nr;i++)
     { for(j=1;j<=nc;j++) 
       { l = l + string(obj[i,j]);
         if (j <nc ) { l = l + " & ";}
         else {if( i < nr) { l = l + "\\\\" + newline;}}
       }
     }
     l = l + newline + "\\end{array}" + newline + 
             "\\right" + CB + newline;
    s = s + l; 
  }

  if (typeof(obj) == "ring" or
      typeof(obj) == "qring") { s = s + D + texring("",obj) + D + newline;}

  kill obj;
 }

 s = s + DE + newline;

 if(!(ND)) { kill NoDollars;}

// s;
 if(size(fname))
 { i=1;
  while (fname[i]==">"){i++;}
  fname = fname[i,size(fname)-i+1];
  if (size(fname)>=4)               // check if filename is ending with ".tex"
  { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
  }
  else {fname = fname + ".tex";}
  write(fname,s);
 }
 else {return(s);}
}
example
{ "EXAMPLE:"; echo =2;
   ring r = 0,(x,y),lp;
   poly f = 3xy4 + 2xy2 + x5y3 + x + y6;
   ideal G = jacob(f);
   texobj("",G);
   matrix J = jacob(G);
   texobj("",J);
   intmat m[3,4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
   texobj("",m);
   ring r0 = 0,(x,y,z),dp;
   ideal I = 2x2-4yz3+2-4,zy2+2x,y5z-6x2+7y4z2 +5;
}
///////////////////////////////////////////////////////////////////////////////

proc texproc(string fname,string pname) 
USAGE:   opentex(fname,pname); fname,pname = string
RETURN:  string, the proc in a verbatim environment in TeX-typesetting 
                 if fname == empty string;
         otherwise append this to file fname.tex; return nothing  
NOTE:    preceeding ">>" end ending ".tex" may miss in fname; 
CAUTION: texproc cannot applied on itself correctly         
EXAMPLE: example texproc; shows an example
{
  int i,j=1,1;
  string p,s,t;

  if (defined(pname))
  { if (typeof(`pname`)=="proc")
    { p = string(`pname`);
      s = "\\begin{verbatim}" + newline;
      s = s + "proc " + pname + "(";
      i = find(p,"parameter");       // collecting the parameters
      while(i)
      { j=find(p,";",i);
        t = p[i+10,j-i-10];
        if(i>1){s = s + ",";};
        s = s + t;
        i = find(p,"parameter",j);
      }
      s = s + ")" + newline;
     j++;                      // skip one for the newline
     i = find(p,";RETURN();",j);  // j kann hier weg
     s = s + "{" + p[j,i-j-1] + "}" + newline;
     s = s + "\\end{verbatim}" + newline;
   }
  }
  else
  { print("--Error: No such proc defined");
    return();
  }
  if(size(fname))
  { i=1;
    while (fname[i]==">"){i++;}
    fname = fname[i,size(fname)-i+1];
    if (size(fname)>=4)        // check if filename is ending with ".tex"
    { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
    }
    else {fname = fname + ".tex";} 
    write(fname,s);
  }
  else{return(s);}      
}
example
{ "EXAMPLE:"; echo=2;
  proc exp(int i,int j,list #)
  { string s;

    if (size(#))
    {
     for(i;i<=j;i++)
     { s = s + string(j) + string(#); }
    }
   return(s);
  }
  export exp;
  texproc("","exp"); 
}

///////////////////////////////////////////////////////////////////////////////

proc texring(string fname, def r, list #) 
USAGE:   texring(fname, r[,l]); fname = string; r = ring;
                                l=list of strings : controls the symbol for
                                coefficint field etc. see example texdemo(); 
RETURN:  string, the ring in TeX-typesetting if fname == empty string;
         otherwise append this to file fname.tex; return nothing    
NOTE:    preceeding ">>" end ending ".tex" may miss in fname;        
EXAMPLE: example texring; shows an example
{ 
  int i,galT,flag,mipo,nopar,Dollars,TB,TA;
  string ob,cb,cf,en,s,t,savebrack; //opening bracket, closing br, coef.field
  intvec v;


  proc tvar(intvec v)
  { 
    int i,j,ldots;
    string s;
    
    j = 1;
    s = texpoly("",var(1));
    
    if (nvars(basering)==1) { return(s);}
    if (nvars(basering)==2) { return(s + "," + texpoly("",var(2)));}
    if (size(v)==1 and v[1] == 1)
       {return(s + ",\\ldots,"+ texpoly("",var(nvars(basering))));}
    if (v[1]==1 and size(v) >1) {j++;}

    for(i=2;i<nvars(basering);i++)
    { if (i<v[j]  and !(ldots))
      { s = s + ",\\ldots";
        ldots =1;
      }
      if (i== v[j]) 
      { s = s + "," + texpoly("",var(i));
        ldots =0;
        if (j< size(v)) {j++;}
      }
    }
   if (v[j]<nvars(basering)-1) { s = s + ",\\dotsc";}
   return(s + "," + texpoly("",var(nvars(basering))));
  }


  setring r;
  if (!(defined(NoDollars))){ Dollars = 1; int NoDollars; export NoDollars;}
  ob,cb = "[","]";
  if (find(ordstr(r),"s")) { ob,cb="\\{","\\}";}
  if(char(r)==0){cf="\\Q";}
  if(charstr(r)=="real"){cf="\\R";}
  if(char(r)==prime(char(r))){cf="\\Z_{"+string(char(r))+"}";}
  if(char(r)>0)
  { i = find(charstr(r),",");
    if(i)
    { t= charstr(r)[1,i-1];
      galT = (t <> string(char(r)));
      if (galT) { cf = "\\F_{"+ t + "}";}
    }
  }     // all other cases are cover already by char(r)=? prime(char)

  if (size(#))
  { if (typeof(#[1])=="list") { # = #[1];}
  } 
  for (i=1;i<=size(#);i++)
  { flag =0;
    if(typeof(#[i])=="string")
    {
     if(#[i][1]=="^" or #[i][1]=="_"){en=en+#[i];flag = 1;}
     if(#[i]=="mipo"){mipo=1; flag = 1;}
     if(#[i]=="{"){ob,cb="\\{","\\}";flag=1;}
     if(#[i]=="{{"){ob,cb="\\{\\{","\\}\\}";flag=1;}
     if(#[i]=="["){ob,cb="[","]";flag=1;}
     if(#[i]=="[["){ob,cb="[[","]]";flag=1;}
     if(#[i]=="<"){ob,cb="<",">";flag=1;}
     if(#[i]=="<<"){ob,cb="{\\ll}","{\\gg}";flag=1;}
     if(#[i]=="C"){cf="\\C";flag=1;}
     if(#[i]=="Q"){cf="\\Q";flag=1;}
     if((#[i]=="k" or #[i]=="K" or #[i]=="R") and !(galT))
                   {cf=#[i]; flag=1; nopar=1;}
     if (flag!=1) {cf = #[i];}  // for all the cases not covered here e.g Z_(p)
    }                           // or Q[i]

    if ((typeof(#[i])=="intvec") or
        (typeof(#[i])=="int")){v=#[i];}
   }
  s = cf;
  if (!(galT) and mipo and minpoly!=0) { s = s + "/" + texpoly("",minpoly);}
 // now the parameters
 // t;
  if(npars(r) and ((t==string(char(r))) or char(r)==0) and !(nopar))
  {
   s = s + "(";                      // !! mit ideal !!
   for(i=1;i<npars(r);i++) {s = s + texpoly("",par(i)) + ",";}
   s = s + texpoly("",par(npars(r))) + ")";
  }                               // paramters done
  s = s + ob;
  if (v!=0 and size(nvars(r))>3)
  { s = s + tvar(v);}
  else 
  { for(i=1;i<nvars(r);i++) {s = s + texpoly("",var(i)) + ",";}
    s = s + texpoly("",var(nvars(r)));
  } 
   s = s + cb + en;

  if (typeof(r)=="qring")
  { ideal @I = ideal(r);
    if (defined(TeXbrack)) 
    {
      TB =1; savebrack = TeXbrack; 
      if (TeXbrack!= "<" and TeXbrack!="(") { TeXbrack = "<";}
    }
    TA = defined(TeXaligned);
    if (!(TA)) { int TeXaligned; export TeXaligned; }
    t = texobj("",@I);
    @I;
    t;
    if (TB) { TeXbrack = savebrack;}
    if (!(TA)) { kill TeXaligned;}
    s = s + "/" + t;
  }

  if (Dollars) 
  { kill NoDollars;
    s =  "$" + s + "$";
  }
  if (size(fname))
  { i=1;
     while (fname[i]==">"){i++;}
     fname = fname[i,size(fname)-i+1];

     if (size(fname)>=4)           // check if filename is ending with ".tex"
     { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
     }
     else {fname = fname + ".tex";}
     write(fname,s);
  }
  else{return(s);}
} 
example
{ "EXAMPLE:"; echo=2;
  ring r0 = 0,(x,y,z),dp;       // short varnames polynomial ordering
  texring("",r0);
  ring r7 =0,(x(0..2)),ds;      // char =7, long varnames 
  texring("",r7);
  ring r1 = 0,(x1,x2,y1,y2),wp(1,2,3,4);
  texring("",r1);
  ring r2= 0,(x_10,x_11),M(1,2,3,4);
  texring("",r2);
  ring rr = real,(x),dp;        // real numbers
  texring("",rr);
  ring r;
  texring("",r); 
  ring rabc =(0,t1,t2,t3),(x,y),dp;  // parameters
  texring("",rabc);
  ring ralg = (7,a),(x1,x2),(ds,dp);  // algebraic extension
  minpoly = a2-a+3;
  texring("",ralg);
 // texring("",ralg,"mipo");
  ring r49=(49,a),x,dp;              // Galoisfield
  texring("",r49);  
  setring r0;
  ideal i = x2-z,xy2+1;
  qring q = std(i);
  q;
  texring("",q);
  // -------- additional features -------------
  ring r10 =0,(x(0..10)),dp;
  texring("",r10,1);
  ring rxy = 0,(x(1..5),y(1..6)),ds;
  intvec v = 5,6;
  texring("",rxy,v);
  texring("",r0,"C","{"); 
  texring("",ralg,"k");
  texring("",r7,"^G");
  list TeXreplace;
  TeXreplace[1] = list("x","\\xi");
  TeXreplace[2] = list ("t","\\lambda");
  export TeXreplace;
  texring("",rabc);
  texring("",r7);
  kill TeXreplace;
}

///////////////////////////////////////////////////////////////////////////////

proc rmx(string fname)
USAGE:   rmx(fname); fname = string
RETURN:  nothing; removes .log and .aux files associated to file <fname>      
         removes tex and xdvi file too, if suffix ".tex" or ".dvi" is given
NOTE:    if fname ends by .dvi or .tex 
         fname.dvi or fname.dvi and fname.tex will be deleted, too           
EXAMPLE: example rmx; shows an example
{
  int i,suffix= 1,0;

  while (fname[i]==">"){i++;}
  fname = fname[i,size(fname)-i+1];

  if (!(size(fname))) { return();}
  if (size(fname)>4))
  { if (fname[size(fname)-3,4]==".tex") { suffix = 2;}
    if (fname[size(fname)-3,4]==".dvi") { suffix = 1; }
    fname = fname[1,size(fname)-4];
  } 
  system("sh","rm " + fname + ".aux");
  system("sh","rm " + fname + ".log");
  if (suffix==2) {system("sh","\bin\rm -i " + ".tex");}
  if (suffix>=1) {system("sh","\bin\rm -i " + ".dvi");}
  return();
}
example
{ "EXAMPLE:"; echo =2;
  ring r;
  poly f = maxideal(7);
  opentex("exp001");              // defaulted latex2e document
  texobj("exp001","A polynom",f);
  closetex("exp001");
  tex("exp001");
  rmx("exp001");   // removes aux and log file of exp001

  opentex("exp002","tex");       // create a texdocument
  texobj("exp002","A polynom",f);
  closetex("exp002");
  tex("exp002","tex");
  rmx("exp002.tex");  // removes aux, log, dvi and tex file of exp002
  echo = 0;
  print("remaining files will be deleted after pressing <RETURN> ");
  pause;
  echo = 2;
  system("sh","rm -i exp00?.*");
}
///////////////////////////////////////////////////////////////////////////////

proc xdvi(string fname, list #)
USAGE:   xdvi(fname[,style]); fname,style = string
RETURN:  nothing; displays dvi-file fname.dvi with previewer xdvi
NOTE:    ending .dvi may miss in fname
         style overwrites the default setting xdvi
EXAMPLE: example xdvi ; shows an example
{
  int i=1;
  string default = "xdvi";            // may be changed appropriatly (C.G.)
  
  while (fname[i]==">") {i++;}
  fname = fname[i,size(fname)-i+1];

  if (size(fname)>=4)
  { if(fname[size(fname)-3,4]==".tex") {fname = fname[1,size(fname)-4];}}
  if (size(#)) {default = #[1];}
  "calling ",default, " for :",fname,newline;

  system("sh",default + " " +  fname + " &");
  return();
}
example
{ "EXAMPLE:"; echo = 2;
  ring r;
  ideal i = maxideal(7);
  opentex("exp001");              // defaulted latex2e document
  texobj("exp001","A ideal",i);
  closetex("exp001");
  tex("exp001");
  xdvi("exp001");
  echo = 0;
  print("the created files will be deleted after pressing <RETURN> ");
  pause;
  echo = 2;
  system("sh","rm -i exp00?.*");  
}
///////////////////////////////////////////////////////////////////////////////

proc texpoly(string fname,def p,list #)
{ 
  def @r = basering;

  poly f,monom;
  ideal I;
  number cfm;
  string sign,cfmt,pt,s,bg,t,monomt;
  string sep = newline;
  int i,b,b2,n, msz,linesz, count,k; 
  int realT, parT, galT;
  int C = 2 + defined(TeXdisplay);
   


  proc parsr(string s)                     // parse real
  { string t; 
                             
    if (s=="      Inf") { return("\\infty",3);}   
    if (s=="     -Inf") { return("\\-infty",6);}
    if (s[7]=="-"){t ="-";}
    if (s[8]<>"0"){t = t + s[8];}
    if (s[9]<>"0" or s[8]<>"0"){t = t + s[9];}
    if (size(t)) 
    { if (t=="1") {return(s[1,5]+"*10",21);}
      if (size(t)>1) {return(s[1,5]+"*10^{"+t+"}",21+2*size(t));}
      else {return(s[1,5]+"*10^"+t,23);}
    }
    else {return(s[1,5],12);}
  }

  proc parsg(string s)                  // parse Galoisfield
  { int i,j = 1,1;
    string t;
    
    if (short)
    { t =s[1]; 
     if(size(s)>1) {return(t+"^{" + s[2,size(s)-1] + "}",3+2*(size(s)-1));}
     else{return(t,5);}     
    }
    else
    { return(parselong(s+"!"));}
  }
  
  if (defined(TeXdisplay)) { bg = "& ";}
  if (!(defined(TeXwidth))) { int TeXwidth = -1; export TeXwidth;}
  if (typeof(p)=="poly" or typeof(p)=="number") {I = p;}
  if (typeof(p)=="ideal") 
  { I = p;
    if(size(#)){ sep = #[1];}
  }

  if (I==0) 
  { if (!(defined(NoDollars))){return("$0$");}
    else {return("0");}
  }

//--------------------- 


//------- set flags: --------------------------------------------------------
   
  if (size(#))
  { if (typeof(#[1])=="int") { linesz = #[1];}
 //   if (typeof(#[1])=="string") { linesz = #[1];}
  }

  parT = npars(@r);
  realT = (charstr(@r)=="real");
  i = find(charstr(@r),",");
  if (i)
  { t = charstr(@r)[1,i-1];
    galT = (t <> string(char(@r)));  // the char is not the same as the ...
  } 
  i = 0;
  
//------- parse the polynom
  pt = bg;
 
 for(k=1;k<=size(matrix(I));k++)
 { i = 0; linesz = 0; count =0;
   sign =""; 
   f = I[k];
   if (f==0) { pt = pt + "0";}
  while(f<>0)
  { count++; msz = 0;

// ------ tex the coefficient
    monom = lead(f);    
    f = f - monom;       
    cfm = leadcoef(monom);
    monom = monom/cfm;                  // the normalized monom
    s = string(monom) + "!";            // add an terminating sign
    cfmt = "";
    
    if (defined(TeXreplace)) { short =0;}  // this is essential
    cfmt = string(cfm);
    if (size(cfmt)>1)                   // check if sign is < 0
    { if (cfmt[2]=="-") { cfm = (-1) *cfm; sign = "-";}}
    if (cfmt[1] == "-") { cfm = (-1) * cfm; sign = "-";}
    if  (cfm!=1 or monom==1) {cfmt = string(cfm);}
    else {cfmt="";}

    if (defined(TeXwidth) and TeXwidth > 0 and TeXwidth <9 and count> TeXwidth)
    { pt = pt + sign + "\\dotsb"; break;}
   // ----------------------------------------  linesz ??

    if (size(cfmt))                            // parse the coefficient
    {
     monomt = cfmt;                   // (already a good choice for integers)
     msz = size(cfmt);

     if(realT) { monomt,msz = parsr(cfmt);}
     if (galT) { monomt,msz = parsg(cfmt);}
     b = find(cfmt,")/(");                     // look if fraction
     b2 = find(cfmt,"/");
     if (b) {b++;}
     n = size(cfmt);
     if (!(parT) and  !(realT) and !(galT))   
     { if( !(b2) or defined(TeXnofrac)) 
       {monomt = cfmt; msz = size(monomt);}
       else
       { monomt = "\\frac{" + cfmt[1,b2-1] + "}{" + cfmt[b2+1,n-b2] + "}";
          if (n-2*b2>0) {msz = C*(n-b2);}
          else {msz = C*b2;}
       }
     }
     if (parT and !(galT))
     { monomt,msz = parsp(cfmt,b);}
    }

// -- now parse the monom
    if (monom <> 1)
    { i = 1;    
      if(short)
      {                   while(s[i]<>"!")
        { monomt = monomt + s[i]; i++; 
          b = i;
          msz = msz + 3; //the was the single lettered var
          while(s[i]!="!" and s[i]>="0" and s[i]<="9"){i++;}
          if (i-b)
          { monomt = monomt + "^{" + s[b,i-b] + "}";
            msz = msz + 2*(i-b);
          }
        }
      }
      else          //  not short
      { t,i = parselong(s);
        monomt = monomt + t;
        msz = msz + i;
      }
    }
    


   if (TeXwidth > 10 and (linesz + msz > 2*TeXwidth) and linesz) {
   pt = pt + "\\\\" + newline +bg; linesz = 0; }
   else { linesz = linesz + msz; } 
   pt = pt + sign + monomt;
   sign = "+";
   monomt = "";
  }

  if (k<size(matrix(I))){ pt = pt + sep;}
 }

  if (not(defined(NoDollars))) { pt = "$"+pt+"$";}

  if (size(fname))
  { i=1;
    while (fname[i]==">"){i++;}
    fname = fname[i,size(fname)-i+1];

    if (size(fname)>=4)         // check if filename is ending with ".tex"
    { if(fname[size(fname)-3,4]!=".tex") {fname = fname +".tex"; }
    }
    else {fname = fname + ".tex";}
    write(fname,pt);
   }
  else {return(pt);}
}   
example
{ "EXAMPLE:"; echo =2;
  ring r0=0,(x,y,z),dp;
  poly f = -1x^2 + 2;
  texpoly("",f);
  texpoly("",2x2y23z);
  

  ring rr= real,(x,y),dp;

  ring r7= 7,(x,y,z),dp;
  poly f = 2x2y23z;
  texpoly("",f);
  ring rab =(0,a,b),(x,y,z),dp;
  poly f = (-2a2 +b3 -2)/a * x2y4z5 + (a2+1)*x + a+1;
  f;
  texpoly("",f);
}     

proc parsp(string cfmt, int b)
{ string mt, nom,denom;
  int fl1,fl2,sz1,sz2,msz;

  if (!(b))
  { mt,fl1 = parst(cfmt,0); msz = size(cfmt)-2;
    if (fl1) { mt = "(" + mt + ")"; msz = msz +1; }
  }
  else
  { nom,fl1 = parst(cfmt[1,b-1],1);
    denom,fl2 = parst(cfmt[b+1,size(cfmt)-b],1);
    if (defined(TeXnofrac))
    { if(fl1) { nom = "(" + nom + ")"; sz1++;}
      if(fl2) {denom = "(" + denom + ")"; sz2++;}
      mt = nom+ "/"+ denom; msz = sz1+sz2 +1;
    }
    else
    { mt = "\\frac{" + nom + "}{" + denom + "}";
      if (sz1-sz2) { msz = 5*sz1;}
      else {msz = 5*sz2;}
    }
   }
  return(mt,msz);
}
example
{"EXAMPLE:"; echo =2;
  ring r=(0,a,b),x,dp;
  int i;
  poly f = (a2b12 + 23a2 -b13-1)/(a2+2b -1);
  f;
  string s;
  s= string(f);
  i = find(s,")/(");
  parsp(s,i);
}

proc parst(string s,int sec)                // parse parameter
// sec parameter to see if in parsp a fraction follows
{ int i,j =1,-1;
  int b,k,jj,mz;                         // begin and end 
  int saveshort=short;
            string t,c,vn,nom,denom,sg;

  s = s[2,size(s)-2];    s = s + "!";

  if(defined(TeXreplace)){ short =0;}   // only then replacing works correctly
  if (short)
  { while(s[i]<>"!")
    { b=i; j++;
      while(s[i]>="0" and s[i]<="9" or (s[i]=="+" or s[i]=="-") and s[i]!="!")
      {i++;}     // scan the number 
        t =s[b,i-b];
    //  if (t=="-1" and s[i]!="!" and s[i]!="-" and s[i]!="+"){t = "-";}
      if (t=="-1" and (s[i]<="0" or s[i]>="9") and s[i]!= "/" and s[i]!="!")
       {
     t = "-";} 
      if (s[i]=="/")     
      { i++;
        sg = "";
        if (t[1]=="+" or t[1]=="-")
        { nom = t[2,size(t)-1];
          sg = t[1];
        }
        else { nom = t;}
        b =i; 
        while(s[i]>="0" and s[i]<="9") {i++;}
        denom = s[b,i-b];
        if (!(sec) and (!(defined(TeXaligned))))
        { t = sg + "\\frac{" + nom + "}{" + denom + "}";}
        else
        { t = sg + "(" + nom + "/" + denom + ")";
        }
      }  
      c = c + t;
      if(s[i]!="!"){c = c + s[i]; i++;}      // the parameter
      b=i;
      while(s[i]>="0" and s[i]<="9")
      {i++;}  //the exponent
     if(i-b){ c = c + "^{" + s[b,i-b]+"}";}
     }
   }
   else                         // if not short ....
   { while (s[i] <> "!") 
     { b=i; j++;
       while(s[i]=="-" or s[i]=="+" or (s[i]>="0" and s[i]<="9")){i++;}
       t = s[b,i-b];
       if (t=="-1" and s[i]=="*" ) {t="-";}
      if (s[i]=="/") 
      { i++;
        sg = "";
        if (t[1]=="+" or t[1]=="-")
        { nom = t[2,size(t)-1];
          sg = t[1];
        }
        else { nom = t;}
        b =i; 
        while(s[i]>="0" and s[i]<="9") {i++;}
        denom = s[b,i-b];
        if (!(sec) and (!(defined(TeXaligned))))
        { t = sg + "\\frac{" + nom + "}{" + denom + "}";}
        else
        { t = sg + "(" + nom + "/" + denom + ")";
        }
      }  
       c = c+t; t="";   
       if (s[i]=="*"){i++;} 
       b=i;
       while(s[i]!="+" and s[i]!="-" and s[i]!="!")  //pass a monom
       { // start with letters 
        // alternativ:
        while((s[i]>="a" and s[i]<="z") or (s[i]>="A" and s[i]<="Z")){i++;}
             k = i-b; 
        vn = s[b,k];
        if (defined(TeXreplace))
        { for (jj=1; jj<= size(TeXreplace);jj++) 
         { if (vn == TeXreplace[jj][1]) 
           {vn = TeXreplace[jj][2]; k=1;
             if (s[i]=="*") {vn = vn + " ";} 
            break;} //suppose replacing by a single sign
         }
        }
        t = t + vn;
        mz = mz + 10*k;
        if (s[i]=="_"  or s[i]=="(") { i++;}    // the index is coming
        b = i;
        while(s[i]>="0" and s[i]<="9"){ i++;}
        k = i-b;
        if (k){ t = t + "_{" +s[b,k] + "}";}
        if(s[i]==")") {i++;}
            if (s[i]=="^")
        { i++; b = i;
          while(s[i]>="0" and s[i]<="9"){ i++;} // for neg. expon.
          if (b-i) { t = t + "^{" + s[b,i-b] + "}";}
        }
          if (i-b > k) { mz = mz + 5*(i-b);}
        else {mz = mz + 5*k;}
       if (s[i]=="*"){i++;}
       b=i;
        }
      c =c+t;
      }
   }
  short = saveshort;
  return(c,j);
}
example
{ "EXAMPLE:"; echo =2;
  ring r=(0,a,b),x,dp;
  poly f = (a2b12 + 23a2 -b13-1);
  f;
  parst(string(f));
 
  f =(-a +4b2 -2);
  f;
  parst(string(f));
 
  f = a23;
  f;
  parst(string(f));
  f = 2a12b3 -4ab15 +2a4b12 -2;
  short =0;
  f;
  parst(string(f));
   ring r2=(0,a1,b1),x,dp;
  poly f = 2*a1^12*b1^3 -4*a1*b1^15 +2*a1^4*b1^12 -2;
  f;
  parst(string(f));
}


proc parselong(string s)
{ 
  int i,j,k,b,mz;
  string t,vn;              // varname
  
 // "s=" + s;
  i = 1; 
  while (s[i] <> "!") 
  { b=i;     
    
// -- scan now the letter ...

  //  while(s[i]!="!" and )

// alternativ:
 while((s[i]>="a" and s[i]<="z") or (s[i]>="A" and s[i]<="Z"))
 { i++;}
 // s[i]; i;
   k = i-b; 
   vn = s[b,k];

   if (defined(TeXreplace))
   { for (j=1; j<= size(TeXreplace);j++) 
     { if (vn == TeXreplace[j][1]) 
       {vn = TeXreplace[j][2]; k=1;
        if (s[i]=="*") {vn = vn + " ";} 
         break;} //suppose replacing by a single sign
     }
   }
   t = t + vn;
   mz = mz + 10*k;
   if (s[i]=="_"  or s[i]=="(") { i++;}    // the index is coming
   b = i;
   while(s[i]>="0" and s[i]<="9"){ i++;}
   j = i-b;
   if (j){ t = t + "_{" +s[b,j] + "}";}
   if(s[i]==")") {i++;}
   if (s[i]=="^")
   { i++; b = i;
     while(s[i]>="0" and s[i]<="9" or s[i]=="-")
     { i++;}  // for neg. expon.
     if (b-i) { t = t + "^{" + s[b,i-b] + "}";}
   }
   if (i-b > j) { mz = mz + 5*(i-b);}
   else {mz = mz + 5*j;}
   if (s[i]=="*"){i++;}
  }
  return(t,mz);
}
example
{ "EXAMPLE:"; echo =2;  
  ring r =(49,a),x,dp;
  number f = a13;
  parsg(string(f));
  list TeXreplace; export TeXreplace;
  TeXreplace[1] = list("b","\\beta");
  TeXreplace[2] = list("a","\\alpha");
  TeXreplace[3] = list("c","\\gamma"); 
  parselong(string(f)+"!");
}
///////////////////////////////////////////////////////////////////////////////

