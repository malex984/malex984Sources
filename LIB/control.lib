version="$Id: control.lib,v 1.6 2004-08-04 19:11:01 levandov Exp $";
category="System and Control Theory";
info="
LIBRARY:  control.lib Procedures for System and Control Theory 
AUTHORS:  Oleksandr Iena  yena@mathematik.uni-kl.de
@*        Markus Becker   mbecker@mathematik.uni-kl.de

SUPPORT: Forschungsschwerpunkt 'Mathematik und Praxis'


PROCEDURES:
declare(string NameOfRing, string Variables[,string  Parameters, string Ordering]);
Defining the ring, optional parametes are a string of parameters and a sting of ordering.
 
Print();                      Well-formatted output of lists, modules and matrixes
control(module R);            Computes everthing related to controllability
autonom(module R);            Computes everything related to autonomy(using Exts) 
autonom2(module R);           Computes everything related to autonomy(using dim) 
LeftKernel(module R);         Computing the left kernel of R
RightKernel(module R);        Computing the right kernel of R

Ext_Our(...)                  Copy of Ext_R from 'homolog.lib' in commutative case;
is_zero_Our(module R)         Copy of is_zero from 'OBpoly.lib';
LeftInverse(module R)         Computes left inverse of matrix(module)
static space(int n)           Procedure used inside the procedure 'Print' to have a better formatted output
static control_output();      Generating the output for the procedure 'control'
static autonom_output();      Generating the output for the procedure 'autonom' and 'autonom2'

";

LIB "homolog.lib"; 
LIB "poly.lib";
LIB "primdec.lib";
LIB "ncalg.lib";

//---------------------------------------------------------------
proc ncdetection( r)
//in dieser proc. wird eine matrix erzeugt, die in der i-ten zeile die 
indices 
//der differential-,shift- oder advance-operatoren enthaelt mit denen die 
i-te
//variable nicht kommutiert. 
{
  int i,j,k,LExp;
  int NVars=nvars(r);
  matrix rel = NCRelations(r)[2];
  intmat M[NVars][3];
  int NRows = nrows(rel);
  intvec v,w; 
  poly d,d_lead;
  ideal I;
  map theta;
 
  for( j=NRows;j>=2;j-- )
  {
   if( rel[j] == w )       //the whole column is zero
    {
      j--;
      continue;
    }
    
    for( i=1;i<j;i++ )         
    {
      if( rel[i,j]==1 )   //relation of type var(j)*var(i) = var(i)*var(j) +1
      {
         M[i,1]=j;
      }
      if( rel[i,j] == -1 ) //relation of type var(i)*var(j) = var(j)*var(i) -1
      {
        M[j,1]=i;
      }
      d = rel[i,j];
      d_lead = lead(d);
      v=leadexp(d_lead); 
//in the next lines we check whether we have 
//a relation of differential or shift type
      LExp=0;
      for( k=1;k<=NVars;k++)
      {
        LExp = LExp + v[k];
      }
      if( (d-d_lead != 0) || (LExp > 1) )
      {
        return( "wrong input" );
      }
      if( v[j] == 1)    //relation of type var(j)*var(i) = var(i)*var(j) -lambda*var(j)
      {
        if (leadcoef(d) < 0)
        {
          M[i,2] = j;
        }
        else
        {
          M[i,3] = j;
        }
      }
      if( v[i]==1 ) //relation of type var(j)*var(i) = var(i)*var(j) -lambda*var(i)
      {
        if (leadcoef(d) > 0)
        {
          M[j,2] = i;
        }
        else
        {
          M[j,3] = i;
        }
      }
    }
  }
  //ab hier wird die map ausgerechnet
  for(i=1;i<=NVars;i++)
  {
    I=I+var(i);
  }
  for(i=1;i<=NVars;i++)
  {
    if( M[i,1..3]==(0,0,0) )
    {
      i++;
      continue;
    }
    if( M[i,1]!=0 )
    {
      if( (M[i,2]!=0) && (M[i,3]!=0) )
      {
        I[M[i,1]] = -var(M[i,1]);
        I[M[i,2]] = var(M[i,3]);
        I[M[i,3]] = var(M[i,2]);
      }
      if( (M[i,2]==0) && (M[i,3]==0) )
      {
        I[M[i,1]] = -var(M[i,1]);
      }                  
      if( ( (M[i,2]!=0) && (M[i,3]==0) )|| ( (M[i,2]!=0) && (M[i,3]==0) ) 
)
      {
        I[i] = -var(i);
      }
    }
    else
    {
      if( (M[i,2]!=0) && (M[i,3]!=0) )
      {
        I[i] = -var(i);
        I[M[i,2]] = var(M[i,3]);
        I[M[i,3]] = var(M[i,2]);
      }
      else
      {
        I[i] = -var(i);
      } 
    }
  }
  theta = I;
  return(theta);
}
example
{ 
  "EXAMPLE:";echo = 2;
  ring r=0,(x,y,z,D(1..3)),dp;
  matrix D[6][6];
  D[1,4]=1;
  D[2,5]=1;
  D[3,6]=1;
  ncalgebra(1,D);
  ncdetection(r);
  kill r;
//------------------
  ring r=0,(x,S),dp;
  ncalgebra(1,-S);
  ncdetection(r);
  kill r;
//------------------
  ring r=0,(x,D(1),S),dp;
  matrix D[3][3];
  D[1,2]=1;
  D[1,3]=-S;
  ncalgebra(1,D);
  ncdetection(r);
}

proc invo_poly(poly m, map theta)
//applies the involution map theta to m, where m=polynomial
{
  int i,j;
  intvec v;
  poly p,z;
  poly n = 0;
  i = 1;
  while(m[i]!=0)
  {
    v = leadexp(m[i]);
    z =1;
    for(j=nvars(basering); j>=1; j--)
    {
      if (v[j]!=0)
      { 
        p = var(j); 
        p = theta(p);
        z = z*(p^v[j]);
      }
    }    
    n = n + (leadcoef(m[i])*z);
    i++;  
  }
  return(n);
}

proc involution(m, map theta)
//applies the involution map theta to m, where m=vector, polynomial,
//module,ideal
{
  int i,j;
  intvec v;
  poly p,z;
  if (typeof(m)=="poly")
  {
    return (invo_poly(m,theta));  
  }
  if ( typeof(m)=="ideal" )
  {
    ideal n;
    for (i=1; i<=size(m); i++)
    {
      n [i] = invo_poly(m[i],theta);
    } 
    return(n);
  }
  if (typeof(m)=="vector")
  {
    vector n=m;
    for(i=1; i<=size(m); i++)
    {
      n[i] = invo_poly(m[i],theta);
    }
    return (n);  
  }

  if ( (typeof(m)=="matrix") || (typeof(m)=="module"))
  {  
//    m=transpose(m);
    matrix n = matrix(m);
    int @R=nrows(n);
    int @C=ncols(n);
    for(i=1; i<=@R; i++)
    {
      for(j=1; j<=@C; j++)
      {
        n[i,j] = invo_poly( m[i,j], theta);
      }
    }
   }
  if (typeof(m)=="module")
  {
    return (module(n));
  }
  return(n);
}
example
{ 
  "EXAMPLE:";echo = 2;
  ring r = 0,(x,d),dp;
  ncalgebra(1,1); // Weyl-Algebra
  map F = r,x,-d;
  poly f =  x*d^2+d;
  poly If = involution(f,F);
  f-If;
  poly g = x^2*d+2*x*d+3*x+7*d;
  poly tg = -d*x^2-2*d*x+3*x-7*d;
  poly Ig = involution(g,F);
  tg-Ig;
  ideal I = f,g;
  ideal II = involution(I,F);
  II;
  I - involution(II,F);
  module M  = [f,g,0],[g,0,x^2*d];
  module IM = involution(M,F);
  print(IM);
  print(M - involution(IM,F));  
}



proc declare(string NameOfRing, string Variables, list #)
{
  if(size(#)==0)
  {
    execute("ring "+NameOfRing+"=0,("+Variables+"),dp;");
  }
  else
  {
    if(size(#)==1)
    {
      execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),dp;" );
    }
    else
    { 
      if( (size(#[1])!=0)&&(#[1]!=" ") )
      {
        execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),("+#[2]+");" );
      }
      else
      {
        execute( "ring " + NameOfRing + "=0,("+Variables+"),("+#[2]+");" ); 
      };
    };
  };
  keepring(basering);
  return();
};
example
{"EXAMPLE:";echo = 2;
  string v="x,y,z";
  string p="q,p";
  string Ord ="c,lp";
 
  declare("Ring_1",v);
  print(nameof(basering));
  print(basering);
  
  declare("Ring_2",v,p);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_3",v,p,Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_4",v,"",Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_5",v," ",Ord);
  print(basering);
  print(nameof(basering));
};
//
//maybe reasonable to add this in declare
//
//  print("Please enter your representation matrix in the following form: 
//  module R=[1st row],[2nd row],...");
//  print("Type the command: R=transpose(R)");
//  print(" To compute controllability please enter: control(R)");
//  print(" To compute autonomy please enter: autonom(R)");
//
//
//
//-------------------------------------------------------------------------
static proc space(int n)
//the procedure is used in the procedure Print to have a better formatted output
//USAGE:spase(int n)
//RETURN: string consisting of n spases
{
  int i;
  string s="";
  for(i=1;i<=n;i++)
  {
    s=s+" ";
  };
  return(s);
};
//-----------------------------------------------------------------------------
proc Print(M)
//procedure for a well-formatted output of lists, modules and matrixes
{
  if ( (typeof(M)=="module")||(typeof(M)=="matrix") )
  {
  int @R=nrows(M);
  int @C=ncols(M);
  int i;
  int j;
  list MaxLength=list();
  int Size=0;
  int max;
  string s;
  
  for(i=1;i<=@C;i++)
  { 
    max=0; 
    
    for(j=1;j<=@R;j++)
    {
      Size=size( string( M[j,i] ) );
      if( Size>max )
      {
        max=Size;
      };
    };
    MaxLength[i] = max;
  };
  
  for(i=1;i<=@R;i++)
  {
    s="";
    for(j=1;j<@C;j++)
    {
      s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) ) +",";
    };
    
    s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) );

    if (i!=@R)
    {
      s=s+",";
    };
    print(s);
  };

  return();    
  };
  
  if(typeof(M)=="list")
  {
    int sz=size(M);
    int i;
    for(i=1;i<=sz;i++)
    {
      Print(M[i]);
      print("");
    }; 

    return();
  };
  print(M);
  return();
};
//--------------------------------------------------------------------------
proc RightKernel(matrix M)
{ 
  return(syz(M));
}; 
//-------------------------------------------------------------------------
proc LeftKernel(matrix M)
{
  return( transpose( syz( transpose(M) ) ) );
};
//------------------------------------------------------------------------
proc LeftInverse(module M)
{
  int NCols=ncols(M);
  M=transpose(M);
  matrix I[NCols][NCols];
  I=I+1;
  module Id=I;
  return( module( transpose( lift( M,Id ) ) ) );
};
example
{"EXAMPLE:";echo =2;
  ring r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module R;
  R =  [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
       [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
       [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];
  R=transpose(R);
  module RK =RightKernel(R);
  RK = LeftInverse(RK);
  print(RK);
  };
//-----------------------------------------------------------------------
proc Ext_Our(int i, module R, list #)
//copy of Ext_R;
{
  if ( size(#)==0 )
  { 
    return( Ext_R(i,R) ); 
  }
  else
  {
    return( Ext_R(i,R,#[1]) );
  };
};
//------------------------------------------------------------------------
proc is_zero_Our(module R)
{
  return( is_zero(R) ) ;
};
//------------------------------------------------------------------------
static proc control_output(int i, int NVars, module R, module Ext_1) 
//in this procedure the output list with all the contollability properties of the system is generated
{
  int d=dim( std( Ann( transpose(R) ) ) ) ;;//this is the dimension of the system 
  string DofS= "dimension of the system:";
  string Fn= "number of first nonzero Ext:";
  if(i==1)
  { 
    module RK=RightKernel(R);
    return( 
            list ( Fn,
	           i,
	          "not controllable , image representation for controllable part:",
         	   RK,	    
	          "kernel representation for controllable part:",
		   LeftKernel( RK ),
		  "obstruction to controllability",
		   Ext_1,
		  "annihilator of torsion module(of obstruction to controllability)",
		   Ann(Ext_1),
		   DofS,
		   d
		 ) 
          );
  };
  
  if(i>NVars)
  { module RK =RightKernel(R); 
    return( list(  Fn,
                   -1, 
                  "strongly controllable, image representation:",
		   RK,
		  "left inverse to image representation:",
		   LeftInverse(RK),
		   DofS, 
		   d) 
          );
  };
  
  //
  //now i<=NVars
  //
       
  if( (i==2) )
  {
    return( list( Fn,
                  i, 
                 "controllable, not reflexive, image representation:",
		  RightKernel(R),
                  DofS,
                  d ) 
          ); 
  };
    
  if( (i>=3) )
  {
    return( list ( Fn,
                   i, 
                  "reflexive, not strongly controllable, image representation:",
		   RightKernel(R),
		   DofS,
		   d) 
          );
  };
              
  
};  
//-------------------------------------------------------------------------

proc control(module R)
//"Computes the controllability of a behaviour represented by the matrix R"
{
  int i;
  int NVars=nvars(basering); 
  int ExtIsZero;
 
       
  module Ext_1 = std(Ext_Our(1,R));
   
  ExtIsZero=is_zero_Our(Ext_1);
  i=1;
  while( (ExtIsZero) && (i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our( Ext_Our(i,R) );
  };
  
  return( control_output( i, NVars, R, Ext_1 ) );
};
example
{"EXAMPLE:";echo = 2; 
  //-------------------------------
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  Print( R );  
  Print( control(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  Print( Rc );
  Print( control(Rc) );
  kill r;
  //----------------------------------
  //reflector antenna
  ring A = (0, K1, K2, Te, Kp, Kc),(Dt, delta), dp;
  module R;
  R = [Dt, -K1, 0, 0, 0, 0, 0, 0, 0],
       [0, Dt+K2/Te, 0, 0, 0, 0, -Kp/Te*delta, -Kc/Te*delta, -Kc/Te*delta],
       [0, 0, Dt, -K1, 0, 0, 0, 0, 0],
       [0, 0, 0, Dt+K2/Te, 0, 0, -Kc/Te*delta, -Kp/Te*delta, -Kc/Te*delta],
       [0, 0, 0, 0, Dt, -K1, 0, 0, 0],
       [0, 0, 0, 0, 0, Dt+K2/Te, -Kc/Te*delta, -Kc/Te*delta, -Kp/Te*delta];
  R=transpose(R);
  Print(R);
  Print(control(R));
  kill A;
  //----------------------------------
  //Flexible Rod
  ring A = 0,(D1, delta), dp;
  module R;
  R = [D1, -D1*delta, -1],
      [2*D1*delta, -D1-D1*delta^2, 0];
  R=transpose(R);
  Print(R);
  Print(control(R));
  kill A;
  //-------------------------------------
  //TwoPendula
  ring r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module R;
  R =  [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
       [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
       [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];
  R=transpose(R);
  Print(R);
  Print(control(R));
  kill r;
  //----------------------------------------
  //Wind Tunnel
  ring A = (0,a, omega, zeta, k),(D1, delta),dp;
  module R;
  R = [D1+a, -k*a*delta, 0, 0],
      [0, D1, -1, 0],
      [0, omega^2, D1+2*zeta*omega, -omega^2];
  R=transpose(R);
  Print(R);
  Print(control(R));
  //-------------------------------------------

};
//------------------------------------------------------------------------
static proc autonom_output( int i, int NVars ) 
//in this procedure the output list with all the autonomy properties of the system is generated
{
  int d=NVars-i;//that is the dimension of the system
  string DofS="dimension of the system:";
  string Fn = "number of first nonzero Ext:";
  if(i==0)
  { 
    return( list(  Fn,
                   i,
                  "not autonomous",
		   DofS,
		   d ) 
	  );
  };
  
  if( i>NVars )
  {  
    return( list( Fn,
                  -1,
                  "trivial",
		  DofS,
		  d ) 
          );
  };
  
  //
  //now i<=NVars
  //
    
     
  if( i==1 )
  //in case that NVars==1 there is no sence to consider the notion
  //of strongly autonomous behavior, because it does not imply 
  //that system is overdetermined in this case
  {
    return( list ( Fn,
                   i, 
                  "autonomous, not overdetermined",
		   DofS,
		   d ) 
          ); 
  };
    
  if( i==NVars )
  {  
    return( list(  Fn,
                   i,
                  "strongly autonomous,in particular overdetermined",
		   DofS,
		   d) 
	  );
  };
  
  if( i<NVars )
  {
    return( list ( Fn,
                   i,
                  "overdetermined, not strongly autonomous",
		   DofS, 
		   d) 
          );
  };
    
};  
//--------------------------------------------------------------------------
proc autonom2(module R)
//analogue to autonom using dim calculations
{ 
  int d;
  int NVars = nvars(basering);
  R=transpose(R);
  d=dim( std( Ann(R) ) );
  return( autonom_output(NVars-d,NVars) );
};
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  Print( R );  
  Print( autonom2(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  Print( Rc );
  Print( autonom2(Rc) );
  kill r;
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  Print( R );
  Print( autonom2(R) );
  
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  Print( R );
  Print( autonom2(R) );
  kill r;
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  Print(R);
  Print(autonom2(R));	   
};  
//---------------------------------------------------------------------------

proc autonom(module R)
//"Computes the autonomy of a behaviour represented by the matrix R"
{
  int i;
  int NVars=nvars(basering);
  int ExtIsZero;
    
  
  R=transpose(R); 
  
  
  ExtIsZero=is_zero_Our(Ext_Our(0,R)); 
  
  i=0;
  while( (ExtIsZero)&&(i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our(Ext_Our(i,R));
  };
  
  return(autonom_output(i,NVars));
     
};
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  Print( R );  
  Print( autonom(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  Print( Rc );
  Print( autonom(Rc) );
  kill r;
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  Print( R );
  Print( autonom(R) );
  
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  Print( R );
  Print( autonom(R) );
  kill r;
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  Print(R);
  Print(autonom(R));	   
  
};  
//---------------------------------------------------------------------------
