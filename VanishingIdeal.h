#ifndef VANISHING_IDEAL_H
#define VANISHING_IDEAL_H

#ifdef HAVE_VANISHING_IDEAL

/* decide whether you want to have print-outs regarding
   information on the number of performed basic operations: */
#define PRINT_VANISHING_IDEAL_OPERATIONS 1

/**
  * A method for printing some information on
  * how to use this code.
  */
void usageVanishingIdealCode ();
/**
  * A method for running the algorithm for the direct generation of a strong Groebner
  * basis of the ideal of vanishing polynomials in the given ring. This ring is assumed to
  * be a polynomial ring with global ordering over Z/m for some m >= 2.<br>
  * The command returns the ideal generated by this strong Groebner basis.
  * @return the ideal generated by a strong GB of the ideal of vanishing polynomials
  */
ideal gBForVanishingIdealDirect ();
/**
  * A method for running the algorithm for the recursive generation of a strong Groebner
  * basis of the ideal of vanishing polynomials in the given ring. This ring is assumed to
  * be a polynomial ring with global ordering over Z/m for some m >= 2.<br>
  * The command returns the ideal generated by this strong Groebner basis which should be
  * the same as the result of <c>gBForVanishingIdealDirect</c>.<br>
  * With this algorithm, the Groebner basis will be constructed along the prime
  * factorization of m.
  * @return the ideal generated by a strong GB of the ideal of vanishing polynomials
  */
ideal gBForVanishingIdealRecursive ();
/**
  * A method for obtaining the normal form of a given polynomial f with respect to the
  * strong Groebner basis as computed by <c>gBForVanishingIdealDirect</c> or
  * <c>gBForVanishingIdealRecursive</c>.<br>
  * Note that this method does not explicitely generate the Groebner basis.
  * @param f a polynomial
  * @return the normal form of p w.r.t. a strong GB of the ideal of vanishing polynomials
  */
poly normalForm (const poly f);
/**
  * A method for obtaining the polynomial p(alpha, a) defined as follows.<br>
  * p(alpha, a) = a * (x(1) - 1) * (x(1) - 2) * ... * (x(1) - alpha_1) * ...<br>
  * ... * (x(2) - 1) * (x(2) - 2) * ... * (x(2) - alpha_2) * ...<br>
  * ... * (x(n) - 1) * (x(n) - 2) * ... * (x(n) - alpha_n),<br>
  * where alpha = (alpha_1, alpha_2, ..., alpha_n), and x(1), x(2), ..., x(n) are the
  * ring variables, i.e., n = number of ring variables.<br>
  * Each alpha_i is expected to be at least 0. If alpha_i = 0, then the factors
  * corresponding to x(i) are omitted in the above product.
  * @param alpha a multi-index of n natural numbers, where n = number of ring variables
  * @param a an element of the underlying coefficient ring Z/m
  * @return the polynomial p(alpha, a)
  */
poly p_alpha_a (const int* alpha, const int a);
/**
  * A method for computing the value of the Smarandache function
  * for the argument which is assumed to be at least 1.
  * For an integer m, m >= 1, the Smarandache function yields the
  * smallest natural number k such that m divies k!.
  * @param m a natural number >= 1
  * @return the value of the Smarandache function applied to m
  */
int smarandache (const int m); // expects m >= 1
/**
  * A method for checking whether a given polynomial f evaluates to zero for all
  * tuples of values. If so, true is returned, false otherwise.<br>
  * Instead of computing the normal form and checking whether it is zero, this command
  * makes use of an alternative algorithm first proposed by P. Kalla.
  * @param f a polynomial
  * @return true iff f is the zero function
  */
bool isZeroFunction (const poly f);
/**
  * A method for obtaining a value for each ring variable such that a given
  * polynomial does not evaluate to zero for this tuple.<br>
  * The tuple is returned as an array of ints with length = number of ring variables.<br>
  * If there is no such tuple, i.e., if f is the zero function, then all entris of
  * the returned array will be equal to -1.<br>
  * This algorithm works similar to Kalla's algorithm and may thus be used instead
  * of <c>isZeroFunction</c>.
  * @param f a polynomial
  * @return a tuple a values for which f does not evaluate to zero
  */
int* nonZeroTuple (const poly f);

#endif
/* HAVE_VANISHING_IDEAL */

#endif
/* VANISHING_IDEAL_H */
