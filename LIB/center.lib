///////////////////////////////////////////////////////////////////////////////
version="$Id: center.lib,v 1.17 2006-03-13 14:31:42 motsak Exp $"
category="Noncommutative"
info="
LIBRARY:  center.lib      computation of central elements of GR-algebras
AUTHOR:  Oleksandr Motsak,        motsak@mathematik.uni-kl.de.
OVERVIEW:
This is a library for computing the central elements and centralizers of elements in various non-commutative algebras.
Implementation is based on algorithms written in the frame of the diploma thesis by O. Motsak (adviser: Prof. S.A. Ovsienko, support: V. Levandovskyy), at Kyiv Taras Shevchenko University (Ukraine) with the title 'An algorithm for the computation of the center of a non-commutative polynomial algebra'.

SUPPORT: Forschungsschwerpunkt 'Mathematik und Praxis', University of Kaiserslautern

MAIN PROCEDURES:
CENTRALIZE_SET(F, V); computes a VS basis of the centralizer of F within V,
CENTRALIZER_VECTORSPACE(F, d); computes a VS basis of the centralizer of F up to degree D,
CENTRALIZER_SUBALGEBRA(F, D[, N]); computes a SA base of the centralizer of F up to degree D,
CENTER_VECTORSPACE(D); computes a VS basis of the center up to degree D,
CENTER_SUBALGEBRA(D[, k]); computes a SA base of the center up to degree D,

center(D[,k]); computes a SA generators of the center,
centralizer(S, D[, k]); computes a SA generators of the centralizer of S,

sa_reduce(V); 'subalgebra reduction' of a set of pairwise commuting polynomials,
sa_poly_reduce(p,V); 'subalgebra reduction' of a polynomial p wrt a set of pairwise commuting polynomials.

AUXILIARY PROCEDURES:
ApplyAd( Basis, f); Computes images of basis elements under the linear map Ad_{f},
KER(Images); Computes the kernel of a linear map given by its images on certain basis vectors,
LinearCombinations(Basis, C); computes linear combinations of Basis vectors with the coefficients from C,

inCenter(T); checks the centrality of polynomials of a list/ideal/poly T,
inCentralizer(T, S); checks whether polynomials of list/ideal/poly T commute with polynomials of S,
isCartan(p); checks whether polynomial p is a Cartan element,

standard_variables(); computes the set of algebra generators in their natural order,
sorted_variables(); computes the sorted set of algebra generators,

PBW_basis_byDeg( Deg ); computes monomials of a given degree Deg,
PBW_basis_byMaxDeg( MaxDeg ); computes monomials up to a given degree MaxDeg,
PBW_basis_byMaxMonom( MaxMonom ); computes monomials up to a given maximal monomial MaxMonom.

KEYWORDS:  center; centralizer; cartan; reduce; centralize; PBW
"

LIB "general.lib" // for "sort" 
LIB "poly.lib" // for "maxdeg" 


/******************************************************/
// ::DefaultStuff:: Shortcuts to useful short functions. Just to avoid if( if( if( ... ))).
/******************************************************/


/******************************************************/
static proc DefaultValue ( def s, list # ) // Process general variable parameters list
"
RETURN: s or (typeof(s))(#)
"
{
    def @p = s;
    if ( size(#) > 0 )
    {
        if ( typeof(#[1]) == typeof(s) )
        {
            @p = #[1];
        }
    }
    return( @p );
}

/******************************************************/
static proc DefaultInt( list # ) // Process variable parameters list with 'int' default value
"
RETURN: 0 or int(#)
"
{
    int @p = 0;
    return( DefaultValue( @p, # ) );
}

/******************************************************/
static proc DefaultIdeal ( list # ) // Process variable parameters list with 'ideal' default value
"
RETURN: 0 or ideal(#)
"
{
    ideal @p = 0;
    return( DefaultValue( @p, # ) );
}



/******************************************************/
// ::Debug:: Shortcuts to used debugging functions.
/******************************************************/


/******************************************************/
static proc toprint( int pl ) // To print or not to print?!? The answer is here!
"
RETURN: 1 means to print, otherwise 0.
"
{
    return( printlevel >= ( 3 -  pl) ); // voice + ?
}

/******************************************************/
static proc DBPrint( int pl, list # ) // My 'dbprint' which uses toprint(i).
"
    USAGE:     
"
{
    if( toprint(pl) )
    {
        dbprint(1, #);
    }
}

/******************************************************/
static proc BCall( string Name, list # ) // This function must be called at the beginning of every 'mathematical' function.
"
USAGE: Name is a name of a mathematical function to trace. # means parameters into the function.
"
{
    if( toprint(0) )
    {
        "CALL: ", Name, "( "; 
        dbprint(1, #);
        "     )";
    }
}

/******************************************************/
static proc ECall(string Name, list #) // This function must be called at the end of every 'mathematical' function.
"
USAGE: Name is a name of a mathematical function to trace. # means result of the function.
"
{
    if( toprint(0) )
    {
        "RET : ", Name, " => Result: {";
        dbprint(1, #);
        "    }";
    }
}



/******************************************************/
// ::Helpers:: Small functions used in this library.
/******************************************************/

/******************************************************/
static proc makeNice( def l )
"
RETURN: the same as input
PURPOSE: make 'nice' polynomials, kill scalars
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "makeNice", l ); }; /*4DEBUG*/

    poly p;
    
    if( typeof(l) == "poly" )
    {
        // "normal" polynomial form == no denominators, gcd of coeffs is a unit
        p = cleardenom( l );
        l = cleardenom( p / leadcoef(p) );
    } else
    {
        if( typeof(l) == "ideal" )
        {
            for( int i = 1; i <= size(l); i++ )
            {   
                p = l[i];
        
                // Now make polynomials look nice:
                if ( deg(p) > 0 ) // throw away scalars!
                {
                    // "normal" polynomial form == no denominators, gcd of coeffs is a unit
                    p = cleardenom( p );
                    l[i] = cleardenom( p / leadcoef(p) );
                } else
                {
                    l[i] = 0;
                }
            }
            
            l = simplify(l, 2 + 8);
        }
    }

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "makeNice", l ); }; /*4DEBUG*/
    return( l );
}



/******************************************************/
static proc monomialForm( def p )
"
: p is either poly or ideal
RETURN: polynomial with all monomials from p but without coefficients.
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "monomialForm", p ); }; /*4DEBUG*/

    poly result = 0; int k, j; poly m;
    
    if( typeof(p) == "ideal" ) //
    {
        if( ncols(p) > 0 )
        {
            result = uni_poly( p[1] );
        
            for ( k = ncols(p); k > 1; k -- )
            {            
                for( j = size(p[k]); j > 0; j-- )
                {
                    m = leadmonom( p[k][j] );
                    
                    if( size(result + m) > size(result) ) // trick!
                    {
                        result = result + m;
                    }
                }
                
            }
        }
    }
    else
    {
        if( typeof(p) == "poly" ) //
        {
            result = uni_poly(p);
        } else
        {
            ERROR( "ERROR: Wrong input! Expected polynomial or ideal!" );
        }
    }
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "monomialForm", result ); }; /*4DEBUG*/
    return( result );
}

/******************************************************/
static proc uni_poly( poly p )
"
    returns polynomial with the same monomials but without coefficients.
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "uni_poly", p ); }; /*4DEBUG*/

    poly result = 0;
    
    for ( int k = size(p); k > 0; k -- )
    {
        result = result + leadmonom( p[k] );
    }
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "uni_poly", result ); }; /*4DEBUG*/
    return( result );
}





/******************************************************/
static proc smoothQideal( ideal I, list #)
"
PURPOSE: smooths the ideal in a current QUOTIENT(!) ring.
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "smoothQideal", I ); }; /*4DEBUG*/
    
    ideal A = NF( I, twostd(DefaultIdeal(#)), 1 );
    
    ideal D = I - A;
    
    if( size(D) > 0 ) // Were there any changes???
    {
        ideal T = ideal(); int j = 1;
    
        for( int i = 1; i <= ncols(I); i++ )
        {
            if( size(D[i]) == 0 ) // keep only unchanged elements
            {
                T[ j ] = I[i]; j++;
            }
        }
        
        kill A;
        
        ideal A = T;
        
        kill T;
    }
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "smoothQideal", A ); }; /*4DEBUG*/
    
    return( A );    
}




/******************************************************/
// ::PBW:: PBW basis construction.
/******************************************************/




/******************************************************/
proc PBW_basis_byMaxDeg( int MaxDeg )
"USAGE: PBW_basis_byMaxDeg(MaxDeg); int MaxDeg
PURPOSE: Compute the PBW basis (up to a given maximal degree) of a current algebra.
RETURN: ideal consisting of PBW elements.
NOTE: unit is omitted. Weights are ignored!
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "PBW_basis_byMaxDeg", MaxDeg ); }; /*4DEBUG*/
    
    ideal Basis = ideal();
    
    for (int k = 1; k <= MaxDeg; k ++ )
    {
        ideal T = Basis + maxideal(k); kill Basis; ideal Basis = T; kill T; // ?
    }
    
    ideal T = smoothQideal( Basis ); kill Basis;
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "PBW_basis_byMaxDeg", T ); }; /*4DEBUG*/
    return( T );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(e,f,h),dp;
matrix D[3][3]=0;
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is U(sl_2)

// PBW Basis of A_2 - monomials of degree <= 2, without unit:
PBW_basis_byMaxDeg( 2 ); 
}


/******************************************************/
proc PBW_basis_byDeg( int Deg )
"USAGE: PBW_basis_byDeg(Deg); int Deg
PURPOSE: Compute the PBW basis (of a given degree) of a current algebra.
RETURN: ideal consisting of PBW elements.
NOTE: Unit is omitted. Weights are ignored!
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "PBW_basis_byDeg", Deg ); }; /*4DEBUG*/
    
    ideal Basis = smoothQideal( maxideal( Deg ) );
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "PBW_basis_byDeg", Basis ); }; /*4DEBUG*/
    return( Basis );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(e,f,h),dp;
matrix D[3][3]=0;
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is U(sl_2)

// PBW Basis of A_2 \ A_1 - monomials of degree == 2:
PBW_basis_byDeg( 2 ); 
}


/******************************************************/
proc PBW_basis_byMaxMonom( poly MaxMonom )
"USAGE: PBW_basis_byMaxMonom(m); poly m
PURPOSE: Compute the PBW basis, up to a given maximal exponent, of a current algebra.
INPUT: Maximal exponent is given by the corresponding monomial.
RETURN: ideal consisting of PBW elements.
NOTE: Unit is omitted. Weights are ignored!
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "PBW_basis_byMaxMonom", MaxMonom ); }; /*4DEBUG*/
    
    ideal K = ideal();
    
    intvec exp = leadexp( MaxMonom );
    
    for ( int k = 1; k <= size(exp); k ++ )
    {
        K[ 1 + size(K) ] = var(k)^( 1 + exp[k] );
    }
    
    attrib(K, "isSB", 1);
    
    ideal Basis = kbase( K );
    
    kill K;
    
    ideal K = Basis[ (ncols(Basis)-1)..1]; // reverse, kill last 1
    
    kill Basis;
    
    ideal T = smoothQideal( K ); kill K;

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "PBW_basis_byMaxMonom", T ); }; /*4DEBUG*/
    
    return( T );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(e,f,h),dp;
matrix D[3][3]=0;
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is U(sl_2)

// At most 1st degree in e, h and at most 2nd degree in f, unit is omitted:
PBW_basis_byMaxMonom( e*(f^2)* h ); 
}




/******************************************************/
// ::CORE:: Core procedures...
/******************************************************/



/******************************************************/
proc ApplyAd( ideal I, poly p )
"
USAGE: ApplyAd( Basis, f); ideal Basis, poly f
PURPOSE: Apply Ad_{f} to every element of Basis
RETURN: ideal, Ad_{f}(Basis)
SEE ALSO:   KER; LinearCombinations
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "ApplyAd", I, p ); }; /*4DEBUG*/

    poly t;

    ideal II = ideal();

    for ( int k = ncols(I); k > 0; k --)
    {
        t = I[k];
        II[k] = p * t - t * p; // we have to reduce smooth images in Qrings...
    }
    
    ideal J = NF( II, twostd(0) ); // ... now!
    
    kill II;
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "ApplyAd", J ); }; /*4DEBUG*/
    return( J );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(e,f,h),dp;
matrix D[3][3]=0;
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is U(sl_2)

// Let us consider the linear map Ad_{e} from A_2 into A.

// Compute the PBW basis of A_2:
ideal Basis = PBW_basis_byMaxDeg( 2 ); Basis;

// Compute images of basis elements under the linear map Ad_e:
ideal Image = ApplyAd( Basis, e ); Image;

// Now we have a linear map given by: Basis_i --> Image_i
// Let's compute its kernel:
module C = KER( Image ); C;

// Now we can compute the kernel of Ad_e by means of basis vectors:
ideal K = LinearCombinations(Basis, C); K;

// Let's check that Ad_e(K) is zero:
ApplyAd( K, e );
}



/******************************************************/
proc KER( ideal Images )
"USAGE: KER( Images ); ideal Images
PURPOSE: Computes the kernel of a linear map given by its images on certain basis vectors
RETURN: syzygy module, or 0 if all images are zeroes
SEE ALSO:   ApplyAd; LinearCombinations
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "KER", Images ); }; /*4DEBUG*/

    // This must be a list of monomials in a form of polynomial (sum with coeffs == 1)    
    poly Monomials = monomialForm( Images ); 

    int N = size( Monomials ); // number of different monomials   
    
    if ( N == 0 ) // & ncols( Images ) > 0 => all Images == 0
    {
        int result = 0;
        
/*4DEBUG*/        if( defined( @@@DEBUG ) ){ ECall( "KER", result ); }; /*4DEBUG*/
        return( result );
    }

    // Compute matrix MD
    module MD; // zero

    int x, y;
    
    vector w;
    
    poly p, m;
    
    int V = ncols(Images); // must be equal to ncols(Basis) and size(Basis)!
    
    // We take monomials as vector space basis of <Image>_k...
    
    // TODO: Is there any other way to compute a basis of it and represent images as 
    // linear combination of them???
    
    // Maybe some 'free resolution' stuff??? But we need linear maps only!!!
    
    for ( x = 1; x <= V; x++ ) // For every Image vector
    {
        w = 0; 
        
        
        p = Images[x];
        
        y = 1; // from 1st monomial in Monomials...
        
        while( size(p) > 0 )
        {
            m = leadmonom(p);
            
            // y < N!
            while( Monomials[y] != m ) 
            // There MUST be this monomial because of the construction of Monomials polynomial!
            {
                y++; // to size()
            }
            
            // found monomial m at position y.
            
            w = w + leadcoef(p) * gen(y); // leadcoef(p) MUST be nonzero!
            p = p - lead(p); // kill lead term            
        }
        
        MD[x] = w;
    }
    
    /*******************************************/
    
    // save options
    intvec v = option( get );
    
    // set right options
    option( redSB );
    option( redTail );
    
    // compute everything in a right form
    module KER = simplify( std( syz(MD) ), 1 + 2 + 8 ); 
    // note that MD is a matrix of numbers - no polynomials... 
    
    // restore options
    option( set, v ); 
    
    // kill used structure       
    kill MD; 
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "KER", KER ); }; /*4DEBUG*/

    return( KER );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(e,f,h),dp;
matrix D[3][3]=0;
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is U(sl_2)

// Let us consider the linear map Ad_{e} from A_2 into A.

// Compute the PBW basis of A_2:
ideal Basis = PBW_basis_byMaxDeg( 2 ); Basis;

// Compute images of basis elements under the linear map Ad_e:
ideal Image = ApplyAd( Basis, e ); Image;

// Now we have a linear map given by: Basis_i --> Image_i
// Let's compute its kernel:
module C = KER( Image ); C;

// Now we can compute the kernel of Ad_e by means of basis vectors:
ideal K = LinearCombinations(Basis, C); K;

// Let's check that Ad_e(K) is zero:
ideal Z = ApplyAd( K, e ); Z;

// Now KER will return a single integer 0:
def CC  = KER(Z); typeof(CC); CC;
}


/******************************************************/
proc LinearCombinations( ideal Basis, module KER )
"
USAGE:  LinearCombinations( Basis, C ); ideal Basis, module C
PURPOSE: computes linear combinations of Basis vectors with the coefficients from C.
RETURN: ideal of linear combinations of Basis vectors with the coefficients from C.
SEE ALSO:   KER; ApplyAd
"
{
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "LinearCombinations", Basis, KER ); }; /*4DEBUG*/


    number c;    
    
    int x, y; 
    
    vector w;
    
    poly p;
    
    ideal result = ideal();
    
    // Kernel' basis translation
    for ( x = 1; x <= ncols(KER); x++ )
    {
        p = 0;
        w = KER[x];
        
        for ( y = 1; y <= nrows(w); y++ )
        {
            c = leadcoef( w[y] );

            if ( c != 0 )
            {
                p = p + c * Basis[y]; // linear combination of base vectors { Basis[y] }
            }
        }
        
        result[ 1 + size(result) ]  = p;
    }
    
    // no reduction in quotient algebras is needed. No multiplications were done!
    
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "LinearCombinations", result ); }; /*4DEBUG*/
    
    return( result );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(e,f,h),dp;
matrix D[3][3]=0;
D[1,2]=-h;  D[1,3]=2*e;  D[2,3]=-2*f;
ncalgebra(1,D); // this algebra is U(sl_2)

// Let us consider the linear map Ad_{e} from A_2 into A.

// Compute the PBW basis of A_2:
ideal Basis = PBW_basis_byMaxDeg( 2 ); Basis;

// Compute images of basis elements under the linear map Ad_e:
ideal Image = ApplyAd( Basis, e ); Image;

// Now we have a linear map given by: Basis_i --> Image_i
// Let's compute its kernel:
module C = KER( Image ); C;

// Now we can compute the kernel of Ad_e by means of basis vectors:
ideal K = LinearCombinations(Basis, C); K;

// Let's check that Ad_e(K) is zero:
ApplyAd( K, e );
}



/******************************************************/
static proc LINEAR_MAP_KERNEL(ideal Basis, ideal Images ) // Ker of the linear map given by its values on basis vectors
"
PURPOSE: Computation of the kernel basis of the linear map given by the list @given
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "LINEAR_MAP_KERNEL", Basis, Images ); }; /*4DEBUG*/
    
    ideal result = ideal(); 
    
    if ( size( Basis ) == 0 )
    {
/*4DEBUG*/        if( defined( @@@DEBUG ) ){ ECall( "LINEAR_MAP_KERNEL", result ); }; /*4DEBUG*/
        return( result );
    }
    
    // compute fundamental solutions system
    def T = KER( Images );
    
    
    // check result of KER
    if( (typeof(T) == "int") and (T == 0) )
    {
        // All zeroes! Return Basis:
/*4DEBUG*/        if( defined( @@@DEBUG ) ){ ECall( "LINEAR_MAP_KERNEL", Basis ); }; /*4DEBUG*/
        return( Basis );
    } 
    else
    {
        if( typeof(T) != "module" )
        {
            ERROR( "Wrong output from the 'KER' function!" );
        }    
    }
    
    result = LinearCombinations( Basis, T );
    
    kill T;

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "LINEAR_MAP_KERNEL", result ); }; /*4DEBUG*/
    return( result );
}


/******************************************************/
static proc ZeroKer( ideal Basis, ideal Images ) // VS Basis of a Kernel of the linear map AD_h, h is a Cartan element
"
PURPOSE: Computes VS Basis of a Kernel of the linear map AD_h, when h is a Cartan element
NOTE: the result is a set of all basis vectors having a zero image
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "ZeroKer", Basis, Images ); }; /*4DEBUG*/

    ideal result = ideal();

    for( int i = 1; i <= ncols( Basis ); i++ )
    {
        if( size( Images[i] ) == 0 ) // zero image?
        {
            result[ 1 + size(result) ] = Basis[i]; // take this basis vector!
        }
    }
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "ZeroKer", result ); }; /*4DEBUG*/
    return( result );
}




/******************************************************/
// ::Variables:: Computes a set of variables
/******************************************************/



/******************************************************/
proc standard_variables() // Returns an ideal of variables in a current base ring.
"USAGE:      standard_variables();
RETURN:     ideal, generated by algebra variables
PURPOSE:    computes the ideal generated by algebra variables taken in their natural order
SEE ALSO:   sorted_variables
EXAMPLE:    example standard_variables; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "standard_variables" ); }; /*4DEBUG*/

    ideal result = maxideal(1);

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "standard_variables", result ); }; /*4DEBUG*/
    return( result );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;  D[1,3]=2*x;  D[2,3]=-2*y;
ncalgebra(1,D); // this algebra is U(sl_2)
// Variables in their natural order:
standard_variables(); 
}

/******************************************************/
proc sorted_variables() // Sorts variables into an ideal. This is a kind of heuristics!
"USAGE:      sorted_variables();
RETURN:     ideal, generated by sorted algebra variables
PURPOSE:    computes the ideal generated by algebra variables sorted so that Cartan variables are first and all other variables are behind.
NOTE:       This is a heuristics for the computation of center: it is better to compute centralizers of Cartan variables first since we can omit solving the system of equations. 
SEE ALSO:   standard_variables
EXAMPLE:    example sorted_variables; shows an example
"{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "sorted_variables" ); }; /*4DEBUG*/

    ideal V   = standard_variables();
    int  N    = size( V ); // == nvars( basering )

    ideal result;

    int  r_begin = 1;
    int  r_end   = N;

    poly v;

    for( int k = 1; k <= N; k++ )
    {
        v = V[k];

        if( isCartan(v) == 1 ) // Cartan elements go 1st
        {
            result[r_begin] = v;
            r_begin++;
        } else // Other - in the end...
        {
            result[r_end] = v;
            r_end--;
        }
    }

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "sorted_variables", result ); }; /*4DEBUG*/
    return( result );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;  D[1,3]=2*x;  D[2,3]=-2*y;
ncalgebra(1,D); // this algebra is U(sl_2)
// There is only one Cartan variable - z in U(sl_2), 
// it must go 1st:
sorted_variables(); 
}





/******************************************************/
/******************************************************/
// ::BasicCentralizerComputation:: Basic functions for centralize' computation.
/******************************************************/
/******************************************************/





/******************************************************/
proc CENTRALIZE_SET( ideal F, ideal V ) // HL 'core' function
"USAGE:      CENTRALIZE_SET( F, V ); ideal F, ideal V
INPUT:       a finite set of elements F, vector space basis V
RETURN:     ideal, generated by base elements
PURPOSE:    computes the vector space basis of the centralizer of F in the vector space spanned by V, that is, Cen(F[N],Cen(F[N-1],...,Cen(F[1],V)...))
SEE ALSO:   CENTRALIZER_VECTORSPACE; centralizer; inCentralizer
EXAMPLE:    example CENTRALIZER_VECTORSPACE; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "CENTRALIZE_SET", F, V ); }; /*4DEBUG*/

    int  N = size(F);

    if( N == 0)
    {
        ERROR( "F MUST be non empty!!!" );
    }
    
    DBPrint(1, "BasisSize: " + string(size(V)) );
    
    for( int v = 1; (v <= N) and (size(V) > 0); v++ )
    {
        DBPrint(1, "Centralizing " + string(F[v]) );
        
        //
        ideal Images = ApplyAd( V, F[v] ); 
        
        ideal K;        
        if( (isCartan(F[v]) == 1) or (size(V) == 1) ) 
        {
            K = ZeroKer( V, Images );
        } else
        {
            K = LINEAR_MAP_KERNEL( V, Images );
        }
        
        kill Images;        
        kill V; ideal V = K; kill K;
        
        // Printing...
        DBPrint(1, "Progress: [ " + string(v) + " / " + string(N) + " ]"+
                   " => BasisSize: " + string(size(V)) );        
    }
    
    ideal result = makeNice(V); kill V;
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "CENTRALIZE_SET", result ); }; /*4DEBUG*/
    
    return( result );
}
example
{
"EXAMPLE:"; echo = 2;
 ring A_4_1 = 0,(e(1..4)),dp;
 matrix D[4][4]=0;
 D[2,4] = -e(1);
 D[3,4] = -e(2);
 // This is $A_{41}$ - the first real Lie algebra of dimension $4$.
 ncalgebra(1,D); 
  
 ideal F = sorted_variables(); F;
 
 // if we know that the center of $A_{41}$ is generated by 
 // $e(1)$ and $-1/2*e(2)^2+e(1)*e(3)$ 
 // therefore one may consider computing it in the following way:
 
 // 1. Compute PBW basis consisting of 
 //    monomials of exponent <= (1,2,1,0)
 ideal V = PBW_basis_byMaxMonom( e(1) * e(2)^ 2 * e(3) ); 
 
 // 2. Compute the centralizer of F within vector space 
 //    spanned by these monomials:
 ideal C = CENTRALIZE_SET( F, V ); C;
 
 inCenter(C);
}



/******************************************************/
proc CENTRALIZER_VECTORSPACE( ideal F, int d )
"USAGE:      CENTRALIZER_VECTORSPACE( F, D ); ideal F, int D
RETURN:     ideal, generated by elements of degree <= D
PURPOSE:    computes a vector space basis of the centralizer of F up to degree D.
NOTE:       D must be non-negative
SEE ALSO:   CENTER_VECTORSPACE; centralizer; inCentralizer
EXAMPLE:    example CENTER_VECTORSPACE; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "CENTRALIZER_VECTORSPACE", F, d ); }; /*4DEBUG*/
    
    if( size(F) == 0)
    {
        ERROR( "F MUST be non-empty!!!" );
    } 

    ideal V = PBW_basis_byMaxDeg( d ); // PBW basis
    
    ideal result = CENTRALIZE_SET( F, V ); // basis of the Centralizer of S in VS <V>
    
    kill V;

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "CENTRALIZER_VECTORSPACE", result ); }; /*4DEBUG*/
    
    return( result );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;  D[1,3]=2*x;  D[2,3]=-2*y;
ncalgebra(1,D); // this algebra is U(sl_2)
ideal F = x, y;
// find all elements commuting with x and y of degree <= 4:
ideal C = CENTRALIZER_VECTORSPACE(F, 4); 
C; 
inCentralizer(C, F);
}




/******************************************************/
// ::CenterAliases:: Basic functions/aliases for center' computation.
/******************************************************/




/******************************************************/
proc CENTER_VECTORSPACE( int D )
"USAGE:      CENTER_VECTORSPACE( D ); int D
RETURN:     ideal, generated by elements of degree <= D
PURPOSE:    computes a vector space basis of the center of the current algebra up to degree D.
NOTE:       D must be non-negative
SEE ALSO:   CENTRALIZER_VECTORSPACE; center; inCenter
EXAMPLE:    example CENTER_VECTORSPACE; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "CENTER_VECTORSPACE", D ); }; /*4DEBUG*/


    if( nameof( basering ) == "basering" )
    {
        ERROR( "No current ring!" );
    }
    
    if( D < 0 )
    {
        ERROR( "Degree D must be non-negative!" );
    }
    
    ideal result = CENTRALIZER_VECTORSPACE( sorted_variables(), D );
     
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "CENTER_VECTORSPACE", result ); }; /*4DEBUG*/

    return( result );
}
example
{
 "EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;  D[1,3]=2*x;  D[2,3]=-2*y;
ncalgebra(1,D); // this algebra is U(sl_2)
// find all central elements of degree <= 4
ideal Z = CENTER_VECTORSPACE(4); 
Z; 
// note that the second element is the square of the first 
// plus the multiple of the first:
Z[2] - Z[1]^2 + 8*Z[1];
inCenter(Z);
}


/******************************************************/
proc CENTRALIZER_SUBALGEBRA( ideal F, int D, list # )
"USAGE:      CENTRALIZER_SUBALGEBRA( F, D[, N] ); ideal F, int D[, int N]
RETURN:     ideal, generated by computed generators
PURPOSE:    if N is absent and D >= 0 computes a subalgebra generators of the centralizer of F up to degree D, otherwise if N is present computes N(at least) first generators of the centralizer, if moreover D > 0 it will be used as the first maximal degree estimation.
NOTE:       Current ordering must be a degree compatible well-ordering.
SEE ALSO:   CENTRALIZER_VECTORSPACE; CENTER_SUBALGEBRA; centralizer; inCentralizer
EXAMPLE:    example CENTRALIZER_SUBALGEBRA; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "CENTRALIZER_SUBALGEBRA", F, D, # ); }; /*4DEBUG*/
    
    if( nameof( basering ) == "basering" )
    {
        ERROR( "No current ring!" );
    }    
    
    if( size(F) == 0)
    {
        ERROR( "F MUST be non-empty!!!" );
    } 
    
    def NCRING = basering; // Non-commutative ring
    list L = ringlist( NCRING );
    def L1, L2, L3, L4 = L[1..4]; // General components    
    def COMMRING = ring( list( L1, L2, L3, L4 ) ); // Underlying commutative ring
    kill L1, L2, L3, L4, L;   
    
    
    int k = DefaultInt(#);
    
    
    int m = (k > 0);
        
    int MinDeg = 6; // starting guess for Maximal Bounding Degree, 6
    int Delta  = 4; // increment of it, 4
        
    if( m and (D <= 0) )
    {
        // minimal guess
        D = MinDeg;
    }
    
    if( !m and D < 0)
    {
        ERROR("Wrong bounding condition!");
    }
    
    ideal result = ideal();
    
    int i, j, l, d;
    
    // we keep the list of found leading monomials in the commutative ring!
    setring COMMRING;
    
    // Init
    list FOUND_LEADING_MONOMIALS = list();
        
    for( i = 1; i <= D; i++ )
    {
        FOUND_LEADING_MONOMIALS[i] = ideal();
    }
    
    setring NCRING;
    
    // Main loop:
    i = 1;
    
    ideal PBW = ideal();
    ideal NEW;
    
    while( i <= D )
    {
        DBPrint( 1, "Current degree is " + string(i) );
        
        // Compute current "reduced" PBW basis...
        
        // Prepare current found leading monomials
        setring COMMRING;
        
        if( defined(FLM) )
        {
            kill FLM;
        }
        
        ideal FLM = FOUND_LEADING_MONOMIALS[i];

        // And back to NCRing
        setring NCRING;
        
        
        // just to avoid "no standard basis" warning.
        ideal FLM = imap(COMMRING, FLM);
        attrib(FLM, "isSB", 1);

        // degrees should not change
        // no monomials should be multiplied here
        ideal T = reduce( PBW_basis_byDeg( i ), FLM, 1 ); 

        kill FLM;
                        
        // we simply kill in T monomials occurring in FOUND_LEADING_MONOMIALS[i]
        ideal P = PBW + T; // here we simplify T        
        
        // Compute current centralizer
        NEW = CENTRALIZE_SET( F, P ); 
        
        if( size(NEW) > 0 )
        {
            // In order to speedup multiplications we are going into a commutative ring:
            setring COMMRING;
            
            if( defined(NEW) )
            {
                kill NEW;
            }
            
            // we can perform commutative interreduction
            // since no monomials should be multiplied!
            // degrees should not change
            ideal NEW = interred( imap( NCRING, NEW ) );
            
            // Go back!
            setring NCRING;
            
            kill NEW; ideal NEW = imap( COMMRING, NEW );
            
            DBPrint( 1, "Found: ", NEW );
            
            // Add them to result...
            result = result + NEW;
        }
        
        // Did we find needed number of generators? Or reached the bound?
        if( (m and (size(result) >= k)) or (!m and (i == D)) ) 
        {
            break; // Get out of here!!!
        }
        
        // otherwise we must update FOUND_LEADING_MONOMIALS
        if( size(NEW) > 0 )
        {
            setring COMMRING;
            
            if( defined(FLM) )
            {
                kill FLM;
            }
            
            ideal FLM = ideal();
            
            // We must update FOUND_LEADING_MONOMIALS!!!
            for( j = 1; j <= size(NEW); j++ )
            {
                FLM[j] = leadmonom( NEW[j] ); // we are interested in leading monomials only!
            }
            
            kill NEW;            
            
            FOUND_LEADING_MONOMIALS[i] = FOUND_LEADING_MONOMIALS[i] + FLM;
            
            for( j = 1; j <= D; j = j + i ) // For every degree (j*i) of LNEW, do:
            {            
                for( l = j; (l+i) <= D; l++ )
                {
                    FOUND_LEADING_MONOMIALS[l+i] = 
                        FOUND_LEADING_MONOMIALS[l+i] + FOUND_LEADING_MONOMIALS[l] * FLM;
                }
            }
            
            // Return to NCRING
            setring NCRING;
                
            // And refine T one more:
        
            // just to avoid "no standard basis" warning.
            ideal FLM = imap(COMMRING, FLM);
            attrib(FLM, "isSB", 1);
    
            // we simply kill in T monomials occurring in FOUND_LEADING_MONOMIALS[i]
            kill P; ideal P = PBW + reduce( T, FLM, 1 );
            kill FLM;            
        }
        
        kill T, PBW; ideal PBW = P; kill P;
        
        if( m and (i == D) ) // Was the previous estimation too small???
        {            
            // We must update FOUND_LEADING_MONOMIALS in their world:
            setring COMMRING;

            // Init new grades:
            for( j = D + 1; j <= (D + Delta); j++ )
            {
                FOUND_LEADING_MONOMIALS[j] = ideal();
            }
                        
            if( defined(FLM) )
            {
                kill FLM;
            }            
            
            ideal FLM = ideal();
            
            // All previously computed elements in their order!
            ideal NEW = imap( NCRING, result );
            
            for( j = 1; j <= size(NEW); j++ )
            {
                FLM[j] = leadmonom( NEW[j] ); // we are interested in leading monomials only!
            }
            
            kill NEW;
            
            while( size(FLM) > 0 )
            {
                // minimal degree:
                d = mindeg(FLM);  
                
                // take all of minimal degree:               
                ideal T = jet( FLM, d ); 
                
                // there are size(T) elements of smallest degree (deg(FLM[1])) in FLM!
                
                // Add them in the same way:
                for( j = 1; j <= (D + Delta); j = j + d ) // For every degree (j*d) of T, do:
                {            
                    for( l = j; (l + d) <= (D + Delta); l++ )
                    {
                        if( (l + d) > D ) // Only new should be updated!
                        {
                            FOUND_LEADING_MONOMIALS[l+d] = 
                                FOUND_LEADING_MONOMIALS[l+d] + FOUND_LEADING_MONOMIALS[l] * T;
                        }
                    }
                }
                
                // Kill them from FLM:
                if( size(T) < size(FLM) )
                {
                    FLM = FLM[ (size(T)+1) .. size(FLM) ];
                } else
                {
                    FLM = ideal(0); // break;
                }
                
                kill T;
            }    
            
            // Go back...
            setring NCRING;

            // And set new Bound
            D = D + Delta;
        }
                
        i++;
    }
    
    kill COMMRING;
    
    result = makeNice(result);

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "CENTRALIZER_SUBALGEBRA", result ); }; /*4DEBUG*/
    
    return( result );
}
example
{
 "EXAMPLE:"; echo = 2;
 ring A = 0,(x,y,z),dp;
 matrix D[3][3]=0;
 D[1,2]=-z;  D[1,3]=2*x;  D[2,3]=-2*y;
 ncalgebra(1,D); // this algebra is U(sl_2)
 ideal F = x, y;
 // find subalgebra generators degree <= 4 of an algebra of
 // all elements commuting with x and y:
 ideal C = CENTRALIZER_SUBALGEBRA(F, 4); 
 C; 
 inCentralizer(C, F);
}


/******************************************************/
proc CENTER_SUBALGEBRA( int D, list # )
"USAGE:      CENTER_SUBALGEBRA( D[, k] ); int D[, int k]
RETURN:     ideal, generated by computed generators
PURPOSE:    if N is absent and D >= 0 computes a subalgebra generators of the center up to degree D, otherwise if N is present computes N(at least) first generators of the center, if moreover D > 0 it will be used as the first maximal degree estimation.
NOTE:       Current ordering must be a degree compatible well-ordering.
SEE ALSO:   CENTRALIZER_SUBALGEBRA; CENTER_VECTORSPACE; center; inCenter
EXAMPLE:    example CENTER_SUBALGEBRA; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "CENTER_SUBALGEBRA", D ); }; /*4DEBUG*/

    if( nameof( basering ) == "basering" )
    {
        ERROR( "No current ring!" );
    }
    
    ideal result = CENTRALIZER_SUBALGEBRA( sorted_variables(), D, # );
     
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "CENTER_SUBALGEBRA", result ); }; /*4DEBUG*/

    return( result );
}
example
{
 "EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=z;
ncalgebra(1,D); // it is a Heisenberg algebra
// find vector space basis of center of degree <= 3
ideal VSZ = CENTER_VECTORSPACE(3); 
// There should be 3 degrees of z.
VSZ;
inCenter(VSZ);
// find "minimal" central elements of degree <= 3
ideal SAZ = CENTER_SUBALGEBRA(3); 
// Only 'z' must be computed
SAZ; 
inCenter(SAZ);
}


/******************************************************/
/******************************************************/
// ::SubAlgebraReduction:: A kind of subalgebra reduction...
/******************************************************/
/******************************************************/

/******************************************************/
static proc INTERRED( ideal S )
"USAGE:      INTERRED( S ); ideal S
RETURN:      ideal, interreduced S
PURPOSE:     interreduction without monomial multiplication, just make every leading monomial occur in a single polynomial
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "INTERRED", S ); }; /*4DEBUG*/

    ideal result = S;
    
    int flag = 1; 
    
    int i, j, N; 
    
    poly p, lm; 
    
    while( flag == 1 )
    {    
        flag = 0;
        
        result = sort( simplify( result, 1 + 2 + 8) )[1];        
        // sorting w.r.t. actual monomial ordering 
        // generators with SMALLER(!) leading term come FIRST
        
        N = size(result);
        
        // kill leading monomials:
        
        i = 1;       
        while( i < N )
        {
            p = result[i];
            lm = leadmonom(p);
            
            j = i + 1;
            while( leadmonom(result[j]) == lm )
            {
                result[j] = result[j] - p; // leadcoefs are 1 because of simplify.
                flag = 1; // we have changed something => we do still need to care about it...
                j++;
                
                if( j > N )
                {
                    break;
                }
            }
                        
            i = j;            
        }
    } 
    
    // We are done! No common leading monomials!
    // The result is sorted 

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "INTERRED", result ); }; /*4DEBUG*/

    return( result );
}


/******************************************************/
static proc SANF( poly p, list FOUND_LEADING_MONOMIALS )
"
    reduce p wrt found multiples without ANY polynomial multiplications!
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "SANF", p, FOUND_LEADING_MONOMIALS); }; /*4DEBUG*/
    
    poly q = p;
    poly head = 0;
    
    int d; int N = size(FOUND_LEADING_MONOMIALS);
    
    while( size(q) > 0 )
    {
        d = maxdeg(p);
        
        if( (0 < d) and (d <= N) )
        {
            if( size(FOUND_LEADING_MONOMIALS[d]) > 0 )
            {
                attrib( FOUND_LEADING_MONOMIALS[d], "isSB", 1);
                q = reduce( p, FOUND_LEADING_MONOMIALS[d] ); 
            }
            
            DBPrint(1, string(p) + " --> " + string(q) );
        }        
                
        if( q == p )
        {
            p = lead(q);
            
            if( d > 0 )
            {
                // No scalars!
                head = head + p;
            }
            
            q = q - p;
        }
        
        p = q;
    }
    
    

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "SANF", head ); }; /*4DEBUG*/

    return( head );
}


/******************************************************/
static proc maxdegInt( ideal I )
{    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "maxdegInt", I ); }; /*4DEBUG*/

    intmat D = maxdeg(I);
    
    int max = D[1, 1]; int m;
    
    for( int c = 2; c <= ncols(D); c++ )
    {
        m = D[1, c];
        
        if( m > max )
        {
            max = m;
        }
    }
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "maxdegInt", max ); }; /*4DEBUG*/

    return( max );    
}

/******************************************************/
proc sa_reduce( ideal V ) // 'subalgebra basis' computation
"USAGE:     sa_reduce(V); ideal V
RETURN:     ideal, generated by found elements
PURPOSE:    compute a subalgebra basis of an algebra generated by polynomial from V
NOTE:       May produce wrong result in quotient algebras.
SEE ALSO:   sa_poly_reduce
EXAMPLE:    example sa_reduce; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "sa_reduce", V ); }; /*4DEBUG*/
    
    ideal result = ideal();
    
    ideal FLM = INTERRED( V ); // The output is sorted "[1]<[2]<[3]<..."
    
    // We are bounded by maximal degree!!!
    int D = maxdegInt( FLM );
    
    // Init
    list FOUND_LEADING_MONOMIALS = list();
    
    int i;
    
    for( i = 1; i <= D; i++ )
    {
        FOUND_LEADING_MONOMIALS[i] = ideal();
    }    
    
    int d, j, l;
    
    poly p, q; ideal T;
    
    
    int c = 1;  // polynomials in FLM commute pairwise
    
    for( j = 1; (j < size(FLM)) and (c == 1); j++ )
    {
        p = FLM[j];
        
        for( l = j+1; (l <= size(FLM)) and (c == 1); l++ )
        {
            q = FLM[l];
        
            if( NF(p*q - q*p, twostd(0)) != 0  )
            {
                c = 0; // There exists non-commuting pair
            }            
        }
    }

    while( size(FLM) > 0 )
    {
        // Take the 1st element of FLM...
        p = FLM[1]; // SANF( FLM[1], FOUND_LEADING_MONOMIALS );
        
        FLM[1] = 0; // ...and kill it from FLM
        
        d = maxdeg( p );
        T = ideal(p); 
        
        FOUND_LEADING_MONOMIALS[d] = FOUND_LEADING_MONOMIALS[d] + T;
        
        for( j = 1; j <= D; j = j + d ) // For every degree (j*d) of T, do:
        {            
            for( l = j; (l + d) <= D; l++ )
            {
                FOUND_LEADING_MONOMIALS[l+d] = 
                    FOUND_LEADING_MONOMIALS[l+d] + FOUND_LEADING_MONOMIALS[l] * T;
                    
                if( c != 1 )
                {
                    FOUND_LEADING_MONOMIALS[l+d] = 
                        FOUND_LEADING_MONOMIALS[l+d] + T * FOUND_LEADING_MONOMIALS[l];
                }   
            }
        }
        
        if( size(FLM) > 0 )
        {
            for( i = 2; i <= ncols(FLM); i++ )
            {
                FLM[i] = SANF( FLM[i], FOUND_LEADING_MONOMIALS );
            }
            FLM = INTERRED( FLM );            
        } 
        
        DBPrint(1, "Found: " + string(T) );
        
        result = result + T;
        
    }
    
    result = makeNice(result);
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "sa_reduce", result ); }; /*4DEBUG*/
    
    return( result );
}
example
{ "EXAMPLE:"; echo = 2;
 ring A = 0,(x,y,z),dp;
 matrix D[3][3]=0;
 D[1,2]=-z; D[1,3]=2*x; D[2,3]=-2*y;
 ncalgebra(1,D); // this algebra is U(sl_2)
 poly f = 4*x*y+z^2-2*z; // a central polynomial
 ideal I = f, f*f, f*f*f - 10*f*f, f+3*z^3; I;
 sa_reduce(I); // should be just f and z^3
}



/******************************************************/
proc sa_poly_reduce( poly p, ideal V ) // subalgebra reduction of a polynomial
"USAGE:      sa_poly_reduce(p, V); poly p, ideal V
RETURN:     polynomial, a reduction of p wrt V
PURPOSE:    computes a reduction of a given polynomial p wrt a set of polynomials V
NOTE:       May produce wrong result in quotient algebras.
SEE ALSO:   sa_reduce
EXAMPLE:    example sa_poly_reduce; shows an example
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "sa_poly_reduce", p, V ); }; /*4DEBUG*/
    // As previous...
    
    ideal FLM = INTERRED( V ); // The output is sorted "[1]<[2]<[3]<..."
    
    // We are bounded by maximal degree!!!
    int D = maxdegInt( FLM + ideal(p)  );

    // Init
    list FOUND_LEADING_MONOMIALS = list();
    
    int i;
    
    for( i = 1; i <= D; i++ )
    {
        FOUND_LEADING_MONOMIALS[i] = ideal();
    }    
    
    int d, j, l;
    
    poly f, q; ideal T;

    
    int c = 1;  // polynomials in FLM commute pairwise
    
    for( j = 1; (j < size(FLM)) and (c == 1); j++ )
    {
        f = FLM[j];
        
        for( l = j+1; (l <= size(FLM)) and (c == 1); l++ )
        {
            q = FLM[l];
        
            if( NF(f*q - q*f, twostd(0)) != 0 )
            {
                c = 0;
            }            
        }
    }

        
    while( size(FLM) > 0 )
    {
        // Take the 1st element of FLM...
        q = SANF( FLM[1], FOUND_LEADING_MONOMIALS );
        
        FLM[1] = 0; // ...and kill it from FLM
        
        d = maxdeg(q);
        T = ideal(q); 
        
        FOUND_LEADING_MONOMIALS[d] = FOUND_LEADING_MONOMIALS[d] + T;
        
        for( j = 1; j <= D; j = j + d ) // For every degree (j*d) of T, do:
        {            
            for( l = j; (l + d) <= D; l++ )
            {
                FOUND_LEADING_MONOMIALS[l+d] = 
                    FOUND_LEADING_MONOMIALS[l+d] + FOUND_LEADING_MONOMIALS[l] * T;
                    
                if( c != 1 )
                {
                    FOUND_LEADING_MONOMIALS[l+d] = 
                        FOUND_LEADING_MONOMIALS[l+d] + T * FOUND_LEADING_MONOMIALS[l];
                }   
            }
        }
        
        if( size(FLM) > 0 )
        {
            for( i = 2; i <= ncols(FLM); i++ )
            {
                FLM[i] = SANF( FLM[i], FOUND_LEADING_MONOMIALS );
            }
            FLM = INTERRED( FLM );            
        }
    }
    
    poly result = SANF(p, FOUND_LEADING_MONOMIALS);
    
    result = makeNice( result );

    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "sa_poly_reduce", result ); }; /*4DEBUG*/

    return( result );
}
example
{ "EXAMPLE:"; echo = 2;
 ring A = 0,(x,y,z),dp;
 matrix D[3][3]=0;
 D[1,2]=-z; D[1,3]=2*x; D[2,3]=-2*y;
 ncalgebra(1,D); // this algebra is U(sl_2)
 poly f = 4*x*y+z^2-2*z; // a central polynomial
 sa_poly_reduce(f + 3*f*f + x, ideal(f) ); // should be just 'x'
}







/******************************************************/
// ::inStuff:: inCentralizer, inCenter, isCartan helpers
/******************************************************/


/******************************************************/
static proc inCentralizer_poly( poly p, ideal S )
"
    if p in centralizer(S) => return 1, otherwise return 0
"
{
    poly f;
    
    for( int k = 1; k <= size(S); k++ )
    {
        f = S[k];

        if( NF( f * p - p * f, twostd(0) ) != 0 )
        {
            DBPrint( 1, "POLY: " + string (p) + 
                " is NOT in the centralizer of poly {" + string(f) + "}" );
            return (0);
        }
    }

    return( 1 );
}

/******************************************************/
static proc inCentralizer_list( def l, ideal S )
{    
    for( int @i = 1; @i <= size(l); @i++ )
    {
        if( (typeof(l[@i])=="poly") or (typeof(l[@i]) == "int") or (typeof(l[@i]) == "number") )
        {
            if(! inCentralizer_poly(l[@i], S) )
            {
                return(0);
            }

        } else
        {
            if( (typeof(l[@i])=="list") or (typeof(l[@i])=="ideal") )
            {
                if(! inCentralizer_list(l[@i], S) )
                {
                    return(0);
                }
            }
        }
    }
    return(1);
}


/******************************************************************************/
proc inCentralizer( def a, ideal S ) // Checks the commutativity of polynomials of a with the polynomials in S
"USAGE:   inCentralizer(a, S); a poly/list/ideal, S poly/ideal
RETURN:  integer, 1 if a in the centralizer(S), 0 otherwise
PURPOSE: check whether a given element is centralizing with respect to elements of S
EXAMPLE: example inCentralizer; shows examples
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "inCentralizer", a, S ); }; /*4DEBUG*/

    if( nameof( basering ) == "basering" )
    {
        ERROR( "No current ring!" );
    }
    

    int res;
    
    if( (typeof(a) == "poly") or (typeof(a) == "int") or (typeof(a) == "number") )
    {
        res = inCentralizer_poly(a, S);
    } else
    {
        if( (typeof(a)=="list") or (typeof(a)=="ideal") )
        {
            res = inCentralizer_list(a, S);
        } else
        {
            res = -1;
        }
    }
    
    if( res == -1 )
    {
        ERROR( "Wrong argument!" );
    }

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "inCentralizer", res ); }; /*4DEBUG*/

    return (res);
}
example
{
"EXAMPLE:";echo=2;
ring r=0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;
ncalgebra(1,D); // the Heisenberg algebra
poly f = x^2;
poly a = z; // we know this element if central
poly b = y^2;
inCentralizer(a, f);
inCentralizer(b, f);
list  l = list(1, a);
inCentralizer(l, f);
ideal I = a, b;
inCentralizer(I, f);
printlevel = 1;
inCentralizer(a, f); // yes
inCentralizer(b, f); // no
}

/******************************************************/
proc inCenter( def a ) // Checks the centrality of a
"USAGE:   inCenter(a); a poly/list/ideal
RETURN:  integer, 1 if a in the center, 0 otherwise
PURPOSE: check whether a given element is central
EXAMPLE: example inCenter; shows examples
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "inCenter", a ); }; /*4DEBUG*/

    if( nameof( basering ) == "basering" )
    {
        ERROR( "No current ring!" );
    }
        
    int result = inCentralizer( a, standard_variables() );

/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "inCenter", result ); }; /*4DEBUG*/

    return( result );
}
example
{
"EXAMPLE:";echo=2;
ring r=0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;
D[1,3]=2*x;
D[2,3]=-2*y;
ncalgebra(1,D); // this is U(sl_2)
poly p=4*x*y+z^2-2*z;
inCenter(p);
poly f=4*x*y;
inCenter(f);
list l= list( 1, p, p^2, p^3);
inCenter(l);
ideal I= p, f;
inCenter(I);
}


/******************************************************/
proc isCartan( poly f ) // Checks whether f is a Cartan element.
"
PURPOSE: check whether f is a Cartan element.
RETURN: 1 if f is a Cartan element and 0 otherwise.
NOTE: f is a Cartan element iff for all g in A there exists C in K such that [f, g] = C * g
iff for all variables v_i of A there exist C in K such that [f, v_i] = C * v_i.
"
{
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ BCall( "isCartan", f ); }; /*4DEBUG*/

    if( nameof( basering ) == "basering" )
    {
        ERROR( "No current ring!" );
    }
    

    ideal V = standard_variables();

    int r = 1; poly v, g;

    for( int i = size(V); i > 0; i-- )
    {
        v = leadmonom(V[i]); // V[i] must be just a variable, but...

        g = NF( f*v - v*f, twostd(0) ); // [f, V[i]]

        if( size(g) > 0 )
        {
            if( size(g) > 1 ) // it is not just \alpha * v_i.
            {
                r = 0;
                break;
            }

            if( leadmonom(g) != v ) // g = \alpha * v_j, j != i.
            {
                r = 0;
                break;
            }

        } // else \alpha = 0
    }
    
/*4DEBUG*/    if( defined( @@@DEBUG ) ){ ECall( "isCartan", r ); }; /*4DEBUG*/
    return( r );
}
example
{
"EXAMPLE:";echo=2;
ring r=0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z;
D[1,3]=2*x;
D[2,3]=-2*y;
ncalgebra(1,D); // this is U(sl_2) with cartan - z
isCartan(z); // yes!
poly p=4*x*y+z^2-2*z;
isCartan(p); // central elements are Cartan elements!
poly f=4*x*y;
isCartan(f); // no way!
isCartan( 10 + p + z ); // scalar + central + cartan
}




/******************************************************/
/******************************************************/
// ::MainAliases:: The only non-static functions, visible to user are here. And they are high level wrappers around basic static functions.
/******************************************************/
/******************************************************/




/******************************************************/
proc center( int D, list # ) // Computes the generators of the center of a basering
"USAGE:      center(D[, N]); int D, int N
RETURN:     ideal, generated by elements of degree at most D
PURPOSE:    computes a minimal set of central elements up to degree D.
NOTE:       In general, one cannot predict the number or the highest degree of
central elements. Hence, one has to specify a termination condition via arguments D and/or N.
@*   If D is positive, the computation stops after all central elements of degree at most D has been found.
@*   If D is negative, the termination is determined by N only.
@*   If N is given, the computation stops if at least N central elements has been found.
@* Warning: if N is given and bigger than the actual number of generators, the procedure may not terminate.
SEE ALSO:   centralizer; inCenter
EXAMPLE:    example center; shows an example
"
{
    if( nameof( basering ) == "basering" ) 
    {
        ERROR( "No current ring!" );  
    }
    
    if( DefaultInt( # ) > 0 )
    {
        return( CENTER_SUBALGEBRA( D, # ) );
    }
    
    if( D >= 0 )
    {
        return( sa_reduce( CENTER_VECTORSPACE(D) ) ); // Experimental! May be wrong!!!
    }
    
    ERROR( "Wrong arguments!" );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z,t),dp;
matrix D[4][4]=0;
D[1,2]=-z;  D[1,3]=2*x;  D[2,3]=-2*y;
ncalgebra(1,D); // this algebra is U(sl_2) tensored with K[t]
ideal Z = center(3); // find all central elements of degree <= 3
Z;
inCenter(Z);
ideal ZZ = center(-1, 1); // find one central element of the lowest degree
ZZ;
inCenter(ZZ);
}

/******************************************************/
proc centralizer( ideal S, int D, list # ) // Computes the generators of the centralizer of S in a basering
"USAGE:      centralizer(S, MaxDeg[, N]); poly/ideal S, int MaxDeg, int N
RETURN:     ideal, generated by elements of degree <= MaxDeg
PURPOSE:    computes a minimal set of elements centralizer(S) up to degree MaxDeg.
NOTE:       In general, one cannot predict the number or the highest degree of
centralizing elements. Hence, one has to specify a termination condition via arguments MaxDeg and/or N.
@*   If MaxDeg is positive, the computation stops after all centralizing elements of degree at most MaxDeg has been found.
@*   If MaxDeg is negative, the termination is determined by N only.
@*   If N is given, the computation stops if at least N centralizing elements has been found.
@* Warning: if N is given and bigger than the actual number of generators, the procedure may not terminate.
SEE ALSO:   center; inCentralizer
EXAMPLE:    example centralizer; shows an example
"
{
    if( nameof( basering ) == "basering" ) 
    {
        ERROR( "No current ring!" );  
    }
    
    if( DefaultInt( # ) > 0 )
    {
        return( CENTRALIZER_SUBALGEBRA( S, D, # ) );
    }
    
    if( D >= 0 )
    {
        return( sa_reduce( CENTRALIZER_VECTORSPACE(S, D), 1) ); // Experimental! May be wrong!!!
    }
    
    ERROR( "Wrong arguments!" );
}
example
{
"EXAMPLE:"; echo = 2;
ring A = 0,(x,y,z),dp;
matrix D[3][3]=0;
D[1,2]=-z; D[1,3]=2*x; D[2,3]=-2*y;
ncalgebra(1,D); // this algebra is U(sl_2)
poly f = 4*x*y+z^2-2*z; // a central polynomial
f;
ideal c = centralizer(f, 2); // find all elements of the centralizer of f
                            // of degree <= 2
c;  // since f is central, the answer consists of generators of A
inCentralizer(c, f);
ideal cc = centralizer(f,-1,2); // find at least two elements of the centralizer of f
cc;
inCentralizer(cc, f);
poly g = z^2-2*z; // some non-central polynomial
c = centralizer(g, 2); // find all elements of the centralizer of g
                        // of degree <= 2
c;
inCentralizer(c, g);
centralizer(g,-1,1); // find the element of the lowest degree in the centralizer
cc = centralizer(g,-1,2); // find at least two elements of the centralizer of g
cc;
inCentralizer(cc, g);
}


/*******************************************************
// normally one should use this library together with ncalg.lib in the following way:

LIB "ncalg.lib";
def Usl3 = makeUsl(3); // U(sl_3)
setring Usl3;

// show current ring:
basering;

LIB "center.lib";

// easy example(few seconds), must compute two polynomials of degrees 2 and 3.
center(3);

kill Usl3;

def Ug2 = makeUg2(); // U(g_2)
setring Ug2;

// show current ring:
basering;

// easy example(few seconds), must compute one polynomial of degree 2.
center(2);

// hard example(some minutes), must compute two polynomials of degrees 2 and 6.
center(6);

quit;
*******************************************************/
