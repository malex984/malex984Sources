///////////////////////////////////////////////////////////////////////////////

version="$Id: jordan.lib,v 1.2 1998-12-23 13:13:09 mschulze Exp $";
info="
LIBRARY: jordan.lib  PROCEDURES TO COMPUTE THE JORDAN NORMAL FORM
                     by Mathias Schulze
                     email: mschulze@mathematik.uni-kl.de

 jordandata(M);      data of the jordan normal form of the constant part 
                     of the matrix M
 jordanmatrix(d);    jordan matrix defined by the data d
 jordanform(M);      jordan normal form of the constant part of the matrix M
 jordanbasis(M);     basis with respect to which the constant part 
                     of the matrix M is in jordan normal form
";

LIB "ring.lib";
///////////////////////////////////////////////////////////////////////////////

proc jordandata(matrix M)
INPUT:   square matrix M with factorizable characteristic polynomial 
         of the constant part M0
OUTPUT:  nothing, if the assumptions are not fulfilled, else,
         a list with first entry an ideal containing the eigenvalues of M0 
         in increasing order and second entry a list of increasingly ordered 
         int vectors containing the corresponding jordan block sizes
EXAMPLE: example jordandata; shows an example
{
  int n=nrows(M);
  if(n!=ncols(M))
  {
    "//no square matrix";
    return();
  }

  def br=basering;
  map zero=br,0;
  M=zero(M);

  changeord("pr","dp");
  matrix M=imap(br,M);

  list l=factorize(det(M-var(1)*freemodule(n)),2);
  def eM,mM=l[1..2];

  int i;
  for(i=size(eM);i>=1;i--)
  {
    if(deg(eM[i])>1)
    {
      kill pr;
      "//unable to factorize characteristic polynomial";
      return();
    }
  }

  map inv=pr,-var(1);
  eM=simplify(inv(eM),1);
  setring br;
  map zero=pr,0;
  ideal eM=zero(eM);
  kill pr;

  int j;
  poly e;
  int m;
  for(i=size(eM);i>=2;i--)
  {
    for(j=i-1;j>=1;j--)
    {
      if(eM[i]<eM[j])
      {
        e=eM[i];
        eM[i]=eM[j];
        eM[j]=e;
        m=mM[i];
        mM[i]=mM[j];
        mM[j]=m;
      }
    }
  }
  kill e,m;

  int k,l,m;
  intvec bMi;
  list bM;
  matrix Mi,Mj;
  matrix E=freemodule(nrows(M));
  for(i=ncols(eM);i>=1;i--)
  {
    Mi=M-eM[i]*E;
    Mj=Mi;
    k=ncols(syz(Mj));
    m=k;
    bMi=0;
    bMi[m]=0;
    for(j=k;j>=1;j--)
    {
      bMi[j]=1;
    }
    for(j=mM[i];j>=1;j--)
    {
      Mj=Mj*Mi;
      k=ncols(syz(Mj));
      for(l=size(bMi);l>size(bMi)+m-k;l--)
      {
        bMi[l]=bMi[l]+1;
      }
      m=k;
    }
    bM=list(bMi)+bM;
  }

  return(list(eM,bM));
}
example
{
  "EXAMPLE:";
  echo=2;
  LIB "random.lib";
  ring r;
  list d=ideal(2,3),list(intvec(1,1,2,2,2),intvec(3,4,5));
  matrix M=jordanmatrix(d);
  print(M);
  int n=nrows(M);
  matrix U;
  while(det(U)==0)
  {
    U=randommat(n,n,ideal(1)); 
  }
  matrix invU=lift(U,freemodule(n));
  M=invU*M*U;
  print(M);
  jordandata(M);
}
///////////////////////////////////////////////////////////////////////////////

proc jordanmatrix(list d)
INPUT:   list d
ASSUME:  first entry of d an ideal containing numbers and second entry of d 
         a list of same length containing int vectors with positive entries
OUTPUT:  a jordan matrix with eigenvalues from the first entry of d 
         and jordan block sizes from the second entry of d
EXAMPLE: example jordanmatrix; shows an example
{
  def eM,bM=d[1..2];

  int i,j,n;
  for(i=size(bM);i>=1;i--)
  {
    for(j=size(bM[i]);j>=1;j--)
    {
      n=n+bM[i][j];
    }
  }
  matrix M[n][n];

  int k,l;
  for(i,l,M=1,1,0;i<=size(eM);i++)
  {
    for(j=1;j<=size(bM[i]);j++)
    {
      for(k=bM[i][j];k>=2;k,l=k-1,l+1)
      {
        M[l,l]=eM[i];
        M[l,l+1]=1;
      }
      M[l,l]=eM[i];
      l++;
    }
  }

  return(M);
}
example
{
  "EXAMPLE:";
  echo=2;
  ring r;
  list d=ideal(2,3),list(intvec(1,1,2,2,2),intvec(3,4,5));
  d;
  print(jordanmatrix(d));
}
///////////////////////////////////////////////////////////////////////////////

proc jordanform(matrix M)
INPUT:   square matrix M with factorizable characteristic polynomial 
         of the constant part M0
OUTPUT:  nothing, if the assumptions are not fulfilled, else,
         a jordan matrix of M0
EXAMPLE: example jordanform; shows an example
{
  return(jordanmatrix(jordandata(M)));
}
example
{
  "EXAMPLE:";
  echo=2;
  LIB "random.lib";
  ring r;
  list d=ideal(2,3),list(intvec(1,1,2,2,2),intvec(3,4,5));
  matrix M=jordanmatrix(d);
  print(M);
  int n=nrows(M);
  matrix U;
  while(det(U)==0)
  {
    U=randommat(n,n,ideal(1)); 
  }
  matrix invU=lift(U,freemodule(n));
  M=invU*M*U;
  print(M);
  print(jordanform(M));
}
///////////////////////////////////////////////////////////////////////////////

proc jordanbasis(matrix M)
INPUT:   square matrix M with factorizable characteristic polynomial 
         of the constant part M0
OUTPUT:  nothing, if the assumptions are not fulfilled, else,
         a module containing a basis with respect to which M0 is in
         jordan normal form
EXAMPLE: example jordanbasis; shows an example
{
  int n=nrows(M);
  if(n!=ncols(M))
  {
    "//no square matrix";
    return();
  }

  def br=basering;
  map zero=br,0;
  M=zero(M);

  changeord("pr","dp");
  matrix M=imap(br,M);

  list l=factorize(det(M-var(1)*freemodule(n)),2);
  def eM,mM=l[1..2];

  int i;
  for(i=size(eM);i>=1;i--)
  {
    if(deg(eM[i])>1)
    {
      kill pr;
      "//unable to factorize characteristic polynomial";
      return();
    }
  }

  map inv=pr,-var(1);
  eM=simplify(inv(eM),1);
  setring br;
  map zero=pr,0;
  ideal eM=zero(eM);
  kill pr;

  int j;
  poly e;
  int m;
  for(i=size(eM);i>=2;i--)
  {
    for(j=i-1;j>=1;j--)
    {
      if(eM[i]<eM[j])
      {
        e=eM[i];
        eM[i]=eM[j];
        eM[j]=e;
        m=mM[i];
        mM[i]=mM[j];
        mM[j]=m;
      }
    }
  }
  kill e,m;

  int k,l;
  matrix Mi,Ni;
  matrix E=freemodule(n);
  module V,K1,K2,sNi;
  matrix v[n][1];
  list K;
  for(i=ncols(eM);i>=1;i--)
  {
    Mi=M-eM[i]*E;
    K=list();

    for(Ni,sNi=Mi,0;size(sNi)<mM[i];Ni=Ni*Mi)
    {
      sNi=syz(Ni);
      K=K+list(sNi);
    }
    if(size(K)>1)
    {
      K1=K[1];
      K[1]=interred(reduce(K[1],std(module(Mi*K[2]))));
      for(j=2;j<=size(K)-1;j++)
      {
        K2=K[j];
        K[j]=interred(reduce(K[j],std(K1+module(Mi*K[j+1]))));
        K1=K2;
      }
      K[j]=interred(reduce(K[j],std(K1)));
    }
    for(j=size(K);j>=1;j--)
    {
      for(k=size(K[j]);k>=1;k--)
      {
        v=K[j][k];
        for(l=j;l>=1;l--)
        {
          V=module(v)+V;
          v=Mi*v;
        }
      }
    }
  }
  return(V);
}
example
{
  "EXAMPLE:";
  echo=2;
  LIB "random.lib";
  ring r;
  list d=ideal(2,3),list(intvec(1,1,2,2,2),intvec(3,4,5));
  matrix M=jordanmatrix(d);
  print(M);
  int n=nrows(M);
  matrix U;
  while(det(U)==0)
  {
    U=randommat(n,n,ideal(1)); 
  }
  matrix invU=lift(U,freemodule(n));
  M=invU*M*U;
  print(M);
  U=jordanbasis(M);
  invU=lift(U,freemodule(n));
  print(invU*M*U);
}
///////////////////////////////////////////////////////////////////////////////
