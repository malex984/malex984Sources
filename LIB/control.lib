version="$Id: control.lib,v 1.7 2004-08-08 21:40:19 plural Exp $";
category="System and Control Theory";
info="
LIBRARY:  control.lib Procedures for System and Control Theory 
AUTHORS:  Oleksandr Iena  yena@mathematik.uni-kl.de
@*        Markus Becker   mbecker@mathematik.uni-kl.de

SUPPORT: Forschungsschwerpunkt 'Mathematik und Praxis'


PROCEDURES:
declare(string NameOfRing, string Variables[,string  Parameters, string Ordering]);
Defining the ring, optional parametes are a string of parameters and a sting of ordering.
 
Print();                      Well-formatted output of lists, modules and matrixes
control(module R);            Computes everthing related to controllability
autonom(module R);            Computes everything related to autonomy(using Exts) 
autonom2(module R);           Computes everything related to autonomy(using dim) 
LeftKernel(module R);         Computing the left kernel of R
RightKernel(module R);        Computing the right kernel of R
LeftInverse(module R)         Computes left inverse of matrix(module)

static Ext_Our(...)                  Copy of Ext_R from 'homolog.lib' in commutative case;
static is_zero_Our(module R)         Copy of is_zero from 'OBpoly.lib';
static space(int n)           Procedure used inside the procedure 'Print' to have a better formatted output
static control_output();      Generating the output for the procedure 'control'
static autonom_output();      Generating the output for the procedure 'autonom' and 'autonom2'

";

LIB "homolog.lib"; 
LIB "poly.lib";
LIB "primdec.lib";
//---------------------------------------------------------------
proc declare(string NameOfRing, string Variables, list #)
"USAGE: declare(NameOfRing, Variables,[Parameters, Ordering]);
          NameOfRing:  string with name of ring,
	  Variables:   string with names of variables separated by commas(e.g. "x,y,z"),
	  [Parameters, Ordering]: optional, strings:
	    Parameters: string of parameters in the ring separated by commas(e.g. "a,b,c"),
	    Ordering:   string with name of ordering(by default the ordering "dp,C" is used)
RETURN:  no return value
EXAMPLE:  example declare; shows an example 
"
{
  if(size(#)==0)
  {
    execute("ring "+NameOfRing+"=0,("+Variables+"),dp;");
  }
  else
  {
    if(size(#)==1)
    {
      execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),dp;" );
    }
    else
    { 
      if( (size(#[1])!=0)&&(#[1]!=" ") )
      {
        execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),("+#[2]+");" );
      }
      else
      {
        execute( "ring " + NameOfRing + "=0,("+Variables+"),("+#[2]+");" ); 
      };
    };
  };
  keepring(basering);
};
example
{"EXAMPLE:";echo = 2;
  string v="x,y,z";
  string p="q,p";
  string Ord ="c,lp";
 
  declare("Ring_1",v);
  print(nameof(basering));
  print(basering);
  
  declare("Ring_2",v,p);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_3",v,p,Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_4",v,"",Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_5",v," ",Ord);
  print(basering);
  print(nameof(basering));
};
//
//maybe reasonable to add this in declare
//
//  print("Please enter your representation matrix in the following form: 
//  module R=[1st row],[2nd row],...");
//  print("Type the command: R=transpose(R)");
//  print(" To compute controllability please enter: control(R)");
//  print(" To compute autonomy please enter: autonom(R)");
//
//
//
//-------------------------------------------------------------------------
static proc space(int n)
"USAGE:spase(n); 
         n: integer, number of needed spaces
RETURN:  string consisting of n spaces
NOTE:  the procedure is used in the procedure 'view' to have a better formatted output
"
{
  int i;
  string s="";
  for(i=1;i<=n;i++)
  {
    s=s+" ";
  };
  return(s);
};
//-----------------------------------------------------------------------------
proc view(M)
"USAGE:  view(M);
           M:  any type
RETURN:  no return value
PURPOSE:  procedure for ( well-) formatted output of modules, matrices, lists of modules, matrices;
          shows everything even if entries are long
NOTE:  in case of other types( not 'module', 'matrix', 'list') works just as standard 'print' procedure  
EXAMPLE:  example view; shows an example
"
{
  if ( (typeof(M)=="module")||(typeof(M)=="matrix") )
  {
  int @R=nrows(M);
  int @C=ncols(M);
  int i;
  int j;
  list MaxLength=list();
  int Size=0;
  int max;
  string s;
  
  for(i=1;i<=@C;i++)
  { 
    max=0; 
    
    for(j=1;j<=@R;j++)
    {
      Size=size( string( M[j,i] ) );
      if( Size>max )
      {
        max=Size;
      };
    };
    MaxLength[i] = max;
  };
  
  for(i=1;i<=@R;i++)
  {
    s="";
    for(j=1;j<@C;j++)
    {
      s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) ) +",";
    };
    
    s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) );

    if (i!=@R)
    {
      s=s+",";
    };
    print(s);
  };

  return();    
  };
  
  if(typeof(M)=="list")
  {
    int sz=size(M);
    int i;
    for(i=1;i<=sz;i++)
    {
      view(M[i]);
      print("");
    }; 

    return();
  };
  print(M);
  return();
};
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[1][3] = x,y,z;
  print(M);
  view(M);
};
//--------------------------------------------------------------------------
proc RightKernel(matrix M)
"USAGE:  RightKernel(M);
           M:  matrix
RETURN:  right kernel of matrix M, i.e., the module of all elements v such that Mv=0
NOTE:  in commutative case it is really a left  module, in noncommutative(to be implemented later) it will be right module   
EXAMPLE:  example RightKernel; shows an example
"
{ 
  return(syz(M));
}; 
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[1][3] = x,y,z;
  print(M);
  print( RightKernel(M) );
};
//-------------------------------------------------------------------------
proc LeftKernel(matrix M)
"USAGE:  LeftKernel(M);
           M:  matrix
RETURN:  left kernel of matrix M, i.e., the matrix whose rows are generators of left module
         (elements of this module are to be rows) of all elements v such that vM=0   
EXAMPLE:  example LeftKernel; shows an example
"
{
  return( transpose( syz( transpose(M) ) ) );
};
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[3][1] = x,y,z;
  print(M);
  print( LeftKernel(M) );
};
//------------------------------------------------------------------------
proc LeftInverse(matrix M)
"USAGE:  LeftInverse(M);
           M:  matrix
RETURN:  left inverse of M if exists, i.e., matrix L such that LM == id;
EXAMPLE:  example LeftInverse; shows an example
"
{
  int NCols=ncols(M);
  M=transpose(M);
  matrix I[NCols][NCols];
  I=I+1;
  module Id=I;
  return( transpose( lift( module(M),Id ) )  );
};
example
{"EXAMPLE:";echo =2;
  ring r;
  matrix M[2][1] = 1,x2z;
  print(M);
  print( LeftInverse(M) );  
};
//-----------------------------------------------------------------------
static proc Ext_Our(int i, module R,list #)
// just a copy of 'Ext_R' from "homolog.lib" in commutative case
{
  if ( size(#)==0 )
  { 
    return( Ext_R(i,R) ); 
  }
  else
  {
    return( Ext_R(i,R,#[1]) );
  };
};
//------------------------------------------------------------------------
static proc is_zero_Our(module R)
//just a copy of 'is_zero' from "poly.lib"
{
  return( is_zero(R) ) ;
};
//------------------------------------------------------------------------
static proc control_output(int i, int NVars, module R, module Ext_1) 
"USAGE:  proc control_output(i, NVars, R, Ext_1)
           i:  integer, number of first nonzero Ext or 
	       just number of variables in a base ring + 1 in case that all the Exts are zero
	   NVars:  integer, number of variables in a base ring  
	   R:  module R (cokernel representation)
	   Ext_1:  module, the first Ext(its cokernel representation)      
RETURN:  list with all the contollability properties of the system which is to be returned in 'control' procedure
NOTE:  this procedure is used in 'control' procedure
"
{
  int d=dim( std( Ann( transpose(R) ) ) ) ;;//this is the dimension of the system 
  string DofS= "dimension of the system:";
  string Fn= "number of first nonzero Ext:";
  if(i==1)
  { 
    module RK=RightKernel(R);
    return( 
            list ( Fn,
	           i,
	          "not controllable , image representation for controllable part:",
         	   RK,	    
	          "kernel representation for controllable part:",
		   LeftKernel( RK ),
		  "obstruction to controllability",
		   Ext_1,
		  "annihilator of torsion module(of obstruction to controllability)",
		   Ann(Ext_1),
		   DofS,
		   d
		 ) 
          );
  };
  
  if(i>NVars)
  { module RK =RightKernel(R); 
    return( list(  Fn,
                   -1, 
                  "strongly controllable, image representation:",
		   RK,
		  "left inverse to image representation:",
		   LeftInverse(RK),
		   DofS, 
		   d) 
          );
  };
  
  //
  //now i<=NVars
  //
       
  if( (i==2) )
  {
    return( list( Fn,
                  i, 
                 "controllable, not reflexive, image representation:",
		  RightKernel(R),
                  DofS,
                  d ) 
          ); 
  };
    
  if( (i>=3) )
  {
    return( list ( Fn,
                   i, 
                  "reflexive, not strongly controllable, image representation:",
		   RightKernel(R),
		   DofS,
		   d) 
          );
  };
              
  
};  
//-------------------------------------------------------------------------

proc control(module R)
"USAGE:  control(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning controllability of the system(behavior) represented by the  matrix R
EXAMPLE:  example control; shows an example
"
{
  int i;
  int NVars=nvars(basering); 
  int ExtIsZero;
 
       
  module Ext_1 = std(Ext_Our(1,R));
   
  ExtIsZero=is_zero_Our(Ext_1);
  i=1;
  while( (ExtIsZero) && (i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our( Ext_Our(i,R) );
  };
  
  return( control_output( i, NVars, R, Ext_1 ) );
};
example
{"EXAMPLE:";echo = 2; 
  //-------------------------------
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  view( R );  
  view( control(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  view( Rc );
  view( control(Rc) );
  //----------------------------------
  //reflector antenna
  ring A = (0, K1, K2, Te, Kp, Kc),(Dt, delta), dp;
  module R;
  R = [Dt, -K1, 0, 0, 0, 0, 0, 0, 0],
       [0, Dt+K2/Te, 0, 0, 0, 0, -Kp/Te*delta, -Kc/Te*delta, -Kc/Te*delta],
       [0, 0, Dt, -K1, 0, 0, 0, 0, 0],
       [0, 0, 0, Dt+K2/Te, 0, 0, -Kc/Te*delta, -Kp/Te*delta, -Kc/Te*delta],
       [0, 0, 0, 0, Dt, -K1, 0, 0, 0],
       [0, 0, 0, 0, 0, Dt+K2/Te, -Kc/Te*delta, -Kc/Te*delta, -Kp/Te*delta];
  R=transpose(R);
  view(R);
  view(control(R));
  //----------------------------------
  //Flexible Rod
  ring A = 0,(D1, delta), dp;
  module R;
  R = [D1, -D1*delta, -1],
      [2*D1*delta, -D1-D1*delta^2, 0];
  R=transpose(R);
  view(R);
  view(control(R));
  //-------------------------------------
  //TwoPendula
  ring r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module R;
  R =  [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
       [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
       [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];
  R=transpose(R);
  view(R);
  view(control(R));
  //----------------------------------------
  //Wind Tunnel
  ring A = (0,a, omega, zeta, k),(D1, delta),dp;
  module R;
  R = [D1+a, -k*a*delta, 0, 0],
      [0, D1, -1, 0],
      [0, omega^2, D1+2*zeta*omega, -omega^2];
  R=transpose(R);
  view(R);
  view(control(R));
  //-------------------------------------------

};
//------------------------------------------------------------------------
static proc autonom_output( int i, int NVars ) 
"USAGE:  proc autonom_output(i, NVars)
           i:  integer, number of first nonzero Ext or 
	       just number of variables in a base ring + 1 in case that all the Exts are zero
	   NVars:  integer, number of variables in a base ring  
RETURN:  list with all the autonomy properties of the system which is to be returned in 'autonom' procedure
NOTE:  this procedure is used in 'autonom' procedure
"
{
  int d=NVars-i;//that is the dimension of the system
  string DofS="dimension of the system:";
  string Fn = "number of first nonzero Ext:";
  if(i==0)
  { 
    return( list(  Fn,
                   i,
                  "not autonomous",
		   DofS,
		   d ) 
	  );
  };
  
  if( i>NVars )
  {  
    return( list( Fn,
                  -1,
                  "trivial",
		  DofS,
		  d ) 
          );
  };
  
  //
  //now i<=NVars
  //
    
     
  if( i==1 )
  //in case that NVars==1 there is no sence to consider the notion
  //of strongly autonomous behavior, because it does not imply 
  //that system is overdetermined in this case
  {
    return( list ( Fn,
                   i, 
                  "autonomous, not overdetermined",
		   DofS,
		   d ) 
          ); 
  };
    
  if( i==NVars )
  {  
    return( list(  Fn,
                   i,
                  "strongly autonomous,in particular overdetermined",
		   DofS,
		   d) 
	  );
  };
  
  if( i<NVars )
  {
    return( list ( Fn,
                   i,
                  "overdetermined, not strongly autonomous",
		   DofS, 
		   d) 
          );
  };
    
};  
//--------------------------------------------------------------------------
proc autonom2(module R)
"USAGE:  autonom2(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning autonomy of the system(behavior) represented by the  matrix R
NOTE:  this procedure is an analogue to 'autonom' using dimension calculations
EXAMPLE:  example autonom2; shows an example
"
{ 
  int d;
  int NVars = nvars(basering);
  R=transpose(R);
  d=dim( std( Ann(R) ) );
  return( autonom_output(NVars-d,NVars) );
};
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  view( R );  
  view( autonom2(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  view( Rc );
  view( autonom2(Rc) );
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  view( R );
  view( autonom2(R) );
  
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  view( R );
  view( autonom2(R) );
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  view(R);
  view(autonom2(R));	   
};  
//---------------------------------------------------------------------------

proc autonom(module R)
"USAGE:  autonom(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning autonomy of the system(behavior) represented by the  matrix R
EXAMPLE:  example autonom; shows an example
"
//"Computes the autonomy of a behaviour represented by the matrix R"
{
  int i;
  int NVars=nvars(basering);
  int ExtIsZero;
    
  
  R=transpose(R); 
  
  
  ExtIsZero=is_zero_Our(Ext_Our(0,R)); 
  
  i=0;
  while( (ExtIsZero)&&(i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our(Ext_Our(i,R));
  };
  
  return(autonom_output(i,NVars));
     
};
example
{"EXAMPLE:"; echo = 2;
  ring r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  view( R );  
  view( autonom(R) );

  module Rc=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  Rc=transpose(Rc);	    
  view( Rc );
  view( autonom(Rc) );
  //-----------------------------------
  ring r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  view( R );
  view( autonom(R) );
  
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  view( R );
  view( autonom(R) );
  //----------------------------------------
  ring r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  view(R);
  view(autonom(R));	   
  
};  
//---------------------------------------------------------------------------
