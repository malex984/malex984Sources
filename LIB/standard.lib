// $Id: standard.lib,v 1.12 1998-05-24 15:50:27 obachman Exp $
///////////////////////////////////////////////////////////////////////////////

version="$Id: standard.lib,v 1.12 1998-05-24 15:50:27 obachman Exp $";
info="
LIBRARY: standard.lib   PROCEDURES WHICH ARE ALWAYS LOADED AT START-UP

 stdfglm(ideal[,ord])   standard basis of the ideal via fglm [and ordering ord]
 stdhilb(ideal)         standard basis of the ideal using the Hilbert function
 groebner(ideal/module) standard basis of ideal or module using a 
                        heuristically choosen method 
";

///////////////////////////////////////////////////////////////////////////////

proc stdfglm (ideal i, list #)
"USAGE:   stdfglm(i[,s]); i ideal, s string (any allowed ordstr of a ring)
RETURN:  stdfglm(i): standard basis of i in the basering, calculated via fglm
                     from ordering \"dp\" to the ordering of the basering.
         stdfglm(i,s): standard basis of i in the basering, calculated via
                     fglm from ordering s to the ordering of the basering.
EXAMPLE: example stdfglm; shows an example"
{
   string os;
   def dr= basering;
   if( (size(#)==0) or (typeof(#[1]) != "string") )
   {
     os = "dp(" + string( nvars(dr) ) + ")";
     if ( (find( ordstr(dr), os ) != 0) and (find( ordstr(dr), "a") == 0) )
     {
       os= "Dp";
     }
     else
     {
       os= "dp";
     }
   }
   else { os = #[1]; }
   execute "ring sr=("+charstr(dr)+"),("+varstr(dr)+"),"+os+";";
   ideal i= fetch(dr,i);
   intvec opt= option(get);
   option(redSB);
   i=std(i);
   option(set,opt);
   setring dr;
   return (fglm(sr,i));
}
example
{ "EXAMPLE:"; echo = 2;
   ring r  = 0,(x,y,z),lp;
   ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
   ideal i1= stdfglm(i);         //uses fglm from "dp" to "lp"
   i1;
   ideal i2= stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
   i2;
}
///////////////////////////////////////////////////////////////////////////////

proc stdhilb(ideal i,list #)
"USAGE:   stdhilb(i);  i ideal
         stdhilb(i,v); i homogeneous ideal, v intvec (the Hilbert function)
RETURN:  stdhilb(i): a standard basis of i (computing v internally)
         stdhilb(i,v): standard basis of i, using the given Hilbert function
EXAMPLE: example stdhilb; shows an example"
{
   def R=basering;

   if((homog(i)==1)||(ordstr(basering)[1]=="d"))
   {
      if ((size(#)!=0)&&(homog(i)==1))
      {
         return(std(i,#[1]));
      }
      return(std(i));
   }

   execute "ring S = ("+charstr(R)+"),("+varstr(R)+",@t),dp;";
   ideal i=homog(imap(R,i),@t);
   intvec v=hilb(std(i),1);
   execute "ring T = ("+charstr(R)+"),("+varstr(R)+",@t),("+ordstr(R)+");";
   ideal i=fetch(S,i);
   ideal a=std(i,v);
   setring R;
   map phi=T,maxideal(1),1;
   ideal a=phi(a);

   int k,j;
   poly m;
   int c=size(i);

   for(j=1;j<c;j++)
   {
     if(deg(a[j])==0)
     {
       a=ideal(1);
       attrib(a,"isSB",1);
       return(a);
     }
     if(deg(a[j])>0)
     {
       m=lead(a[j]);
       for(k=j+1;k<=c;k++)
       {
          if(size(lead(a[k])/m)>0)
          {
            a[k]=0;
          }
       }
     }
   }
   a=simplify(a,2);
   attrib(a,"isSB",1);
   return(a);
}
example
{ "EXAMPLE:"; echo = 2;
   ring  r = 0,(x,y,z),lp;
   ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
   ideal i1= stdhilb(i); i1;
   // is in this case equivalent to:
   intvec v=1,0,0,-3,0,1,0,3,-1,-1;
   ideal i2=stdhilb(i,v);
}
///////////////////////////////////////////////////////////////////////////////

proc groebner(def i, list #)
"USAGE: groebner(i) i ideal/module
RETURNS: standard basis of ideal or module which is computed using a 
         heuristically choosen method: 
         If the ordering of the current ring is a lokal ordering, or
         if it is a non-block ordering and the current ring has no
         parameters, then std(i) is returned.  
         Otherwise, i is mapped into a ring with no parameters and
         ordering dp, where its Hilbert series is computed. This is
         followed by a Hilbert-series based std computation in the
         original ring.
EXAMPLE: example groebner; shows an example"
{
  def P=basering;
  if (size(#) > 0)
  {
    if (system("with", "MP"))
    {
      if (typeof(#[1]) == "int")
      {
        int wait = #[1];
        int j, pid;
        string bs = nameof(basering);
        link l_fork = "MPtcp:fork";
        open(l_fork);
        write(l_fork, quote(system("pid")));
        pid = read(l_fork);
        write(l_fork, quote(groebner(eval(i))));
        
        for (j=0; j<wait; j++)
        {
          if (status(l_fork, "read", "ready", 1)) {break;}
        }
        
        if (status(l_fork, "read", "ready"))
        {
          def result = read(l_fork);
          if (bs != nameof(basering))
          {
            def PP = basering;
            setring P;
            def result = imap(PP, result);
            kill PP;
          }
          kill (l_fork);
        }
        else
        {
          ideal result;
          if (! defined(groebner_error))
          {
            int groebner_error;
            export groebner_error;
          }
          groebner_error = 1;
          "// ** groebner did not finish";
          j = system("sh", "kill " + string(pid));
        }
        return (result);
      }
      else
      {
        "// ** groebner needs int as 2nd arg";
      }
    }
    else
    {
      "// ** groebner with two args not supported in this configuration";
    }
  }
   string ordstr_P = ordstr(P);

   if (find(ordstr_P,"s") > 0)
   {
     //spaeter den lokalen fall ueber lp oder aehnlich behandeln
      return(std(i));
   }
   
   int IsSimple_P;
   if (system("nblocks") <= 2)
   {
     if (find(ordstr_P, "M") <= 0)
     {
       IsSimple_P = 1;
     }
   }
   int npars_P = npars(P);

   // return std if no parameters and (dp or wp)
   if ((npars_P == 0) && IsSimple_P)
   {
     if (find(ordstr_P, "d") > 0)
     {
       return (std(i));
     }
     if (find(ordstr_P,"w") > 0)
     {
       return (std(i));
     }
   }

   // reset options
   intvec opt=option(get);
   int p_opt;
   string s_opt = option();
   option(none);
   // turn on option(prot) and/or option(mem), if previously set
   if (find(s_opt, "prot"))
   {
     option(prot);
     p_opt = 1;
   }
   if (find(s_opt, "mem"))
   {
     option(mem);
   }
   
   // construct ring in which first std computation is done
   string varstr_P = varstr(P);
   string parstr_P = parstr(P);
   int is_homog = (homog(i) && (npars_P == 0)); 
   
   string ri = "ring Phelp =" + string(char(P)) + ",(" + varstr_P;
   // parameters are converted to ring variables
   if (npars_P > 0)
   {
     ri = ri + "," + parstr_P;
   }
   // a homogenizing variable is added, if necessary
   if (! is_homog)
   {
     ri = ri + ",@t";
   }
   // ordering is set to (dp, C)
   ri = ri + "),(dp,C);";

   // change the ring
   execute(ri);
   
   // get ideal from previous ring
   if (is_homog)
   {
     ideal qh = imap(P, i);
   }
   else
   {
     // and homogenize
     ideal qh=homog(imap(P,i),@t);
   }
   
   // compute std and hilbert series
   if (p_opt)
   {
     "std in " + ri[13, size(ri) - 13];
   }
   ideal qh1=std(qh);
   intvec hi=hilb(qh1,1);

   if (is_homog && (npars_P == 0))
   {
     // no additional variables were introduced
     setring P; // can immediately change to original ring
     // simply compute std with hilbert series in original ring
     if (p_opt)
     {
       "std with hilb in basering";
       i = std(i, hi);
     }
   }
   else
   {
     // additional variables were introduced
     // need another intermediate ring
     ri = "ring Phelp1 =" + string(char(P)) 
       + ",(" + varstr(Phelp) + "),(" + ordstr_P;
     
     // for lp without parameters, we do not need a block ordering
     if ( ! (IsSimple_P && (npars_P + is_homog < 2) && find(ordstr_P, "l")))
     {
       // need block ordering
       ri = ri + ", dp(" + string(npars_P + is_homog) + ")";
     }
     ri = ri + ");";
     
     // change to intermediate ring
     execute(ri);
     ideal qh = imap(Phelp, qh);
     kill Phelp;
     if (p_opt)
     {
       "std with hilb in " + ri[14,size(ri)-14];
     }
     // compute std with Hilbert series
     qh = std(qh, hi);
     // subst 1 for homogenizing var
     if (!is_homog)
     {
       qh = subst(qh, @t, 1);
     }
     
     // go back to original ring
     setring P;
     // get ideal, delete zeros and clean SB
     i = imap(Phelp1,qh);
     i = simplify(i, 34);
     kill Phelp1;
   }

   // clean-up time
   option(set, opt);
   if (find(s_opt, "redSB") > 0)
   {
     i=interred(i);
   }
   attrib(i, "isSB", 1);
   return (i);
}
example
{
  "EXAMPLE: "; echo = 2;
  ring r = 0, (a,b,c,d), lp;
  option(prot); 
  ideal i = a+b+c+d, ab+ad+bc+cd, abc+abd+acd+bcd, abcd-1; // cyclic 4
  groebner(i);
  ring rp = (0, a, b), (c,d), lp;
  ideal i = imap(r, i);
  ideal j = groebner(i);
  option(noprot);
  j; simplify(j, 1); std(i);
}

