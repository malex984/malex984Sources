///////////////////////////////////////////////////////////////////////////////
version="$Id: nctools.lib,v 1.18 2006-07-18 15:48:27 Singular Exp $";
category="Noncommutative";
info="
LIBRARY: nctools.lib     General tools for noncommutative algebras
AUTHORS:   Levandovskyy V.,     levandov@mathematik.uni-kl.de,
@*         Lobillo, F.J.,       jlobillo@ugr.es,
@*           Rabelo, C.,          crabelo@ugr.es.

SUPPORT: DFG (Deutsche Forschungsgesellschaft) and Metodos algebraicos y efectivos en grupos cuanticos, BFM2001-3141, MCYT, Jose Gomez-Torrecillas (Main researcher).

MAIN PROCEDURES:
Gweights(r);              compute weights for a compatible ordering in a G-algebra,
weightedRing(r);          change the ordering of a ring to a weighted one,
ndcond();                 the ideal of non-degeneracy conditions in G-algebra,
Weyl([p]);                create Weyl algebra structure in a basering (two different realizations),
makeWeyl(n, [p]);         return n-th Weyl algebra in (x(i),D(i)) presentation,
makeHeisenberg(N, [p,d]); return n-th Heisenberg algebra in (x(i),y(i),h) realization,
Exterior();               return qring, the exterior algebra of a basering,
findimAlgebra(M,[r]);     create finite dimensional algebra structure from the basering and the multiplication matrix M,

AUXILIARY PROCEDURES:
ncRelations(r);         recover the non-commutative relations of a G-algebra,
isCentral(p);           check for the commutativity of a polynomial in the G-algebra,
isNC();                 check whether basering is noncommutative,
UpOneMatrix(N);         return NxN matrix with 1's in the whole upper triagle,
";

LIB "ring.lib"; // for rootofUnity
LIB "poly.lib"; // for newtonDiag

///////////////////////////////////////////////////////////////////////////////

// This procedure computes a weights vector for a G-algebra r

proc Gweights(def r)
"USAGE:   Gweights(r); r a ring or a square matrix
RETURN:   intvec
PURPOSE: compute the weight vector for the following G-algebra:
@*       for r itself, if it is of the type ring,
@*       or for a G-algebra, defined by the square polynomial matrix r
THEORY:   @code{Gweights} returns a vector, which must be used to redefine the G-algebra. If the input is a matrix and the output is the zero vector then there is not a G-algebra structure associated to these relations with respect to the given variables. Another possibility is to use @code{weightedRing} to obtain directly the G-algebra with the new weighted ordering.
EXAMPLE: example Gweights; shows examples
SEE ALSO: weightedRing
"{
  matrix tails;
  int novalid=0;
  if (typeof(r)=="ring") //a ring is admissible as input
  {
    setring r;
    def l = ncRelations(r);
    tails = l[2]; // l=C,D we need D, the tails of the relations
  }
  else
  {
    if ( (typeof(r)=="matrix") || (typeof(r)=="intmat") )
    {
      if ( nrows(r)==ncols(r) ) //the input is a square matrix
      {
        tails = matrix(r);
      }
      else
      {
        novalid = 1;
      }
    }
    else
    {
      novalid=1;
    }
  }
  if (novalid==0)
  {
    intmat IM = SimplMat(tails);
    if ( size(IM)>1 )
    {
      int n  = ncols(tails);
      int m  = nrows(IM)-1;
      int m1 = 0;
      int m2 = m;
      int m3 = 0;
      ring simplexring=(real,10),(x),lp;// The simplex procedure requires a basering of this type
      matrix M = IM;
      list sol = simplex (M,m,n,m1,m2,m3);
      return(weightvector(sol));
    }
    else
    {
      "Invalid input"; //usually because the input is a one variable ring
      return();
    }
  }
  else
  {
    "The input must be a ring or a square matrix";
    return();
  }
}
example
{
  "EXAMPLE:";echo=2;
  ring r = (0,q),(a,b,c,d),lp;
  matrix C[4][4];
  C[1,2]=q; C[1,3]=q; C[1,4]=1; C[2,3]=1; C[2,4]=q; C[3,4]=q;
  matrix D[4][4];
  D[1,4]=(q-1/q)*b*c;
  ncalgebra(C,D);
  r;
  Gweights(r);
  Gweights(D);
}

///////////////////////////////////////////////////////////////////////////////

// This procedure take a ring r, call to Gweights(r) and use the output
// of Gweights(r) to make a change of order in r
// The output is a new ring, equal to r but the order
// r must be a G-algebra

proc weightedRing(def r)
"USAGE:   weightedRing(r); r a ring
RETURN:  ring
PURPOSE:  equip the variables of a ring with such weights,that the relations of new ring (with weighted variables) satisfies the ordering condition for G-algebras
NOTE:    activate this ring with the \"setring\" command
EXAMPLE: example weightedRing; shows examples
SEE ALSO: Gweights
"{
  def wv=Gweights(r);
  if (typeof(wv)=="intvec")
  {
    setring r;
    int n=nvars(r);
    // Generating an nxn-intmat order
    intmat m[n][n];
    m[1,1]=wv[1];
    int i;
    for (i=2; i<=n; i++)
    {
      m[1,i]=wv[i];
      m[i,n+2-i]=1;
    }
    // End of generation.
    def lr=ncRelations(r);
    string newringstring="ring newring=("+charstr(r)+"),("+varstr(r)+"),M("+string(m)+")";
    execute (newringstring);
    def lnewring=imap(r,lr);
    ncalgebra(lnewring[1],lnewring[2]);
    return(newring);
  }
  else
  {
    "Invalid input.";//usually because the input is a one variable ring
    return();
  }
}
example
{
  "EXAMPLE:";echo=2;
  ring r = (0,q),(a,b,c,d),lp;
  matrix C[4][4];
  C[1,2]=q; C[1,3]=q; C[1,4]=1; C[2,3]=1; C[2,4]=q; C[3,4]=q;
  matrix D[4][4];
  D[1,4]=(q-1/q)*b*c;
  ncalgebra(C,D);
  r;
  def t=weightedRing(r);
  setring t; t;
}

///////////////////////////////////////////////////////////////////////////////

// This procedure computes ei+ej-f with f running in Newton(pij) and deletes the zero rows

static proc Cij(intmat M, int i,j)
{
  M=(-1)*M;
  int nc=ncols(M);
  intvec N;
  int k;
  for (k=1; k<=nrows(M); k++)
  {
    M[k,i]=M[k,i]+1;
    M[k,j]=M[k,j]+1;
    if (intvec(M[k,1..nc])!=0)
    {
      N=N,intvec(M[k,1..nc]);
    } // we only want non-zero rows
  }
  if (size(N)>1)
  {
    N=N[2..size(N)]; // Deleting the zero added in the definition of N
    M=intmat(N,size(N)/nc,nc); // Conversion from vector to matrix
  }
  else
  {
    intmat M[1][1]=0;
  }
  return (M);
}

///////////////////////////////////////////////////////////////////////////////

// This procedure run over the matrix of pij calculating Cij

static proc Ct(matrix P)
{
  int    k = ncols(P);
  intvec T = 0;
  int    i,j;
//  int notails=1;
  def S;
  for (j=2; j<=k; j++)
  {
    for (i=1; i<j; i++)
    {
      if ( P[i,j] != 0 )
      {
//        notails=0;
        S = newtonDiag(P[i,j]);
        S = Cij(S,i,j);
        if ( size(S)>1 )
        {
          T = T,S;
        }
      }
    }
  }
  if ( size(T)==1 )
  {
    intmat C[1][1] = 0;
  }
  else
  {
    T=T[2..size(T)]; // Deleting the zero added in the definition of T
    intmat C = intmat(T,size(T)/k,k); // Conversion from vector to matrix
  }
  return (C);
}

///////////////////////////////////////////////////////////////////////////////

// The purpose of this procedure is to produce the input matrix required by simplex procedure

static proc SimplMat(matrix P)
{
  intmat C=Ct(P);
  if (size(C)>1)
  {
    int r = nrows(C);
    int n = ncols(C);
    int f = 1+n+r;
    intmat M[f][n+1]=0;
    int i;
    for (i=2; i<=(n+1); i++)
    {
      M[1,i]=-1; // (0,-1,-1,-1,...) objective function in the first row
    }
    for (i=2; i<=f; i++) {M[i,1]=1;} // All the independent terms are 1
    for (i=2; i<=(n+1); i++) {M[i,i]=-1;} // wi>=1 is an identity matrix
    M[(n+2)..f,2..(n+1)]=(-1)*intvec(C); // <wi,a> >= 1, a in C ...
  }
  else
  {
    int n = ncols(P);
    int f = 1+n;
    intmat M[f][n+1]=0;
    int i;
    for (i=2; i<=(n+1); i++) {M[1,i]=-1;} // (0,-1,-1,-1,...) objective function in the first row
    for (i=2; i<=f; i++) {M[i,1]=1;} // All the independent terms are 1
    for (i=2; i<=(n+1); i++) {M[i,i]=-1;} // wi>=1 is an identity matrix
  }
  return (M);
}

///////////////////////////////////////////////////////////////////////////////

// This procedure generates a nice output of the simplex method consisting of a vector
// with the solutions. The vector is ordered.

static proc weightvector(list l)
"ASSUME:  l is the output of simplex.
RETURN: if there is a solution, an intvec with it will be returned"
{
  matrix m=l[1];
  intvec nv=l[3];
  int sol=l[2];
  int rows=nrows(m);
  int N=l[6];
  intmat wv[1][N]=0;
  int i;
  if (sol)
  {
    "no solution satisfies the given constraints";
  }
  else
  {
    for ( i = 2; i <= rows; i++ )
    {
      if ( nv[i-1] <= N )
      {
        wv[1,nv[i-1]]=int(m[i,1]);
      }
    }
  }
  return (intvec(wv));
}



///////////////////////////////////////////////////////////////////////////////

// This procedure recover the non-conmutative relations (matrices C and D)

proc ncRelations(def r)
"USAGE:   ncRelations(r); r a ring
RETURN:  list L with two elements, both elements are of type matrix:
@*         L[1] = matrix of coefficients C,
@*         L[2] = matrix of polynomials D
PURPOSE: recover the noncommutative relations via matrices C and D from
a noncommutative ring
SEE ALSO: ringlist, G-algebras
EXAMPLE: example ncRelations; shows examples
"{
  list l;
  if (typeof(r)=="ring")
  {
    int n=nvars(r);
    matrix C[n][n]=0;
    matrix D[n][n]=0;
    poly f; poly g;
    if (n>1)
    {
      int i,j;
      for (i=2; i<=n; i++)
      {
        for (j=1; j<i; j++)
        {
          f=var(i)*var(j); // yx=c*xy+...
          g=var(j)*var(i); // xy
          while (C[j,i]==0)
          {
            if (leadmonom(f)==leadmonom(g))
            {
              C[j,i]=leadcoef(f);
              D[j,i]=D[j,i]+f-lead(f);
            }
            else
            {
              D[j,i]=D[j,i]+lead(f);
              f=f-lead(f);
            }
          }
        }
      }
      l=C,D;
    }
    else { "The ring must have two or more variables"; }
  }
  else { "The input must be of a type ring";}
  return (l);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y,z),dp;
  matrix C[3][3]=0,1,2,0,0,-1,0,0,0;
  print(C);
  matrix D[3][3]=0,1,2y,0,0,-2x+y+1;
  print(D);
  ncalgebra(C,D);
  r;
  def l=ncRelations(r);
  print (l[1]);
  print (l[2]);
}

///////////////////////////////////////////////////////////////////////////////

proc findimAlgebra(matrix M, list #)
"USAGE:   findimAlgebra(M,[r]); M a matrix, r an optional ring
RETURN:  nothing
PURPOSE: define a finite dimensional algebra structure on a ring
NOTE:  the matrix M is used to define the relations x(j)*x(i) = M[i,j] in the
basering (by default) or in the optional ring r.
@* The procedure equips the ring with the noncommutative structure.
@* The procedure exports the ideal (not a two-sided Groebner basis!), called @code{fdQuot}, for further qring definition.
THEORY: finite dimensional algebra can be represented as a factor algebra
of a G-algebra modulo certain two-sided ideal. The relations of a f.d. algebra are thus naturally divided into two groups: firstly, the relations
on the variables of the ring, making it into G-algebra and the rest of them, which constitute the ideal which will be factored out.
EXAMPLE: example findimAlgebra; shows examples
"
{
  if (size(#) >0)
  {
    if ( typeof(#[1])!="ring" ) { return();}
    else
    {
      def @R1 = #[1];
      setring @R1;
    }
  }
  int i,j;
  int n=nvars(basering);
  poly p;
  ideal I;
  number c;
  matrix C[n][n];
  matrix D[n][n];
  for (i=1; i<=n; i++)
  {
    for (j=i; j<=n; j++)
    {
      p=var(i)*var(j)-M[i,j];
      if ( (size(I)==1) && (I[1]==0) )   { I=p; }
      else { I=I,p; }
      if (j>i)
      {
        if ((M[i,j]!=0) && (M[j,i]!=0))
        {
          c = leadcoef(M[j,i])/leadcoef(M[i,j]);
        }
        else
        {
          c = 1;
        }
        C[i,j]=c;
        D[i,j]= - M[j,i] +c*M[i,j];
      }
    }
  }
  ncalgebra(C,D);
  ideal fdQuot = I;
  export fdQuot;
}
example
{
  "EXAMPLE:";echo=2;
  ring r=(0,a,b),(x(1..3)),dp;
  matrix S[3][3];
  S[2,3]=a*x(1); S[3,2]=-b*x(1);
  findimAlgebra(S);
  fdQuot = twostd(fdQuot);
  qring Qr = fdQuot;
  Qr;
}

///////////////////////////////////////////////////////////////////////////////

proc isCentral(poly p, list #)
"USAGE:   isCentral(p); p poly
RETURN:  int, 1 if p commutes with all variables and 0 otherwise
PURPOSE: check whether p is central in a basering (that is, commutes with every generator of a ring)
NOTE: if @code{printlevel} > 0, the procedure displays intermediate information (by default, @code{printlevel}=0 )
EXAMPLE: example isCentral; shows examples
"{
  //v an integer (with v!=0, procedure will be verbose)
  int N = nvars(basering);
  int in;
  int flag = 1;
  poly   q = 0;
  for (in=1; in<=N; in++)
  {
    q = p*var(in)-var(in)*p;
    if (q!=0)
    {
      if ( (size(#) >0 ) || (printlevel>0) )
      {
        "Noncentral at:", var(in);
      }
      flag = 0;
    }
  }
  return(flag);
}
example
{
  "EXAMPLE:";echo=2;
  ring r=0,(x,y,z),dp;
  matrix D[3][3]=0;
  D[1,2]=-z;
  D[1,3]=2*x;
  D[2,3]=-2*y;
  ncalgebra(1,D); // this is U(sl_2)
  poly c = 4*x*y+z^2-2*z;
  printlevel = 0;
  isCentral(c);
  poly h = x*c;
  printlevel = 1;
  isCentral(h);
}

///////////////////////////////////////////////////////////////////////////////

proc UpOneMatrix(int N)
"USAGE:   UpOneMatrix(n); n an integer
RETURN:  intmat
PURPOSE: compute an  n x n matrix with 1's in the whole upper triangle
NOTE: helpful for setting noncommutative algebras with complicated
coefficient matrices
EXAMPLE: example UpOneMatrix; shows examples
"{
  int ii,jj;
  intmat U[N][N]=0;
  for (ii=1;ii<N;ii++)
  {
    for (jj=ii+1;jj<=N;jj++)
    {
      U[ii,jj]=1;
    }
  }
  return(U);
}
example
{
  "EXAMPLE:";echo=2;
  ring   r = (0,q),(x,y,z),dp;
  matrix C = UpOneMatrix(3);
  C[1,3]   = q;
  print(C);
  ncalgebra(C,0);
  r;
}

///////////////////////////////////////////////////////////////////////////////
proc ndcond(list #)
"USAGE:   ndcond();
RETURN:  ideal
PURPOSE: compute the non-degeneracy conditions of the basering
NOTE: if @code{printlevel} > 0, the procedure displays intermediate information (by default, @code{printlevel}=0 )
EXAMPLE: example ndcond; shows examples
"
{
  // internal documentation, for tests etc
  // 1st arg: v an optional integer (if v!=0, will be verbose)
  // if the second argument is given, produces ndc wrt powers x^N
  int N = 1;
  int Verbose = 0;
  if ( size(#)>=1 ) { Verbose = int(#[1]); }
  if ( size(#)>=2 ) { N = int(#[2]); }
  Verbose = ((Verbose) || (printlevel>0));
  int cnt = 1;
  int numvars = nvars(basering);
  int a,b,c;
  poly p = 1;
  ideal res = 0;
  for (cnt=1; cnt<=N; cnt++)
  {
    if (Verbose) { "Processing degree :",cnt;}
    for (a=1; a<=numvars-2; a++)
    {
      for (b=a+1; b<=numvars-1; b++)
      {
        for(c=b+1; c<=numvars; c++)
        {
          p = (var(c)^cnt)*(var(b)^cnt);
          p = p*(var(a)^cnt);
          p = p-(var(c)^cnt)*((var(b)^cnt)*(var(a)^cnt));
          if (Verbose) {a,".",b,".",c,".";}
          if (p!=0)
          {
            if ( res==0 )
            {
              res[1] = p;
            }
            else
            {
              res = res,p;
            }
            if (Verbose) { "failed:",p; }
          }
        }
      }
    }
    if (Verbose) { "done"; }
  }
  return(res);
}
example
{
  "EXAMPLE:";echo=2;
  ring r = (0,q1,q2),(x,y,z),dp;
  matrix C[3][3];
  C[1,2]=q2; C[1,3]=q1; C[2,3]=1;
  matrix D[3][3];
  D[1,2]=x; D[1,3]=z;
  ncalgebra(C,D);
  r;
  ideal j=ndcond(); // the silent version
  j;
  printlevel=1;
  ideal i=ndcond(); // the verbose version
  i;
}


///////////////////////////////////////////////////////////////////////////////
proc Weyl(list #)
"USAGE:   Weyl([p]); p an optional integer
RETURN:  nothing
PURPOSE: create a Weyl algebra structure on a basering
NOTE: suppose the number of variables of a basering is 2k.
(if this number is odd, an error message will be returned)
@*    by default, the procedure treats first k variables as coordinates x_i and the last k as differentials d_i
@*    if nonzero p is given, the procedure treats 2k variables of a basering as k pairs (x_i,d_i), i.e. variables with odd numbers are treated as coordinates and with even numbers as differentials
SEE ALSO: makeWeyl
EXAMPLE: example Weyl; shows examples
"
{
  //there are two possibilities for choosing the PBW basis.
  //The variables have names x(i) for coordinates and d(i) for partial
  // differentiations. By default, the procedure
  //creates a ring, where the variables are ordered as x(1..n),d(1..n).  the
  // tensor product-like realization x(1),d(1),x(2),d(2),... is used.
  string rname=nameof(basering);
  if ( rname == "basering") // i.e. no ring has been set yet
  {
    "You have to call the procedure from the ring";
    return();
  }
  int @chr = 0;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @chr = #[1];
    }
  }
  int nv = nvars(basering);
  int N = nv div 2;
  if ((nv % 2) != 0)
  {
    "Cannot create Weyl structure for an odd number of generators";
    return();
  }
  matrix @D[nv][nv];
  int i;
  for ( i=1; i<=N; i++ )
  {
    if ( @chr==0 ) // default
    {
      @D[i,N+i]=1;
    }
    else
    {
      @D[2*i-1,2*i]=1;
    }
  }
  ncalgebra(1,@D);
  return();
}
example
{
  "EXAMPLE:";echo=2;
  ring A1=0,(x(1..2),d(1..2)),dp;
  Weyl();
  A1;
  kill A1;
  ring B1=0,(x1,d1,x2,d2),dp;
  Weyl(1);
  B1;
}

///////////////////////////////////////////////////////////////////////////////
proc makeHeisenberg(int N, list #)
"USAGE:  makeHeisenberg(n, [p,d]); int n (setting 2n+1 variables), optional int p (field characteristic), optional int d (power of h in the commutator)
RETURN: nothing
PURPOSE: create an n-th Heisenberg algebra in the variables x(1),y(1),...,x(n),y(n),h
SEE ALSO: makeWeyl
NOTE: activate this ring with the \"setring\" command
EXAMPLE: example makeHeisenberg; shows examples
"
{
  int @chr = 0;
  int @deg = 1;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @chr = #[1];
    }
  }
  if ( size(#) > 1 )
  {
    if ( typeof( #[2] ) == "int" )
    {
      @deg = #[2];
      if (@deg <1) { @deg = 1; }
    }
  }
  ring @@r=@chr,(x(1..N),y(1..N),h),lp;
  matrix D[2*N+1][2*N+1];
  int i;
  for (i=1;i<=N;i++)
  {
    D[i,N+i]=h^@deg;
  }
  ncalgebra(1,D);
  return(@@r);
}
example
{
  "EXAMPLE:";echo=2;
  def a = makeHeisenberg(2);
  setring a;   a;
  def H3 = makeHeisenberg(3, 7, 2);
  setring H3;  H3;
}

///////////////////////////////////////////////////////////////////////////////
proc Exterior(list #)
"USAGE:   Exterior();
RETURN:  qring
PURPOSE:  create the exterior algebra of a basering
NOTE:  activate this qring with the \"setring\" command
THEORY: given a basering, this procedure introduces the anticommutative relations x(j)x(i)=-x(i)x(j) for all j>i,
@* moreover, creates a factor algebra modulo the two-sided ideal, generated by x(i)^2 for all i
EXAMPLE: example Exterior; shows examples
"
{
  string rname=nameof(basering);
  if ( rname == "basering") // i.e. no ring has been set yet
  {
    "You have to call the procedure from the ring";
    return();
  }
  int N = nvars(basering);
  string NewRing = "ring @R=("+charstr(basering)+"),("+varstr(basering)+"),("+ordstr(basering)+");";
  execute(NewRing);
  matrix @E = UpOneMatrix(N);
  @E = -1*(@E);
  ncalgebra(@E,0);
  int i;
  ideal Q;
  for ( i=1; i<=N; i++ )
  {
    Q[i] = var(i)^2;
  }
  Q = twostd(Q);
  qring @EA = Q;
  return(@EA);
}
example
{
  "EXAMPLE:";echo=2;
  ring R = 0,(x(1..3)),dp;
  def ER = Exterior();
  setring ER;
  ER;
}

///////////////////////////////////////////////////////////////////////////////
proc makeWeyl(int n, list #)
"USAGE:  makeWeyl(n,[p]); n an integer, n>0; p an optional integer (field characteristic)
RETURN:  ring
PURPOSE: create an n-th Weyl algebra
NOTE:    activate this ring with the \"setring\" command.
@*       The presentation of an n-th Weyl algebra is classical: D(i)x(i)=x(i)D(i)+1,
@*       where x(i) correspond to coordinates and D(i) to partial differentiations, i=1,...,n.
SEE ALSO: Weyl
EXAMPLE: example makeWeyl; shows examples
"{
  if (n<1)
  {
    print("Incorrect input");
    return();
  }
  int @p = 0;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @p = #[1];
    }
  }
  if (n ==1)
  {
    ring @rr = @p,(x,D),dp;
  }
  else
  {
    ring @rr = @p,(x(1..n),D(1..n)),dp;
  }
  setring @rr;
  Weyl();
  return(@rr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a = makeWeyl(3);
   setring a;
   a;
}

//////////////////////////////////////////////////////////////////////
proc isNC()
"USAGE:   isNC();
PURPOSE: check whether a basering is commutative or not
RETURN:   int, 1 if basering is noncommutative and 0 otherwise
EXAMPLE: example isNC; shows examples
"{
  string rname=nameof(basering);
  if ( rname == "basering") // i.e. no ring has been set yet
  {
    "You have to call the procedure from the ring";
    return();
  }
  int n = nvars(basering);
  int i,j;
  poly p;
  for (i=1; i<n; i++)
  {
    for (j=i+1; j<=n; j++)
    {
      p = var(j)*var(i) - var(i)*var(j);
      if (p!=0) { return(1);}
    }
  }
  return(0);
}
example
{ "EXAMPLE:"; echo = 2;
   def a = makeWeyl(2);
   setring a;
   isNC();
   kill a;
   ring r = 17,(x(1..7)),dp;
   isNC();
   kill r;
}

//////////////////////////////////////////////////////////////////////
