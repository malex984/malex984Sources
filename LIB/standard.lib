// $Id: standard.lib,v 1.10 1998-05-14 18:45:16 Singular Exp $
///////////////////////////////////////////////////////////////////////////////

version="$Id: standard.lib,v 1.10 1998-05-14 18:45:16 Singular Exp $";
info="
LIBRARY: standard.lib   PROCEDURES WHICH ARE ALWAYS LOADED AT START-UP

 stdfglm(ideal[,ord])   standard basis of the ideal via fglm [and ordering ord]
 stdhilbert(ideal)      standard basis of the ideal using the Hilbert function
";

///////////////////////////////////////////////////////////////////////////////

proc stdfglm (ideal i, list #)
"USAGE:   stdfglm(i[,s]); i ideal, s string (any allowed ordstr of a ring)
RETURN:  stdfglm(i): standard basis of i in the basering, calculated via fglm
                     from ordering \"dp\" to the ordering of the basering.
         stdfglm(i,s): standard basis of i in the basering, calculated via
                     fglm from ordering s to the ordering of the basering.
EXAMPLE: example stdfglm; shows an example"
{
   string os;
   def dr= basering;
   if( (size(#)==0) or (typeof(#[1]) != "string") )
   {
     os = "dp(" + string( nvars(dr) ) + ")";
     if ( (find( ordstr(dr), os ) != 0) and (find( ordstr(dr), "a") == 0) )
     {
       os= "Dp";
     }
     else
     {
       os= "dp";
     }
   }
   else { os = #[1]; }
   execute "ring sr=("+charstr(dr)+"),("+varstr(dr)+"),"+os+";";
   ideal i= fetch(dr,i);
   intvec opt= option(get);
   option(redSB);
   i=std(i);
   option(set,opt);
   setring dr;
   return (fglm(sr,i));
}
example
{ "EXAMPLE:"; echo = 2;
   ring r  = 0,(x,y,z),lp;
   ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
   ideal i1= stdfglm(i);         //uses fglm from "dp" to "lp"
   i1;
   ideal i2= stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
   i2;
}
///////////////////////////////////////////////////////////////////////////////

proc stdhilbert(ideal i,list #)
"USAGE:   stdhilbert(i);  i ideal
         stdhilbert(i,v); i homogeneous ideal, v intvec (the Hilbert function)
RETURN:  stdhilbert(i): a standard basis of i (computing v internally)
         stdhilbert(i,v): standard basis of i, using the given Hilbert function
EXAMPLE: example stdhilbert; shows an example"
{
   def R=basering;

   if((homog(i)==1)||(ordstr(basering)[1]=="d"))
   {
      if ((size(#)!=0)&&(homog(i)==1))
      {
         return(std(i,#[1]));
      }
      return(std(i));
   }

   execute "ring S = ("+charstr(R)+"),("+varstr(R)+",@t),dp;";
   ideal i=homog(imap(R,i),@t);
   intvec v=hilb(std(i),1);
   execute "ring T = ("+charstr(R)+"),("+varstr(R)+",@t),("+ordstr(R)+");";
   ideal i=fetch(S,i);
   ideal a=std(i,v);
   setring R;
   map phi=T,maxideal(1),1;
   ideal a=phi(a);

   int k,j;
   poly m;
   int c=size(i);

   for(j=1;j<c;j++)
   {
     if(deg(a[j])==0)
     {
       a=ideal(1);
       attrib(a,"isSB",1);
       return(a);
     }
     if(deg(a[j])>0)
     {
       m=lead(a[j]);
       for(k=j+1;k<=c;k++)
       {
          if(size(lead(a[k])/m)>0)
          {
            a[k]=0;
          }
       }
     }
   }
   a=simplify(a,2);
   attrib(a,"isSB",1);
   return(a);
}
example
{ "EXAMPLE:"; echo = 2;
   ring  r = 0,(x,y,z),lp;
   ideal i = y3+x2, x2y+x2, x3-x2, z4-x2-y;
   ideal i1= stdhilbert(i); i1;
   // is in this case equivalent to:
   intvec v=1,0,0,-3,0,1,0,3,-1,-1;
   ideal i2=stdhilbert(i,v);
}
///////////////////////////////////////////////////////////////////////////////

