version="$Id: control.lib,v 1.18 2004-12-16 16:28:53 levandov Exp $";
category="Applications";
info="
LIBRARY:  control.lib Procedures for System and Control Theory 
AUTHORS:  Oleksandr Iena       yena@mathematik.uni-kl.de
@*        Markus Becker        mbecker@mathematik.uni-kl.de
@*        Viktor Levandovskyy  levandov@mathematik.uni-kl.de

SUPPORT: Forschungsschwerpunkt 'Mathematik und Praxis' (Project of Dr. E. Zerz
and V. Levandovskyy), Uni Kaiserslautern

NOTE: This library provides algebraic analysis tools for System and Control Theory

PROCEDURES:
control(module R);            analysis of controllability-related properties of R,
autonom(module R);            analysis of autonomy-related properties of R (using Ext modules),
autonom2(module R);           analysis of autonomy-related properties of R (using dimension),
LeftKernel(module R);         a left kernel of R,
RightKernel(module R);        a right kernel of R,
LeftInverse(module R)         a left inverse of matrix (module),

smith(module M);              a Smith form of a module M.

AUXILIARY PROCEDURES:
ncdetection(ring r);          computes an ideal, presenting an involution map on non-comm algebra r;
involution(m, map theta);    applies the involution, presented by theta to m of type poly, vector, ideal, module;
declare(string NameOfRing, Variables[,string  Parameters, Ordering]);     defines the ring, optional parametes are strings of parameters and ordering,
view();                      Well-formatted output of lists, modules and matrixes

NOTE (EXAMPLES): In order to use examples below, execute the commands
@* def A = exAntenna(); setring A; 
@* Thus A will become a basering from the example with the predefined module R (transposed), corresponding to the system. 
After that you can just type in 
@* control(R); //respectively autonom(R); 
and check the result.


EXAMPLES (AUTONOMY):

exCauchy();                  example of 1-dimensional Cauchy equation,
exCauchy2();                 example of 2-dimensional Cauchy equation,
exZerz();                    example from the lecture of Eva Zerz,

EXAMPLES (CONTROLLABILITY):

ex1();                       example of noncontrollable system,   
ex2();                       example of controllable system ,
exAntenna();                 Antenna,
exEinstein();                Einstein equations,
exFlexibleRod();             Flexible Rod,
exTwoPendula();              Two Pendula,
exWindTunnel();              Wind Tunnel. 
";

// NOTE: static things should not be shown for end-user
// static Ext_Our(...)                  Copy of Ext_R from 'homolog.lib' in commutative case;
// static is_zero_Our(module R)         Copy of is_zero from 'OBpoly.lib';
//  static space(int n)           Procedure used inside the procedure 'Print' to have a better formatted output
// static control_output();      Generating the output for the procedure 'control'
// static autonom_output();      Generating the output for the procedure 'autonom' and 'autonom2'

LIB "homolog.lib"; 
LIB "poly.lib";
LIB "primdec.lib";
LIB "matrix.lib";
// -- noncommutative procs:
LIB "ncalg.lib";
LIB "nctools.lib";
LIB "nchomolog.lib"; 
LIB "gkdim.lib";
//---------------------------------------------------------------
proc declare(string NameOfRing, string Variables, list #)
"USAGE: declare(NameOfRing, Variables,[Parameters, Ordering]);
          NameOfRing:  string with name of ring,
	  Variables:   string with names of variables separated by commas(e.g. "x,y,z"),
	  [Parameters, Ordering]: optional, strings:
	    Parameters: string of parameters in the ring separated by commas(e.g. "a,b,c"),
	    Ordering:   string with name of ordering(by default the ordering "dp,C" is used)
RETURN:  no return value
EXAMPLE:  example declare; shows an example 
"
{
  if(size(#)==0)
  {
    execute("ring "+NameOfRing+"=0,("+Variables+"),dp;");
  }
  else
  {
    if(size(#)==1)
    {
      execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),dp;" );
    }
    else
    { 
      if( (size(#[1])!=0)&&(#[1]!=" ") )
      {
        execute( "ring " + NameOfRing + "=(0," + #[1] + "),(" + Variables + "),("+#[2]+");" );
      }
      else
      {
        execute( "ring " + NameOfRing + "=0,("+Variables+"),("+#[2]+");" ); 
      };
    };
  };
  keepring(basering);
}
example
{"EXAMPLE:";echo = 2;
  string v="x,y,z";
  string p="q,p";
  string Ord ="c,lp";
 
  declare("Ring_1",v);
  print(nameof(basering));
  print(basering);
  
  declare("Ring_2",v,p);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_3",v,p,Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_4",v,"",Ord);
  print(basering);
  print(nameof(basering));
  
  declare("Ring_5",v," ",Ord);
  print(basering);
  print(nameof(basering));
};
//
//maybe reasonable to add this in declare
//
//  print("Please enter your representation matrix in the following form: 
//  module R=[1st row],[2nd row],...");
//  print("Type the command: R=transpose(R)");
//  print(" To compute controllability please enter: control(R)");
//  print(" To compute autonomy please enter: autonom(R)");
//
//
//
//-------------------------------------------------------------------------
static proc space(int n)
"USAGE:spase(n); 
         n: integer, number of needed spaces
RETURN:  string consisting of n spaces
NOTE:  the procedure is used in the procedure 'view' to have a better formatted output
"
{
  int i;
  string s="";
  for(i=1;i<=n;i++)
  {
    s=s+" ";
  };
  return(s);
};
//-----------------------------------------------------------------------------
proc view(M)
"USAGE:  view(M);
           M:  any type
RETURN:  no return value
PURPOSE:  procedure for ( well-) formatted output of modules, matrices, lists of modules, matrices;
          shows everything even if entries are long
NOTE:  in case of other types( not 'module', 'matrix', 'list') works just as standard 'print' procedure  
EXAMPLE:  example view; shows an example
"
{
  if ( (typeof(M)=="module")||(typeof(M)=="matrix") )
  {
  int @R=nrows(M);
  int @C=ncols(M);
  int i;
  int j;
  list MaxLength=list();
  int Size=0;
  int max;
  string s;
  
  for(i=1;i<=@C;i++)
  { 
    max=0; 
    
    for(j=1;j<=@R;j++)
    {
      Size=size( string( M[j,i] ) );
      if( Size>max )
      {
        max=Size;
      };
    };
    MaxLength[i] = max;
  };
  
  for(i=1;i<=@R;i++)
  {
    s="";
    for(j=1;j<@C;j++)
    {
      s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) ) +",";
    };
    
    s=s+string(M[i,j])+space( MaxLength[j]-size( string( M[i,j] ) ) );

    if (i!=@R)
    {
      s=s+",";
    };
    print(s);
  };

  return();    
  };
  
  if(typeof(M)=="list")
  {
    int sz=size(M);
    int i;
    for(i=1;i<=sz;i++)
    {
      view(M[i]);
      print("");
    }; 

    return();
  };
  print(M);
  return();
}
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[1][3] = x,y,z;
  print(M);
  view(M);
};
//--------------------------------------------------------------------------
proc RightKernel(matrix M)
"USAGE:  RightKernel(M);
           M:  matrix
RETURN:  right kernel of matrix M, i.e., the module of all elements v such that Mv=0
NOTE:  in commutative case it is a left  module, in noncommutative (will be implemented later) it is a right module   
EXAMPLE:  example RightKernel; shows an example
"
{ 
  return(modulo(M,std(0)));
}
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[1][3] = x,y,z;
  print(M);
  print( RightKernel(M) );
};
//-------------------------------------------------------------------------
proc LeftKernel(matrix M)
"USAGE:  LeftKernel(M);
           M:  matrix
RETURN:  left kernel of matrix M, i.e., the matrix whose rows are generators of left module
         (elements of this module are to be rows) of all elements v such that vM=0   
EXAMPLE:  example LeftKernel; shows an example
"
{
  return( transpose( modulo( transpose(M),std(0) ) ) );
}
example
{"EXAMPLE:";echo = 2;
  ring r;
  matrix M[3][1] = x,y,z;
  print(M);
  print( LeftKernel(M) );
};
//------------------------------------------------------------------------
proc LeftInverse(module M)
"USAGE:  LeftInverse(M);  M a module
RETURN:  matrix L such that LM == Id;
EXAMPLE:  example LeftInverse; shows an example
NOTE: exists only in the case when Id \subseteq M!
"
{
  // now it works also for the NC case;
  int NCols=ncols(M);
  module Id = freemodule(NCols);
  M = transpose(M);
  Id = std(Id);
  matrix T;
  option(redSB);
  option(redTail);
  // check the correctness:
  // Id \subseteq M
  module N = liftstd(M, T);
  ideal TT = ideal(NF(N,Id));
  TT = simplify(TT,2);

  if (TT[1]!=0)
  {
    "No left inverse exists";
    return(matrix(0));
  }
  matrix T2 = lift(N, Id);
  T2 = transpose(T2)*transpose(T);
  T2 =  transpose(T2);
  return(T2);
}
example
{"EXAMPLE:";echo =2;
  ring r;
  matrix M[2][1] = 1,x2z;
  print(M);
  print( LeftInverse(M) );  
};
//-----------------------------------------------------------------------
static proc dim_Our(module R)
{
  int d;
  if (Is_NC())
  {
    d = GKdim(R);
  }
  else { d = dim(R); }
  return(d);
}
//-----------------------------------------------------------------------
static proc Ann_Our(module R)
{
  if (Is_NC())
  {
    return(-1);
  }
  else
  {
    return(Ann(R));
  }

}
//-----------------------------------------------------------------------
static proc Ext_Our(int i, module R, list #)
// just a copy of 'Ext_R' from "homolog.lib" in commutative case
{
  int ISNC = Is_NC();
  int ExtraArg = ( size(#)>0 );
  if (ISNC)
  {
    // ExtraArg not yet implemented and thus ignored
    return( ncExt_R(i,R) );
  }
  // the commutative case:
  if (ExtraArg)
  {
    return( Ext_R(i,R,#[1]) );
  }
  else
  {
    return( Ext_R(i,R) );
  }
}
//------------------------------------------------------------------------
static proc is_zero_Our
//just a copy of 'is_zero' from "poly.lib" patched with GKdim
{
  int d = dim_Our(std(#[1]));
  int a = ( d==-1 );
  if( size(#) >1 ) { list L=a,d; return(L); }
  return(a);
  //  return( is_zero(R) ) ;
};
//------------------------------------------------------------------------
static proc control_output(int i, int NVars, module R, module Ext_1) 
"USAGE:  proc control_output(i, NVars, R, Ext_1)
           i:  integer, number of first nonzero Ext or 
	       just number of variables in a base ring + 1 in case that all the Exts are zero
	   NVars:  integer, number of variables in a base ring  
	   R:  module R (cokernel representation)
	   Ext_1:  module, the first Ext(its cokernel representation)      
RETURN:  list with all the contollability properties of the system which is to be returned in 'control' procedure
NOTE:  this procedure is used in 'control' procedure
"
{
  int d = dim_Our( std( transpose(R) ) ) ;; //this is the dimension of the system 
  string DofS= "dimension of the system:";
  string Fn= "number of first nonzero Ext:";
  if(i==1)
  { 
    module RK = RightKernel(R);
    return( 
            list ( Fn,
	           i,
	          "not controllable , image representation for controllable part:",
         	   RK,	    
	          "kernel representation for controllable part:",
		   LeftKernel( RK ),
		  "obstruction to controllability",
		   Ext_1,
		  "annihilator of torsion module (of obstruction to controllability)",
		   Ann_Our(Ext_1),
		   DofS,
		   d
		 ) 
          );
  };
  
  if(i>NVars)
  { module RK =RightKernel(R); 
    return( list(  Fn,
                   -1, 
                  "strongly controllable, image representation:",
		   RK,
		  "left inverse to image representation:",
		   LeftInverse(RK),
		   DofS, 
		   d) 
          );
  };
  
  //
  //now i<=NVars
  //
       
  if( (i==2) )
  {
    return( list( Fn,
                  i, 
                 "controllable, not reflexive, image representation:",
		  RightKernel(R),
                  DofS,
                  d ) 
          ); 
  };
    
  if( (i>=3) )
  {
    return( list ( Fn,
                   i, 
                  "reflexive, not strongly controllable, image representation:",
		   RightKernel(R),
		   DofS,
		   d) 
          );
  };
              
  
};  
//-------------------------------------------------------------------------

proc control(module R)
"USAGE:  control(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning controllability of the system(behavior) represented by the  matrix R
EXAMPLE:  example control; shows an example
"
{
  int i;
  int NVars=nvars(basering); 
  int ExtIsZero;
 
       
  module Ext_1 = std(Ext_Our(1,R));
   
  ExtIsZero=is_zero_Our(Ext_1);
  i=1;
  while( (ExtIsZero) && (i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our( Ext_Our(i,R) );
  };
  
  return( control_output( i, NVars, R, Ext_1 ) );
}
example
{"EXAMPLE:";echo = 2; 
  //Wind Tunnel
  ring A = (0,a, omega, zeta, k),(D1, delta),dp;
  module R;
  R = [D1+a, -k*a*delta, 0, 0],
      [0, D1, -1, 0],
      [0, omega^2, D1+2*zeta*omega, -omega^2];
  R=transpose(R);
  view(R);
  view(control(R));

};
//------------------------------------------------------------------------
static proc autonom_output( int i, int NVars ) 
"USAGE:  proc autonom_output(i, NVars)
           i:  integer, number of first nonzero Ext or 
	       just number of variables in a base ring + 1 in case that all the Exts are zero
	   NVars:  integer, number of variables in a base ring  
RETURN:  list with all the autonomy properties of the system which is to be returned in 'autonom' procedure
NOTE:  this procedure is used in 'autonom' procedure
"
{
  int d=NVars-i;//that is the dimension of the system
  string DofS="dimension of the system:";
  string Fn = "number of first nonzero Ext:";
  if(i==0)
  { 
    return( list(  Fn,
                   i,
                  "not autonomous",
		   DofS,
		   d ) 
	  );
  };
  
  if( i>NVars )
  {  
    return( list( Fn,
                  -1,
                  "trivial",
		  DofS,
		  d ) 
          );
  };
  
  //
  //now i<=NVars
  //
    
     
  if( i==1 )
  //in case that NVars==1 there is no sence to consider the notion
  //of strongly autonomous behavior, because it does not imply 
  //that system is overdetermined in this case
  {
    return( list ( Fn,
                   i, 
                  "autonomous, not overdetermined",
		   DofS,
		   d ) 
          ); 
  };
    
  if( i==NVars )
  {  
    return( list(  Fn,
                   i,
                  "strongly autonomous,in particular overdetermined",
		   DofS,
		   d) 
	  );
  };
  
  if( i<NVars )
  {
    return( list ( Fn,
                   i,
                  "overdetermined, not strongly autonomous",
		   DofS, 
		   d) 
          );
  };
    
};  
//--------------------------------------------------------------------------
proc autonom2(module R)
"USAGE:  autonom2(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning autonomy of the system(behavior) represented by the  matrix R
NOTE:  this procedure is an analogue to 'autonom' using dimension calculations
EXAMPLE:  example autonom2; shows an example
"
{ 
  int d;
  int NVars = nvars(basering);
  R = transpose(R);
  d = dim_Our( std(R) );
  return( autonom_output(NVars-d,NVars) );
}
example
{"EXAMPLE:"; echo = 2;
  //Cauchy
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  view( R );
  view( autonom2(R) );
};  
//---------------------------------------------------------------------------

proc autonom(module R)
"USAGE:  autonom(R);
           R:  module (R is a matrix of the system of equations which is to be investigated)
RETURN:  list of all the properties concerning autonomy of the system(behavior) represented by the  matrix R
EXAMPLE:  example autonom; shows an example
"
{
  int NVars=nvars(basering);
  int ExtIsZero;    
  R=transpose(R); 
  ExtIsZero=is_zero_Our(Ext_Our(0,R)); 
  int i=0;
  while( (ExtIsZero)&&(i<=NVars) )
  {
    i++;
    ExtIsZero = is_zero_Our(Ext_Our(i,R));
  };

  return(autonom_output(i,NVars));     
}
example
{"EXAMPLE:"; echo = 2;
  //Cauchy
  ring r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  view( R );
  view( autonom(R) );
};  

//--------------------------------------------------------------------------
//
//Some example rings with defined systems
//----------------------------------------------------------------------------
//autonomy:
//
//----------------------------------------------------------------------------
proc exCauchy()
{
  ring @r=0,(s1,s2),dp;
  module R= [s1,-s2],
            [s2, s1];
  R=transpose(R);
  export R;
  return(@r);	    
};
//----------------------------------------------------------------------------
proc exCauchy2()
{
  ring @r=0,(s1,s2,s3,s4),dp;
  module R= [s1,-s2],
            [s2, s1],
	    [s3,-s4],
	    [s4, s3];	    
  R=transpose(R);
  export R;
  return(@r);	    
}; 
//----------------------------------------------------------------------------
proc exZerz()
{ 
  ring @r=0,(d1,d2),dp;
  module R=[d1^2-d2],
           [d2^2-1];
  R=transpose(R);
  export R;
  return(@r);	    
};  
//----------------------------------------------------------------------------
//control
//
proc ex1()
{
  ring @r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
           [s3,0,-s1];
  R=transpose(R);	   
  export R;
  return(@r);
};
//----------------------------------------------------------------------------
proc ex2()
{ 
  ring @r=0,(s1,s2,s3),dp;
  module R=[0,-s3,s2],
            [s3,0,-s1],
	    [-s2,s1,0];
  R=transpose(R);	   
  export R;
  return(@r); 
};
//----------------------------------------------------------------------------
proc exAntenna()
{
  ring @r = (0, K1, K2, Te, Kp, Kc),(Dt, delta), dp;
  module R;
  R = [Dt, -K1, 0, 0, 0, 0, 0, 0, 0],
      [0, Dt+K2/Te, 0, 0, 0, 0, -Kp/Te*delta, -Kc/Te*delta, -Kc/Te*delta],
      [0, 0, Dt, -K1, 0, 0, 0, 0, 0],
      [0, 0, 0, Dt+K2/Te, 0, 0, -Kc/Te*delta, -Kp/Te*delta, -Kc/Te*delta],
      [0, 0, 0, 0, Dt, -K1, 0, 0, 0],
      [0, 0, 0, 0, 0, Dt+K2/Te, -Kc/Te*delta, -Kc/Te*delta, -Kp/Te*delta];

  R=transpose(R);
  export R;
  return(@r);  
};

//----------------------------------------------------------------------------

proc exEinstein()
{
  ring @r = 0,(D(1..4)),dp;
  module R =
  [D(2)^2+D(3)^2-D(4)^2, D(1)^2, D(1)^2, -D(1)^2, -2*D(1)*D(2), 0, 0, -2*D(1)*D(3), 0, 2*D(1)*D(4)],
  [D(2)^2, D(1)^2+D(3)^2-D(4)^2, D(2)^2, -D(2)^2, -2*D(1)*D(2), -2*D(2)*D(3), 0, 0, 2*D(2)*D(4), 0], 
  [D(3)^2, D(3)^2, D(1)^2+D(2)^2-D(4)^2, -D(3)^2, 0, -2*D(2)*D(3), 2*D(3)*D(4), -2*D(1)*D(3), 0, 0],
  [D(4)^2, D(4)^2, D(4)^2, D(1)^2+D(2)^2+D(3)^2, 0, 0, -2*D(3)*D(4), 0, -2*D(2)*D(4), -2*D(1)*D(4)],
  [0, 0, D(1)*D(2), -D(1)*D(2), D(3)^2-D(4)^2, -D(1)*D(3), 0, -D(2)*D(3), D(1)*D(4), D(2)*D(4)],
  [D(2)*D(3), 0, 0, -D(2)*D(3),-D(1)*D(3), D(1)^2-D(4)^2, D(2)*D(4), -D(1)*D(2), D(3)*D(4), 0],
  [D(3)*D(4), D(3)*D(4), 0, 0, 0, -D(2)*D(4), D(1)^2+D(2)^2, -D(1)*D(4), -D(2)*D(3), -D(1)*D(3)],
  [0, D(1)*D(3), 0, -D(1)*D(3), -D(2)*D(3), -D(1)*D(2), D(1)*D(4), D(2)^2-D(4)^2, 0, D(3)*D(4)],
  [D(2)*D(4), 0, D(2)*D(4), 0, -D(1)*D(4), -D(3)*D(4), -D(2)*D(3), 0, D(1)^2+D(3)^2, -D(1)*D(2)], 
  [0, D(1)*D(4), D(1)*D(4), 0, -D(2)*D(4), 0, -D(1)*D(3), -D(3)*D(4), -D(1)*D(2), D(2)^2+D(3)^2];

  R=transpose(R);
  export R;
  return(@r);  
};


//---------------------------------------------------------------------------------------------

proc exFlexibleRod()
{
  ring @r = 0,(D1, delta), dp;
  module R;
  R = [D1, -D1*delta, -1], [2*D1*delta, -D1-D1*delta^2, 0];
  
  R=transpose(R);
  export R;
  return(@r);  
};

//---------------------------------------------------------------------------------------------
proc exTwoPendula()
{  
  ring @r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module R = [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
             [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
             [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];

  R=transpose(R);
  export R;
  return(@r);  
};
//---------------------------------------------------------------------------------------------
proc exWindTunnel()
{ 
  ring @r = (0,a, omega, zeta, k),(D1, delta),dp;
  module R = [D1+a, -k*a*delta, 0, 0],
             [0, D1, -1, 0],
             [0, omega^2, D1+2*zeta*omega, -omega^2];

  R=transpose(R);
  export R;
  return(@r);  
};
//--------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

static proc invo_poly(poly m, map theta)
//applies the involution map theta to m, where m=polynomial
{
  int i,j;
  intvec v;
  poly p,z;
  poly n = 0;
  i = 1;
  while(m[i]!=0)
  {
    v = leadexp(m[i]);
    z =1;
    for(j=nvars(basering); j>=1; j--)
    {
      if (v[j]!=0)
      { 
        p = var(j); 
        p = theta(p);
        z = z*(p^v[j]);
      }
    }    
    n = n + (leadcoef(m[i])*z);
    i++;  
  }
  return(n);
}

proc involution(m, map theta)
//applies the involution map theta to m, where m=vector, polynomial,
//module,ideal
{
  int i,j;
  intvec v;
  poly p,z;
  if (typeof(m)=="poly")
  {
    return (invo_poly(m,theta));  
  }
  if ( typeof(m)=="ideal" )
  {
    ideal n;
    for (i=1; i<=size(m); i++)
    {
      n[i] = invo_poly(m[i],theta);
    } 
    return(n);
  }
  if (typeof(m)=="vector")
  {
    for(i=1;i<=size(m);i++)
    {
      m[i] = invo_poly(m[i],theta);
    }
    return (m);  
  }
  
  if ( (typeof(m)=="matrix") || (typeof(m)=="module"))
  {  
//    m=transpose(m);
    matrix n = matrix(m);
    int @R=nrows(n);
    int @C=ncols(n);
    for(i=1; i<=@R; i++)
    {
      for(j=1; j<=@C; j++)
      {
        n[i,j] = invo_poly( m[i,j], theta);
      }
    }
   }
  if (typeof(m)=="module")
  {
    return (module(n));
  }
  return(n);
}
example
{ 
  "EXAMPLE:";echo = 2;
  ring r = 0,(x,d),dp;
  ncalgebra(1,1); // Weyl-Algebra
  map F = r,x,-d;
  poly f =  x*d^2+d;
  poly If = involution(f,F);
  f-If;
  poly g = x^2*d+2*x*d+3*x+7*d;
  poly tg = -d*x^2-2*d*x+3*x-7*d;
  poly Ig = involution(g,F);
  tg-Ig;
  ideal I = f,g;
  ideal II = involution(I,F);
  II;
  I - involution(II,F);
  module M  = [f,g,0],[g,0,x^2*d];
  module IM = involution(M,F);
  print(IM);
  print(M - involution(IM,F));  
}

proc ncdetection(def r)
// in this procedure an involution map is generated from the NCRelations 
// that will be used in the function involution
// in dieser proc. wird eine matrix erzeugt, die in der i-ten zeile die indices 
// der differential-,shift- oder advance-operatoren enthaelt mit denen die i-te
// variable nicht kommutiert. 
{
  int i,j,k,LExp;
  int NVars=nvars(r);
  matrix rel = NCRelations(r)[2];
  intmat M[NVars][3];
  int NRows = nrows(rel);
  intvec v,w; 
  poly d,d_lead;
  ideal I;
  map theta;
 
  for( j=NRows; j>=2; j-- )
  {
   if( rel[j] == w )       //the whole column is zero
    {
      j--;
      continue;
    }
    
    for( i=1; i<j; i++ )         
    {
      if( rel[i,j]==1 )        //relation of type var(j)*var(i) = var(i)*var(j) +1
      {
         M[i,1]=j;
      }
      if( rel[i,j] == -1 )    //relation of type var(i)*var(j) = var(j)*var(i) -1
      {
        M[j,1]=i;
      }
      d = rel[i,j];
      d_lead = lead(d);
      v = leadexp(d_lead); //in the next lines we check wether we have a  relation of differential or shift type
      LExp=0;
      for(k=1; k<=NVars; k++)
      {
        LExp = LExp + v[k];
      }
      //      if( (d-d_lead != 0) || (LExp > 1) )
if ( ( (d-d_lead) != 0) || (LExp > 1) || ( (LExp==0) && ((d_lead>1) || (d_lead<-1)) ) )
      {
        return(theta);
      }

      if( v[j] == 1)                   //relation of type var(j)*var(i) = var(i)*var(j) -lambda*var(j)
      {
        if (leadcoef(d) < 0)
        {
          M[i,2] = j;
        }
        else
        {
          M[i,3] = j;
        }
      }
      if( v[i]==1 )                    //relation of type var(j)*var(i) = var(i)*var(j) -lambda*var(i)
      {
        if (leadcoef(d) > 0)
        {
          M[j,2] = i;
        }
        else
        {
          M[j,3] = i;
        }
      }
    }
  }
  // from here on, the map is computed
  for(i=1;i<=NVars;i++)
  {
    I=I+var(i);
  }

  for(i=1;i<=NVars;i++)
  {
    if( M[i,1..3]==(0,0,0) )
    {
      i++;
      continue;
    }
    if( M[i,1]!=0 )
    {
      if( (M[i,2]!=0) && (M[i,3]!=0) )
      {
        I[M[i,1]] = -var(M[i,1]);
        I[M[i,2]] = var(M[i,3]);
        I[M[i,3]] = var(M[i,2]);
      }
      if( (M[i,2]==0) && (M[i,3]==0) )
      {
        I[M[i,1]] = -var(M[i,1]);
      }                  
      if( ( (M[i,2]!=0) && (M[i,3]==0) )|| ( (M[i,2]!=0) && (M[i,3]==0) ) 
)
      {
        I[i] = -var(i);
      }
    }
    else
    {
      if( (M[i,2]!=0) && (M[i,3]!=0) )
      {
        I[i] = -var(i);
        I[M[i,2]] = var(M[i,3]);
        I[M[i,3]] = var(M[i,2]);
      }
      else
      {
        I[i] = -var(i);
      } 
    }
  }
  return(I);
}
example
{ 
  "EXAMPLE:"; echo = 2;
  ring r=0,(x,y,z,D(1..3)),dp;
  matrix D[6][6];
  D[1,4]=1;
  D[2,5]=1;
  D[3,6]=1;
  ncalgebra(1,D);
  ncdetection(r);
  kill r;
  //----------------------------------------
  ring r=0,(x,S),dp;
  ncalgebra(1,-S);
  ncdetection(r);
  kill r;
  //----------------------------------------
  ring r=0,(x,D(1),S),dp;
  matrix D[3][3];
  D[1,2]=1;
  D[1,3]=-S;
  ncalgebra(1,D);
  ncdetection(r);
}

proc genericity(matrix M)
"USAGE:  genericity(M), M is a matrix
RETURN:  list of strings with expressions, used as non-zero in SB
NOTE:  effective with the liftstd procedure
"
{
  // M is a matrix over a ring with params and vars;
  ideal I = ideal(M); // a list of entries
  I = simplify(I,2); // throw 0's away
  // decompose every coeff
  int i; int  cl=1;
  int s = size(I);
  list NM;
  poly p;
  for (i=1; i<=s; i++)
  {
    p = I[i];
    while( p != 0)
    {
      NM[cl] = leadcoef(p);
      cl++;
      p = p - lead(p);
    };
  };
  string newvars = parstr(basering);
  def save = basering;
  string NewRing = "ring @NR =" +string(char(basering))+",("+newvars+"),Dp;";
  execute(NewRing);
  // get params as variables
  // create a list of non-monomials
  ideal L;
  ideal F;
  list NM = imap(save,NM);
  poly p,q;
  cl = 1;
  int j, cf;
  for(i=1; i<=size(NM);i++)
  {
    p = NM[i] - lead(NM[i]);
    if (p!=0)
    {
      //      L[cl] = p;
      F  = factorize(NM[i],1); //non-constant factors only
      cf = 1;
      // factorize every polynomial
      // throw away every non-monomial
      for (j=1; j<=size(F);j++)
      {
	q = F[j]-lead(F[j]);
	if (q!=0)
	{
	  L[cl] = F[j];
	  cl++;
	}
      }
    }
  }
  // return the result [in string-format]
  L = simplify(L,2+4); // skip zeroes and double entries
  list SL;
  for (j=1; j<=size(L);j++)
  {
    SL[j] = string(L[j]);
  }
  setring save;
  return(SL);
}
example
{  // TwoPendula
  "EXAMPLE:"; echo = 2;
  ring r=(0,m1,m2,M,g,L1,L2),Dt,dp;
  module RR = 
    [m1*L1*Dt^2, m2*L2*Dt^2, -1, (M+m1+m2)*Dt^2], 
    [m1*L1^2*Dt^2-m1*L1*g, 0, 0, m1*L1*Dt^2],
    [0, m2*L2^2*Dt^2-m2*L2*g, 0, m2*L2*Dt^2];
  module R = transpose(RR);
  matrix T;
  module SR = liftstd(R,T);
  genericity(T);
}

proc canonize(list L)
"USAGE:  canonize(L), L a list
ASSUME: L is the output of control/autonomy procs
RETURN:  canonized list
"
{
  list M = L;
  option(redSB);
  option(redTail);
  int s = size(L);
  int i;
  for (i=2; i<=s; i=i+2)
  {
    if (typeof(M[i])=="module")
    {
      M[i] = std(M[i]);
      //      M[i] = prune(M[i]); // mimimal embedding
      //      M[i] = std(M[i]);
    }
  }
  return(M);
}
example
{  // TwoPendula with L1=L2=L
  "EXAMPLE:"; echo = 2;
  ring r=(0,m1,m2,M,g,L),Dt,dp;
  module RR = 
    [m1*L*Dt^2, m2*L*Dt^2, -1, (M+m1+m2)*Dt^2], 
    [m1*L^2*Dt^2-m1*L*g, 0, 0, m1*L*Dt^2],
    [0, m2*L^2*Dt^2-m2*L*g, 0, m2*L*Dt^2];
  module R = transpose(RR);
  list C = control(R);
  list CC = canonize(C);
  view(CC);
}

//---------------------------------------------------------------

static proc smdeg(matrix N)  
// returns an intvec of length 2 with the index of an element of N with smallest degree
{
  int n = nrows(N);
  int m = ncols(N);
  int d,d_temp;
  intvec v;
  int i,j;            // counter
  
  for(i=1;i<=n;i++) // hier wird ein Element ausgewaehlt(!=0) und mit dessen Grad gestartet
  {
    for(j=1;j<=m;j++)
    {
      if( deg(N[i,j])!=-1 )
      {
    d=deg(N[i,j]);
    break;
      }
    }
    if(d!=-1)
    {
      break;
    }  
  }
  for(i =1; i<=n; i++)
  {
    for(j=1;j<=m;j++)
    {
      d_temp = deg(N[i,j]);
      if ((d_temp < d) && (N[i,j]!=0) )
      {
    d=d_temp;
      }
    }
  }
  for (i=1; i<=n; i++)
  {
    for (j =1; j<=m;j++)
    {
      if ( (deg(N[i,j]) == d) && (N[i,j]!=0) )
      {
    v = i,j;
    return(v);
      }
    }
  }
}

static proc NoNon0Pol(vector v)
// returns 1, if there is only one non-zero element in v and 0 else
{
  int i,j;
  int n = nrows(v);
  for(j=1; j<=n;j++)
  {
    if(v[j]!=0)
    {
      i++;
    }
  }
  if ( i!=1 )
  {
    i=0;
  }
  return(i);
}


proc smith( module M )
"USAGE: smith(M), M a module or a matrix,
RETURN: a list of length 4 with the following entries:
[1]: The Smith-Form S of M, 
[2]: the rank of M, 
[3]: a unimodular matrix U,
[4]: a unimodular matrix V, 
such that U*M*V=S. An empty list is returned when no Smith Form exists. 
NOTE: The Smith form only exists over PIDs (principal ideal domains).
"
{
  if (nvars(basering)>1)
    {
      list @L;
      return (@L);
    }
  matrix N = matrix(M);         //Typecasting
  int n = nrows(N);
  int m = ncols(N);
  matrix P = unitmat(n);       //left transformation matrix
  matrix Q = unitmat(m);       //right transformation matrix
  int k, i, j, deg_temp;
  poly tmp;
  vector v;
  list L;                      //for extgcd-computation
  intmat f[1][n];              //to save degrees
  matrix lambda[1][n];         //to save leadcoefficients
  intmat g[1][m];              //to save degrees
  matrix mu[1][m];             //to save leadcoefficients
  int ii;                       //counter
  ideal J;                      //for extgcd-computations
  matrix T;                     //----------"------------
  
  while ((k!=n) && (k!=m) )    
  {
    k++;
    while ((k<=n) && (k<=m))  //outer while-loop for column-operations
    {
      while(k<=m )        //inner while-loop for row-operations
      {
    if( (n>m) && (k < n) && (k<m))
    {      
      if( simplify((ideal(submat(N,k+1..n,k+1..m))),2)== 0)
      {
        return(N,k-1,P,Q);
      }
    }
        i,j = smdeg(submat(N,k..n,k..m)); //choose smallest degree in the remaining submatrix
        i=i+(k-1);                        //indices adjusted to the whole matrix
	j=j+(k-1);
	if(i!=k)                    //take the element with smallest degree in the first position
        {
          N=permrow(N,i,k);
          P=permrow(P,i,k);
        }
        if(j!=k)
        {
          N=permcol(N,j,k);
          Q=permcol(Q,j,k);
        }
        if(NoNon0Pol(N[k])==1)
        {
          break;
        }
        tmp=leadcoef(N[k,k]);
        deg_temp=ord(N[k,k]);             //ord outputs the leading degree of N[k,k]
        for(ii=k+1;ii<=n;ii++)
        {
          lambda[1,ii]=leadcoef(N[ii,k])/tmp;     
          f[1,ii]=deg(N[ii,k])-deg_temp;
        }
        for(ii=k+1;ii<=n;ii++)
        {
          N = addrow(N,k,-lambda[1,ii]*var(1)^f[1,ii],ii);
      N = normalize(N);
          P = addrow(P,k,-lambda[1,ii]*var(1)^f[1,ii],ii);
    }
      }
      if (k>n)
      {
    break;
      }
      if(NoNon0Pol(transpose(N)[k])==1)
      {
        break;
      }
      tmp=leadcoef(N[k,k]);
      deg_temp=ord(N[k,k]); //ord outputs the leading degree of N[k][k]
      
      for(ii=k+1;ii<=m;ii++)
      {
        mu[1,ii]=leadcoef(N[k,ii])/tmp;     
        g[1,ii]=deg(N[k,ii])-deg_temp;
      }
      for(ii=k+1;ii<=m;ii++)
      {
        N=addcol(N,k,-mu[1,ii]*var(1)^g[1,ii],ii);
        N=normalize(N);
        Q=addcol(Q,k,-mu[1,ii]*var(1)^g[1,ii],ii);
      }
    }
    if( (k!=1) && (k<n) && (k<m) )
    {
      L=extgcd(N[k-1,k-1],N[k,k]);  //one can use this line if extgcd-bug is fixed
      
      //the next lines are needed for the divisibility condition of the entries of the Smith Form
      
      if(!(N[k-1,k-1]==L[1]))  //means that N[k-1,k-1] is not a divisor of N[k,k]
	{
	  N=addrow(N,k-1,L[2],k);
	  normalize(N);
	  P=addrow(P,k-1,L[2],k);
	  
	  N=addcol(N,k,-L[3],k-1);
	  N=normalize(N);
	  Q=addcol(Q,k,-L[3],k-1);
	  k=k-2;
	}
    }
  }  
  if( (k<=n) && (k<=m) )
    {
      if( N[k,k]==0)
      {
	return(N,k-1,P,Q);
      }
    }
  return(N,k,P,Q);
}
example
{
  "EXAMPLE:";echo = 2;
  option(redSB);
  option(redTail);
  ring r=0,x,dp;
  // This is example is trivial, but we want to see,
  // that nothing is changed, when the matrix is already in Smith-Form!
  module M = [x,0,0],[0,x2,0],[0,0,x3];
  print(M);
  list L = smith(M);
  print(L[1]);
  matrix N=matrix(M);
  matrix B=L[3]*N*L[4];
  B=normalize(std(B));
  print(B);
  //------- and yet another example --------------
  module M2=[x2,x,3x3-4],[2x2-1,4x,5x2],[2x5,3x,4x];
  print(M2);
  list P=smith(M2);
  print(P[1]);
  matrix N2=matrix(M2);
  matrix B2=P[3]*N2*P[4];
  print(B2);
  B2=normalize(std(B2));
  print(B2);
}
