//////////////////////////////////////////////////////////////////////////////
version="$Id: ratgb.lib,v 1.2 2007-05-27 01:51:40 levandov Exp $";
category="Noncommutative";
info="
LIBRARY: ratgb.lib  Groebner bases in Ore localizations
AUTHOR: Viktor Levandovskyy,     levandov@risc.uni-linz.ac.at

PROCEDURES: 
ratstd(ideal I, int n);   compute Groebner basis in Ore localizations of the basering wrt first n variables

SUPPORT: SpezialForschungsBereich F1301 of the Austrian FWF
"

proc ratstd(ideal I, int is)
"USAGE:  ratstd(I, n);  I an ideal, n an integer
RETURN:  ring
PURPOSE: compute the Groebner basis of I in the Ore localization of
the basering with respect to first n variables
ASSUME: the variables are organized in two blocks and
@* the first block of length n contains the elements
@*     with respect to which one localizes, 
@* the basering is equipped with the elimination ordering 
@*     for the variables in the second block
NOTE:    the output ring O is commutative. The ideal rGBid in O
represents the rational form of the output ideal pGBid in the basering.
@* During the computation, the D-dimension of I and the corresponding
vector space D-dimension of I are computed and printed out.
EXAMPLE: example ratstd; shows examples
"
{
  // 0. do the subst's /reformulations
  // for the time being, ASSUME
  // the ord. is an elim. ord. for D
  // and the block of X's is on the left
  // its length is 'is'

  // 1. compute G = GB(I) wrt. the elim. ord. for D

  option(redSB);
  option(redTail);
  ideal G = groebner(I); // although slimgb looks better
  G = simplify(G,2); // to be sure there are no 0's
  int sG  = ncols(G);
  // 2. create L(G) with X's as coeffs

  ideal LG;
  int i,j,k;
  for (i=1; i<= sG; i++)
  {
    LG[i] = lead(G[i]);
  }

  // 3. create K(x)[D], commutative
  def save = basering;
  list L = ringlist(save);
  list RL, tmp1,tmp2,tmp3,tmp4;
  intvec iv;
  // copy: field, enlarge it with Xs

  if ( size(L[1]) == 0)
  {
    // i.e. the field with char only
    tmp2[1] = L[1];
    //    tmp1 = L[2];
    j    = size(L[2]);
    iv   = 1;
    for (i=1; i<=is; i++)
    {
      tmp1[i] = L[2][i];
      iv = iv,1;
    }
    iv = iv[1..size(iv)-1]; //extra 1
    tmp2[2]       = tmp1;
    tmp3[1] = "lp";
    tmp3[2] = iv;
    //    tmp2[3] = 0;
    tmp4[1] = tmp3;
    tmp2[3] = tmp4;
    //[1] = "lp";
    //    tmp2[3][2] = iv;
    tmp2[4]       = ideal(0);
    RL[1] = tmp2;
  }

  if ( size(L[1]) >0 )
  {
    // TODO!!!!!
    tmp2[1] = L[1][1]; //char K
    // there are parameters
    // add to them X's, IGNORE alg.extension
    // the ordering on pars
    tmp1 = L[1][2]; // param names
    j    = size(tmp1);
    iv = L[1][3][1][2];
    for (i=1; i<=is; i++)
    {
      tmp1[j+i] = L[2][i];
      iv = iv,1;
    }
    tmp2[2] = tmp1;
    tmp2[3] = L[1][3];
    tmp2[3][1][2] = iv;
    tmp2[4] = ideal(0);
    RL[1] = tmp2;
  }

  // vars: leave only D's
  kill tmp1; list tmp1;
  //  tmp1 = L[2];
  for (i=is+1; i<= size(L[2]); i++)
  {
    tmp1[i-is] = L[2][i];
  }
  RL[2] = tmp1;

  // assume the ordering is the block with (a(0:is),ORD)
  // set up ORD as the ordering
  //  L; "RL:"; RL;
  if (size(L[3]) != 3)
  {
    "note: strange ordering\n";
  }
  kill tmp2; list tmp2;
  tmp2[1] = L[3][2];
  tmp2[2] = L[3][3];
  RL[3]   = tmp2; 

  // factor ideal is ignored
  RL[4] = ideal(0);

  //  RL;

  // 3. map L(G) to K(X)[D]

  def @RAT = ring(RL);
  setring @RAT;

  ideal LG = imap(save, LG);
  // do not do groebner at this place, 
  // it may cause misordering!

  // 4. run simplify
  
  ideal SLG = simplify(LG,8+32); //contains zeros
  intvec islg;
  if (SLG[1] == 0)
  {  islg = 0;  }
  else
  {    islg = 1;  }
  for (i=2; i<= ncols(SLG); i++)
  {
    if (SLG[i] == 0)
    {
      islg = islg, 0;
    }
    else
    {
      islg = islg, 1;
    }
  }

  // compute the D-dimension of the ideal

  LG = groebner(LG); // cosmetics
  int d = dim(LG);
  int Ddim = d;
  printf("D-dimension is %s",d);
  if (d==0)
  {
    d = vdim(LG);
    int Dvdim = d;
    printf("the K-dimension is %s",d);
  }
  setring save;
  for (i=1; i<= ncols(LG); i++)
  {
    if (islg[i] == 0)
    {
      G[i] = 0;
    }
  }
  G = simplify(G,2); // ready!
  // return the result
  ideal pGBid = G;
  export pGBid;
  //  export Ddim;
  //  export Dvdim;
  setring @RAT;
  ideal rGBid = imap(save,G);
  export rGBid;
  setring save;
  return(@RAT);
  //  kill @RAT;
  //  return(G);
}
example
{
  "EXAMPLE:"; echo = 2;
  ring r = 0,(k,n,K,N),(a(0,0,1,1),dp);
  matrix D[4][4];
  D[1,3] = K;
  D[2,4] = N;
  ncalgebra(1,D); 
  ideal I = (k+1)*K - (n-k), (n-k+1)*N - (n+1); 
  int is = 2;
  def A  = ratstd(I,is);
  pGBid; // polynomial form
  setring A;
  rGBid; // rational form
}

static proc exParam()
{
  // Appel F4
  ring r = (0,a,b,c,d),(x,y,Dx,Dy),(a(0,0,1,1),dp);
  matrix @D[4][4];
  @D[1,3]=1; @D[2,4]=1;
  ncalgebra(1,@D);
  ideal I =
    x*Dx*(x*Dx+c-1) - x*(x*Dx+y*Dy+a)*(x*Dx+y*Dy+b),
    y*Dy*(y*Dy+d-1) - y*(x*Dx+y*Dy+a)*(x*Dx+y*Dy+b);
  def A = ratstd(I,2);
  pGBid; // polynomial form
  setring A;
  rGBid; // rational form
}
