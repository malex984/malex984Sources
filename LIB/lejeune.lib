
//-*- mode:C++;-*-
// $Id: lejeune.lib,v 1.18 2005-08-09 10:02:57 cremer Exp $


info="
LIBRARY: lejeune.lib     Arc space computations
AUTHOR:  Nadine Cremer,  nadine.cremer@gmx.de
[SEE ALSO: <comma-separated words of cross references>]
[KEYWORDS: <semicolon-separated phrases of index keys>]
PROCEDURES:
    variables(k,i);      creates k*i new var. t,a(1),..,a(i),..,x(1),..,x(i)
    atoz(k);             returns kth letter of the alphabet
    modd(f,g);           modulo-operator for polys
    idealsimplify(I)     simplifies ideal- i.o. to avoid/keep small radical
    Hnew(H);             creates 'next' intvec, called from 'trunc' 
    idealequality(I,J);  tests if I==J, using quotient
    order(f);            returns i, where f_i is smallest nonzero homog. part
    minpower(f);         returns minimal ny s.t. x(i)^ny in J(f) for all i

    tpolys(k,i);         creates polyn. a(1)*t+..+a(n)*t^n
    ringchange(i);       changes the ring to the one needed in ith step      
    plugin_coeffs(i,f)   plugs tpolys into f, up to power i
    diffidealstep(i,N);  returns ideal needed for contraction in ith step
                         N is number of variables of input f
    formaldiff(f,H);     computes the formal derivatives corresponding to H
                         and the desciption of F resp. G, list	  
    fset(f,H);           returns the set F corresponding to H as described by
                         M. Lejeune
    gset(f,H);           returns the set G corresponding to H as described by
                         M. Lejeune
    fgset(f,H);          returns simultaneously the sets F and G corresponding
                         to H as described by M. Lejeune
    hset(f,H);           returns the set F\G  corresponding to H as 
                         described by M. Lejeune
    trunc(f,i);          returns the set Tr(i) as described by M. Lejeune
    ";


LIB "ring.lib";
LIB "general.lib";
LIB "primdec.lib";
LIB "standard.lib";
LIB "sing.lib";




proc trunc (poly f, int i)
{
 def r=basering;
 int m=milnor(f);
 int mi=m*i;                  // make sure we obtain Tr(i)
 int k,v,j,u,w;
 int l=order(f);
 int s0=mi+1;
 int s=l*(mi+1);
 int z1=nvars(r)*(i+1)+2;
 int z2=nvars(r)*k+1;
 intvec H=l;
 for(k=1;k<=mi;k++)          // initialize H
 {
   H[k+1]=1; 
 }
 def R1=ringchange(i);        // ring in which result lies, plus decl. of var. 
 setring R1;
 ideal I,J;
 list intersec=I,J;           // initialization
 list result=intersec;
 setring r;
 while(sum(H)<=s)      // consider all possible H's
 {
   for(k=2;k<=s0;k++)       // computes result ror all H[1..k]
   {   
     setring r;
     def tmp=fgset(f,intvec(H[1..k]));
     setring tmp;
     if(k>i+1)              // if we have to apply rho...
     { 
       u=ncols(fgresult[1]);         
       w=ncols(fgresult[2]);
       for(j=1;j<=u;j++)     // cutting terms -F
       {
        for(v=z1;v<=z2;v++)
        { 
         matrix A=coeffs(fgresult[1][j],var(v));
         if(A!=0)
	 {
          fgresult[1][j]=0;
         }
         kill A;
        } 
       }
       for(j=1;j<=w;j++)     // cutting terms -G
       {
        for(v=z1;v<=z2;v++)             
        { 
	  matrix A=coeffs(fgresult[2][j],var(v));
          if(A!=0)
	  {
           fgresult[2][j]=0;
          }
          kill A;
        } 
       }
      }  
      setring R1;
      def step=imap(tmp,fgresult);
      intersec[1]=intersec[1],step[1];
      intersec[2]=intersec[2],step[2];      
      kill step; 
      kill tmp;    
   }
   setring R1;
   result[1]=result[1],intersec[1];     // put together results of all H's
   result[2]=result[2],intersec[2];
   intersec[1]=I;
   intersec[2]=J;
   H=Hnew(H);
 }
 result[1]=simplify(result[1],6);
 result[2]=simplify(result[2],6); 
"Result=";result;
 return(R1);                           // return the ring
}

 



////////////////////////////////////////////////////////////////////////////
//                 COMPUTATION of H = F\G
////////////////////////////////////////////////////////////////////////////

proc hset (poly f,intvec H)
{ 
  int i;                             
  int b=size(H);
  def r=basering;
  def R=ringchange(b-1);
  def tmp1=fgset(f,H);
  setring R;
  poly red;
  list hresult=imap(tmp1,fgresult);
  //hresult;
  export(hresult);
  return(R);
}


////////////////////////////////////////////////////////////////////////////
//          COMPUTATION of F,G and H simultaneously
////////////////////////////////////////////////////////////////////////////

proc hset1 (poly f, intvec H)
{ 
  int i,p;
  int b=size(H);
  def r=basering;                           
  int m0=order(f); 

  if(H[1]!=m0)                           // input admissible?!
    {
     "H[1]=ord(f) necessary!!";
      return(0);
    } 
  for(p=1;p<b;p++)
    {
      if(H[p]<H[p+1])
      {
        "Inadmissible input, H[1]<=...<=H[b] necessary!";
         return(0);
      }
    }

  def R=ringchange(b-1);
  setring R;                            // compute F
  poly red;                           
  list l;
  ideal fresult,gresult,I;
  list fgresult;
  for(p=2;p<=b;p++)
  {
    setring r;
    def tmp=formaldiff(f,intvec(H[1..p]));
    setring R;
    l=imap(tmp,resultdiff);
    I=l[1];           
    kill tmp;
    fresult=fresult,I;
  }
  gresult=fresult;                     // use computation of F for G...


  setring r;                           // last step, special for G
  def tmp=formaldiff(f,H);;
  setring R;
  l=imap(tmp,resultdiff);
  I=l[2];
  kill tmp;
  gresult=gresult,I;



  ideal nonzero,aux;                  // make the result look better...
  option(redSB);                      // i.e. compute H explicitly
  aux=std(fresult);
  for(i=1;i<=size(gresult);i++) 
  {
    red=reduce(gresult[i],aux);
    if (red!=0)
    {
      nonzero=nonzero,red;
    }    
  }
  list hresult=aux,nonzero;
  //hresult;
  export(hresult);
  return(R);
}




proc fgset (poly f,intvec H) 
{
  def r=basering;
  int p;                             
  int m0=order(f); 
  int b=size(H);
  if(H[1]!=m0)                       // input admissible?!
    {
     "H[1]=ord(f) necessary!!";
      return(0);
    } 
  for(p=1;p<b;p++)
    {
      if(H[p]<H[p+1])
      {
        "Inadmissible input, H[1]<=...<=H[b] necessary!";
         return(0);
      }
    }

  def R=ringchange(b-1);
  setring R;
  list l;
  ideal fresult,gresult;
  list fgresult;
  for(p=2;p<=b;p++)
  {
    setring r;
    def tmp=formaldiff(f,intvec(H[1..p]));
    setring R;
    l=imap(tmp,resultdiff);              
    kill tmp;
    fresult=fresult,l[1];
  }
  gresult=fresult;                     // use computation of f for g

  setring r;                           // last step, special for G
  def tmp=formaldiff(f,H);;
  setring R;
  l=imap(tmp,resultdiff);
  kill tmp;
  gresult=gresult,l[2];
  fresult=simplify(fresult,6);
  gresult=simplify(gresult,6);
  fgresult=fresult,gresult;
  export(fgresult);
  //fgresult;
  return(R);
}






////////////////////////////////////////////////////////////////////////////
//                 COMPUTATION OF THE F's
////////////////////////////////////////////////////////////////////////////

proc fset (poly f,intvec H) 
{
  int p;                            
  int m0=order(f); 
  int b=size(H);
  if(H[1]!=m0)                       // input admissible?!
    {
     "H[1]=ord(f) necessary!!";
      return(0);
    } 
  for(p=1;p<b;p++)
    {
      if(H[p]<H[p+1])
      {
        "Inadmissible input, H[1]<=...<=H[b] necessary!";
         return(0);
      }
    }

  def R=ringchange(b-1);
  setring R;
  list l;
  ideal fresult,I;
  for(p=2;p<=b;p++)
  {
    setring r;
    def tmp=formaldiff(f,intvec(H[1..p]));
    setring R;
    l=imap(tmp,resultdiff);
    I=l[1];
    kill tmp;
    fresult=fresult,I;
  }
  fresult=simplify(fresult,6);          // simplify
  //fresult;
  export(fresult);
  return(R);
}






////////////////////////////////////////////////////////////////////////////
//                      COMPUTING the G's                                 
////////////////////////////////////////////////////////////////////////////


proc gset (poly f,intvec H) 
{
  int p;                             
  int m0=order(f); 
  int b=size(H);
  if(H[1]!=m0)                       // input admissible?!
    {
     "H[1]=ord(f) necessary!!";
      return(0);
    } 
  for(p=1;p<b;p++)
    {
      if(H[p]<H[p+1])
      {
        "Inadmissible input, H[1]<=...<=H[b] necessary!";
         return(0);
      }
    }

  def r=basering;
  def R=ringchange(b-1);              // work in new ring
  setring R;
  list l;
  ideal I,gresult;
  for(p=2;p<=b-1;p++)                 // steps equal to fset...
  {
    setring r;
    def tmp=formaldiff(f,intvec(H[1..p]));
    setring R;
    l=imap(tmp,resultdiff);
    I=l[1];
    kill tmp;
    gresult=gresult,I;
  }

  setring r;                          // last step, special for G
  def tmp=formaldiff(f,H);
  setring R;
  l=imap(tmp,resultdiff);
  I=l[2];
  kill tmp;
  gresult=gresult,I; 
  gresult=simplify(gresult,6);          // simplify
  export(gresult);
  //gresult;
  return(R);
}




////////////////////////////////////////////////////////////////////////////
//              PREPARATORY WORK: plugging in and differentiating
////////////////////////////////////////////////////////////////////////////



proc plugincoeffs (poly f,int i)
{ int startvar=nvars(basering);
  def r=basering;
  def R=ringchange(i);              // changes the ring
  setring R;                        // makes it new basering;
  ideal I=tpolys(i,startvar);
  poly g=imap(r,f);                 // maps f to new basering
  export(g);                        // export it
  map h=r,I;                        // define map according to our purpose
  ideal J=h(f);                     // gives f with power series plugged in
  export(h);                   
  matrix resultplug=coeffs(J[1],t); // gives the t-coefficients
  export resultplug;                // export it i.o. to use it later on
  return(R);                        // return ring (ring change!)
}



proc tpolys (int i,int k)             // constructs polynomials a(1)*t+... 
{                                     // has to be called from pluin_coeffs
  int s,t;                            // loop variables
  int v;           
  poly sum; 
  ideal I; 
  for(t=1;t<=k;t++) 
   {  
     v=(t-1)*i; 
     for(s=1;s<=i;s++) 
      { 
        sum=sum+var(1+k+v+s)*var(k+1)^s;    // clumsy: working with "var(1)",
      }                                     // depends on form of basering
     I[t]=sum; 
     sum=0; 
   }   
  return(I); 
} 




proc formaldiff (poly f,intvec H)
{ 
  int startvar=nvars(basering);
  int s,t,v;                          // loop variables
  int u;
  int i=size(H)-1;
  int c=sum(H,1..i);
  int k=H[i+1];
  def R=plugincoeffs(f,i);           // plugs the power series in...
  setring R;                          // changes the ring 
  matrix coe=resultplug;            // gives the t-coeff. after plugging in 
  poly fkv;                           // need this stuff for the following
  ideal step=diffidealstep(i,startvar); 
  list resultdiff;
  ideal m,power,diffstep,J,gresultdiff,fresultdiff;
  for(v=1;v<=k;v++)                   // consider the different t-coeff.
    { 
     fkv=coe[c+v,1];
     m=fkv;                          
     J=fkv;                           
     for(s=1;s<=k-v+1;s++)           // "s<=k-v+1" special for G, ONLY DIFF.!
       { 
	 if(s==k-v+1)                // equations for F!
	 {
	   fresultdiff=fresultdiff,J;      
	 }
         power=step^s;
         u=size(power);
         for(t=1;t<=u;t++)
          {
            diffstep=contract(power[t],m);     // actual differentiation
	    J=J,diffstep;
          }
          
       }
     gresultdiff=gresultdiff,J;
   }
  resultdiff=fresultdiff,gresultdiff;
  export(resultdiff);                  // exports the result
  return(R);                           // return the ring
}                       





////////////////////////////////////////////////////////////////////////////
//                     CONSTRUCTING the new ring
////////////////////////////////////////////////////////////////////////////

proc ringchange (int i)
{    
  def R=changevar(""+varstr(basering)+",t,"+variables(nvars(basering),i)+"");// change
  return(R);                 // return the ring, needed in future proc
}



proc variables (int k,int i)
{
  list l;
  int s,u;                              // loop variables
  string str;               
  for (u=1;u<=k;u++) 
   {
     for (s=1;s<=i;s++)
     {
       str=""+atoz(u)+"("+string(s)+")"; // creates new variables    
       l[(u-1)*i+s]=str;                // saves them in a list
     }
   } 
  string str1=string(l);                // makes the list into a string,
  return(str1);                         // (needed for ring change)
}


proc atoz (int n)                        // returns nth letter of the alphabet
{ 
  if(1>n>26)                           // input admissible?
   { 
     "n must range between 1 and 26!";
      return(0); 
   } 
  string s="ring r=0,("+A_Z("a",n)+"),ds;"; 
  execute(s); 
  return (string(var(n))); 
} 





////////////////////////////////////////////////////////////////////////////
//                        AUXILIARY procedures     
////////////////////////////////////////////////////////////////////////////


proc diffidealstep (int i, int N)       // returns ideal needed for 
{                                     // differentiation in ith step
  ideal I=var(N+1+i);
  int j;
  for(j=2;j<=N;j++)
   {
     I=I,var(N+1+j*i);
   }
return(I);
}



proc order (poly f)                  // gives first elem. of Nash series
{
  poly g=homog(f,var(1));
  int k=deg(g);
  int i;
  for(i=1;i<k;i++)
    {
      if(jet(f,i)!=0)
	{
	  return(i);
        }
    }
}


proc idealsimplify (ideal I)      // simplifies the ideal according to our
{                                 // purposes 
  int i,j;
  int divisornumber=0;
  int pos;
  I=simplify(I,6);
  for(j=1;j<=ncols(I);j++)
  {
    if(size(I[j])==1)
    {
       for(i=1;i<=nvars(basering);i++)     
       {  
	  if(modd(I[j],var(i))==0)
          {
             divisornumber++;
             pos=i;
          }
       }
    }
    if(divisornumber==1)
      {
        I[j]=var(pos);
      }
    divisornumber=0;
  }
  return(I);
}





proc modd (poly f, poly g)      // the modulo-operation for polys
{
  poly result=f-(f/g)*g;
  return(result);
}



proc Hnew (intvec H)           // creates next intvec, called from trunc
{
  intvec H1=H;
  int k;
  int l=size(H);
  for(k=0;k<=l-2;k++)
  {
    if(H[l-k]<H[l-k-1])
    {
      H[l-k]=H[l-k]+1;
      break;
    }
  }
  if(H==H1)
  {
    H[l]=H[l]+1;
  }
  return(intvec(H));
}



proc idealequality (ideal I,ideal J)
{
  I=slimgb(I);
  J=slimgb(J);
  int n=ncols(I);
  int m=ncols(J);
  int i,j;
  for(i=1;i<=n;i++)
  {
    if(reduce(I[i],J)!=0)
    {
      return(0);
    }
  }
  for(j=1;j<=m;j++)
  { 
    if(reduce(J[j],I)!=0)
    {
      return(0);
    }
  } 
  return(1);
}


proc idealsimplify1 (ideal I)       // simplify - and aviod the radical!
{
  int i,j;
  I=simplify(I,6);
  for(j=2;j<=ncols(I);j++)          // reduce with higher element
  { 
    for(i=1;i<j;i++)
    { 
      if(I[i]!=0)
      {
        I[j]=modd(I[j],I[i]);
      }
    }
  }
  for(j=ncols(I)-1;j>=1;j--)        // reduce with lower elements
  { 
    for(i=ncols(I);i>j;i--)
    { 
      if(I[i]!=0)
      {
        I[j]=modd(I[j],I[i]);
      }
    }
  }
  I=simplify(idealsimplify(I),6);
  return(I);
}




proc testHempty ( poly f,int i)
{
 def r=basering;
 int k;
 int m=milnor(f);
 int mi=m*i;
 int l=order(f);
 int s0=mi+1;
 int s=l*(mi+1);
 intvec H=l;
 for(k=1;k<=mi;k++)          // initialize H
 {
   H[k+1]=1; 
 }
 while(sum(H)<=s)
 {
  for(k=2;k<=s0;k++)      
   { 
     setring r;
     def tmp=hset1(f,intvec(H[1..k]));
     setring tmp;
     "current H:";H[1..k];hresult;~;
   }
  H=Hnew(H);
 }  
}





proc minpower (poly f)   
{
 ideal J=jacob(f);
 int s=ncols(J);
 int control=0;                // control if conditions for ny are fulfilled
 int control1=0;
 int n=nvars(basering);
 int ny=1;
 int i,j;
 while (control==0)           // while var(i)^ny not in J(f)...
 {
   for(i=1;i<=n;i++)          // consider all variables 
  {
    control1=0;
    for(j=1;j<=s;j++)         // consider all elements of J
    { 
      if (modd(var(i)^ny,J[j])==0)  // var(i)^ny in J(f)?
      {
        control1=1;
        break;
      }
    }
    if (control1==0)          // increment ny if no var(i)^nt in J(f)
    {
      ny++;
      break;
    }
  }
   if (control1==1)           // if each step was successful...
  {
    control=1;
  }
 } 
 return(ny);
}



