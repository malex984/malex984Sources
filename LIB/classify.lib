//=============================================================================
// $Id: classify.lib,v 1.2 1995-02-04 19:40:47 krueger Exp $
//
//=============================================================================
// Library-loader.
//
proc Lib_lib_Classify
{
  if(defined(SLib_lib_Classify) == 1) { return(); }
  string SLib_lib_Classify="$Id: classify.lib,v 1.2 1995-02-04 19:40:47 krueger Exp $";
  verbose (noloadLib);
  string @Required="lib0,lib1,lib_Classify";
  @Required=@Required+",lib_Setring,lib_ReOrder,lib_RandomPoly,lib_Morse";
  @Required=@Required+",lib_tools,lib_Kclass,lib_Ausgaben,lib_WorkOn";
  @Required=@Required+",lib_HKclass";
  int @len = size(@Required);
  int @i;
  int @k;
  int @j;
  string @s;
  string @s1;

  for(@i=1;@i<@len;@i=@i+@k) {
    @s = @Required[@i..@len];
    @k = find(@s, ",");
    if(@k>0) { 
      @s = @Required[@i,@k-1];
    }
    else {
      @k = size(@s);
    }
    @s1 = "@j = defined(SLib_"+@s+");";
    execute @s1;
    if( @j == 0) {
      @s1 = "LIB \""+@s+"\";";
      execute @s1;
      @s1 = "Lib_"+@s+"();";
      execute @s1;
    }
  }
}

//=============================================================================
//
//
proc ShowLibs
{ 
  string @Required = LIB;
  int @len = size(@Required);
  int @i;
  int @k;
  int @j;
  string @s;
  string @s1;

  for(@i=1;@i<@len;@i=@i+@k) {
    @s = @Required[@i..@len];
    @k = find(@s, ",");
    if(@k>0) { 
      @s = @Required[@i,@k-1]; 
    }
    else {
      @k = size(@s);
    }
    @s1 = "@j = defined(SLib_"+@s+");";
    execute @s1;
    if( @j != 0) {
      @s1 = "SLib_"+@s+";";
      execute @s1;
    }
  }
}
proc Lib_lib0
{
  string SLib_lib0="lib0 - Ohne";
}
proc Lib_lib1
{
  string SLib_lib1="lib1 - Ohne";
}


//=============================================================================
// TopLevel Funktion of the Arnold-Classifier.
//
proc Classify
{
  if( #ARGS != 1 ) {
//=============================================================================
    " USAGE:   Classify(<poly>)";
    " RETURN:  Normal-Form of <poly>";
    " NOTE:    Tells the typ of f";
    " EXAMPLE: ring r;";
    "          //int DeBug=1 / 6 / 11;
    "          poly g=Classify(f);";
//=============================================================================
    return(#1);
  }
  if( typeof(#1) != "poly") {
    "Classify: argv(1) must be poly";
    return(#1);
  }
  Lib_lib_Classify();
  int @show_nf = 1;    // return Normal-form if set to '1'

  poly @f_in = #1;
  int @n = nvars(basering);
  string @RingInput = "setring " + nameof(basering) + ";";
  string @tmp = "map @Conv=" + nameof(basering) + ",";
  int @i;

  if( defined(Rtop) == 1) { kill Rtop; }
  execute Setring(@n, "Rtop");
  @tmp = @tmp + string(maxideal(1)) + ";";
  execute @tmp;
  execute RingInput;
  map ShowPoly=Rtop,maxideal(1);
  setring Rtop;
  init();
  string RingDisplay = @RingInput;

  string @s1;
  string @s2;
  string @s3;
  string @s4;
  @s1,@s2=Klassifiziere(@Conv(@f_in));
  @s4 = "poly @f_out="+@s1+";";

  setring RingB;
  execute @s4;
  setring Rtop;

  poly @f_nf = NormalForm(@s2);
  for(@i=5;@i<=@n;@i=@i+1) {
    @f_nf = @f_nf + x(@i)^2;
  }

  map @ConvUp=RingB,maxideal(1);
  poly @f_out = @ConvUp(@f_out);
  for(@i=CoRang+1;@i<=@n;@i=@i+1) {
    @f_out = @f_out + x(@i)^2;
  }
  execute @RingInput;
  map @ConvBack=Rtop,maxideal(1);

  if(@show_nf == 1) {
    return(@ConvBack(@f_nf));
  }
  else { return(@ConvBack(@f_out)); }
}
// E n d   O f   F i l e